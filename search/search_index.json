{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LeanCert","text":"<p>Verified numerical computation and bound certification for Lean 4.</p> <p>LeanCert automates proofs of inequalities, global extrema, root existence, and integration bounds using rigorous interval arithmetic and Taylor models. Unlike standard numerical libraries that provide approximations, LeanCert produces formal proofs.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Rigorous Interval Arithmetic: Computable bounds with formal correctness proofs</li> <li>Kernel-Only Verification: <code>certify_kernel</code> tactic uses <code>decide</code> for proofs trusted only by the Lean kernel</li> <li>Global Optimization: Branch-and-bound with verified lower/upper bounds</li> <li>Root Finding: Existence proofs (bisection) and uniqueness proofs (Newton contraction)</li> <li>Integration: Verified Riemann sum bounds with both rational and dyadic backends</li> <li>Bernstein Enclosure: Tight polynomial bounds via verified Bernstein basis conversion</li> <li>Neural Network Verification: Interval propagation with DeepPoly relaxations</li> <li>Transformer Verification: Multi-Head Attention, LayerNorm, GELU soundness proofs</li> <li>Counter-Example Search: <code>interval_refute</code> finds where conjectured bounds fail</li> <li>Quantifier Synthesis: Verified witnesses for <code>\u2200</code>, <code>\u2203</code>, min/max, and \u03b5-\u03b4 continuity</li> <li>Lipschitz Bounds: Derivative-based continuity certificates via Mean Value Theorem</li> <li>Adaptive Verification: Domain splitting and proof assembly for complex expressions</li> <li>Python SDK: High-level API with symbolic simplification and false-positive filtering</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":""},{"location":"#python","title":"Python","text":"<pre><code>import leancert as lc\n\nx = lc.var('x')\nexpr = x**2 + lc.sin(x)\n\n# Find rigorous bounds on [0, 1]\nresult = lc.find_bounds(expr, {'x': (0, 1)})\nprint(f\"Bounds: [{result.min_bound}, {result.max_bound}]\")\n\n# Prove root existence\nroots = lc.find_roots(x**2 - 2, {'x': (1, 2)})\n</code></pre>"},{"location":"#lean","title":"Lean","text":"<pre><code>import LeanCert.Tactic.IntervalAuto\nimport LeanCert.Tactic.Discovery\n\nopen LeanCert.Core\n\n-- Prove bounds using natural Set.Icc syntax\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x \u2264 3 := by certify_bound 15\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.sin x \u2264 1 := by certify_bound\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, 0 \u2264 Real.exp x := by certify_bound\n\n-- Prove root existence (\u221a2) via sign change\ndef I12 : IntervalRat := \u27e81, 2, by norm_num\u27e9\nexample : \u2203 x \u2208 I12, Expr.eval (fun _ =&gt; x)\n    (Expr.add (Expr.mul (Expr.var 0) (Expr.var 0)) (Expr.neg (Expr.const 2))) = 0 := by\n  interval_roots\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>LeanCert operates on a certificate-driven architecture:</p> <ol> <li>Reification: Mathematical expressions are converted to an AST (<code>LeanCert.Core.Expr</code>)</li> <li>Computation: Algorithms run on the AST using interval arithmetic</li> <li>Certification: Golden theorems lift boolean results to semantic proofs about real numbers</li> </ol> <p>This separation allows efficient computation while maintaining full formal verification.</p> <p>Two Backends: LeanCert includes both rational (<code>evalIntervalCore</code>) and dyadic (<code>evalIntervalDyadic</code>) interval arithmetic. The dyadic backend is essential for deep expressions like neural networks and integration of complex integrands (e.g., Li\u2082), where rational denominators would explode exponentially. Both backends now support all transcendental functions including <code>atanh</code>.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#lean_1","title":"Lean","text":"<p>Add to your <code>lakefile.toml</code>:</p> <pre><code>[[require]]\nname = \"leancert\"\ngit = \"https://github.com/alerad/leancert\"\nrev = \"main\"\n</code></pre>"},{"location":"#python_1","title":"Python","text":"<pre><code>pip install leancert\n</code></pre> <p>For development:</p> <pre><code>cd python\npip install -e .\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"Guide Description Quickstart Get started with Python SDK and Lean tactics Discovery Mode Interactive exploration: <code>#find_min</code>, <code>#bounds</code>, witnesses Tactics Reference Complete reference for all tactics Choosing Tactics Decision flowchart for picking the right tactic Troubleshooting Common errors and how to fix them End-to-End Example Full workflow from exploration to proof"},{"location":"#api-reference","title":"API Reference","text":"Document Description Solver API Core verification methods Quantifier Synthesis Verified <code>\u2200</code>/<code>\u2203</code> witnesses Lipschitz Bounds Derivative-based continuity Adaptive Verification Domain splitting strategies"},{"location":"#architecture_1","title":"Architecture","text":"Document Description Golden Theorems How computation connects to proofs Verification Status What's proven, what's WIP"},{"location":"#whats-verified","title":"What's Verified?","text":"<p>The core interval arithmetic, Taylor series bounds, global optimization, root finding, and integration are fully proved with no <code>sorry</code>. See Verification Status for details.</p>"},{"location":"choosing-tactics/","title":"Choosing the Right Tactic","text":"<p>Quick reference for picking the right LeanCert tactic for your goal.</p> <p>Having issues? See the Troubleshooting Guide for common errors and solutions.</p>"},{"location":"choosing-tactics/#decision-flowchart","title":"Decision Flowchart","text":"<pre><code>What do you want to prove?\n\u2502\n\u251c\u2500\u25ba \"\u2200 x \u2208 I, f(x) \u2264 c\" or \"\u2200 x \u2208 I, f(x) \u2265 c\"\n\u2502   \u2502\n\u2502   \u251c\u2500\u25ba Single variable? \u2500\u2500\u25ba certify_bound\n\u2502   \u2502                        (or certify_kernel for kernel-only trust)\n\u2502   \u2502\n\u2502   \u2514\u2500\u25ba Multiple variables? \u2500\u2500\u25ba multivariate_bound\n\u2502\n\u251c\u2500\u25ba \"\u2200 x \u2208 I, f(x) \u2260 0\"\n\u2502   \u2514\u2500\u25ba root_bound\n\u2502\n\u251c\u2500\u25ba \"\u2203 x \u2208 I, f(x) = 0\"\n\u2502   \u2514\u2500\u25ba interval_roots\n\u2502\n\u251c\u2500\u25ba \"\u2203! x \u2208 I, f(x) = 0\"\n\u2502   \u2514\u2500\u25ba interval_unique_root\n\u2502\n\u251c\u2500\u25ba \"\u2203 m, \u2200 x \u2208 I, f(x) \u2265 m\" (find minimum)\n\u2502   \u2502\n\u2502   \u251c\u2500\u25ba Single variable? \u2500\u2500\u25ba interval_minimize\n\u2502   \u2514\u2500\u25ba Multiple variables? \u2500\u2500\u25ba interval_minimize_mv\n\u2502\n\u251c\u2500\u25ba \"\u2203 M, \u2200 x \u2208 I, f(x) \u2264 M\" (find maximum)\n\u2502   \u2502\n\u2502   \u251c\u2500\u25ba Single variable? \u2500\u2500\u25ba interval_maximize\n\u2502   \u2514\u2500\u25ba Multiple variables? \u2500\u2500\u25ba interval_maximize_mv\n\u2502\n\u251c\u2500\u25ba \"\u2203 x \u2208 I, \u2200 y \u2208 I, f(x) \u2264 f(y)\" (find argmin)\n\u2502   \u2514\u2500\u25ba interval_argmin\n\u2502\n\u251c\u2500\u25ba \"\u2203 x \u2208 I, \u2200 y \u2208 I, f(y) \u2264 f(x)\" (find argmax)\n\u2502   \u2514\u2500\u25ba interval_argmax\n\u2502\n\u251c\u2500\u25ba Point inequality (\u03c0 &lt; 3.15, etc.)\n\u2502   \u2514\u2500\u25ba interval_decide\n\u2502\n\u251c\u2500\u25ba Integral bound\n\u2502   \u2514\u2500\u25ba interval_integrate\n\u2502\n\u251c\u2500\u25ba Simplify vector/matrix indexing (![a,b,c] \u27e81,h\u27e9 \u2192 b)\n\u2502   \u2514\u2500\u25ba vec_simp\n\u2502\n\u2514\u2500\u25ba Expand finite sum (\u2211 k \u2208 Icc 1 3, f k \u2192 f 1 + f 2 + f 3)\n    \u2514\u2500\u25ba finsum_expand\n</code></pre>"},{"location":"choosing-tactics/#quick-reference-table","title":"Quick Reference Table","text":"I want to prove... Tactic Example Upper bound on interval <code>certify_bound</code> <code>\u2200 x \u2208 Set.Icc 0 1, exp x \u2264 3</code> Lower bound on interval <code>certify_bound</code> <code>\u2200 x \u2208 Set.Icc 0 1, 0 \u2264 exp x</code> Bound with kernel-only trust <code>certify_kernel</code> Same goals, higher trust Multivariate bound <code>multivariate_bound</code> <code>\u2200 x \u2208 I, \u2200 y \u2208 J, x + y \u2264 2</code> Function has no roots <code>root_bound</code> <code>\u2200 x \u2208 I, x\u00b2 + 1 \u2260 0</code> Root exists <code>interval_roots</code> <code>\u2203 x \u2208 I, x\u00b2 - 2 = 0</code> Unique root exists <code>interval_unique_root</code> <code>\u2203! x \u2208 I, x\u00b2 - 2 = 0</code> Minimum exists <code>interval_minimize</code> <code>\u2203 m, \u2200 x \u2208 I, f x \u2265 m</code> Maximum exists <code>interval_maximize</code> <code>\u2203 M, \u2200 x \u2208 I, f x \u2264 M</code> Find the minimizer <code>interval_argmin</code> <code>\u2203 x \u2208 I, \u2200 y \u2208 I, f x \u2264 f y</code> Find the maximizer <code>interval_argmax</code> <code>\u2203 x \u2208 I, \u2200 y \u2208 I, f y \u2264 f x</code> Point inequality <code>interval_decide</code> <code>\u03c0 &lt; 3.15</code> Disprove a bound <code>interval_refute</code> Find counterexample Simplify vector indexing <code>vec_simp</code> <code>![a,b,c] \u27e81, h\u27e9 = b</code> Expand finite sums <code>finsum_expand</code> <code>\u2211 k \u2208 Icc 1 3, f k = f 1 + f 2 + f 3</code> Integral bound <code>interval_integrate</code> <code>\u222b x in a..b, f x \u2208 I</code>"},{"location":"choosing-tactics/#trust-levels","title":"Trust Levels","text":"Tactic Verification When to use <code>certify_kernel</code> <code>decide</code> (kernel-only) Maximum trust, slower <code>certify_bound</code> <code>native_decide</code> Good balance of trust/speed <code>certify_kernel_quick</code> <code>decide</code> (30 bits) Fast, lower precision <code>certify_kernel_precise</code> <code>decide</code> (100 bits) Tight bounds needed"},{"location":"choosing-tactics/#common-patterns","title":"Common Patterns","text":""},{"location":"choosing-tactics/#my-bound-is-too-tight-and-fails","title":"\"My bound is too tight and fails\"","text":"<pre><code>-- Try 1: Increase Taylor depth\nexample : \u2200 x \u2208 Set.Icc 0 1, exp x \u2264 2.72 := by certify_bound 20\n\n-- Try 2: Use subdivision\nexample : \u2200 x \u2208 Set.Icc 0 1, exp x \u2264 2.72 := by interval_bound_subdiv 15 3\n\n-- Try 3: Use higher precision dyadic\nexample : \u2200 x \u2208 Set.Icc 0 1, exp x \u2264 2.72 := by certify_kernel_precise\n</code></pre>"},{"location":"choosing-tactics/#i-dont-know-what-bound-to-use","title":"\"I don't know what bound to use\"","text":"<p>Use discovery tactics to find bounds first:</p> <pre><code>-- Find the actual minimum/maximum\nexample : \u2203 m, \u2200 x \u2208 Set.Icc 0 1, x^2 + sin x \u2265 m := by interval_minimize\nexample : \u2203 M, \u2200 x \u2208 Set.Icc 0 1, x^2 + sin x \u2264 M := by interval_maximize\n</code></pre> <p>Or use interactive commands:</p> <pre><code>import LeanCert.Discovery.Commands\n\n#find_min (fun x =&gt; x^2 + Real.sin x) on [0, 1]\n#find_max (fun x =&gt; x^2 + Real.sin x) on [0, 1]\n</code></pre>"},{"location":"choosing-tactics/#i-want-to-prove-both-upper-and-lower-bounds","title":"\"I want to prove both upper and lower bounds\"","text":"<p>Prove them separately and combine:</p> <pre><code>theorem exp_lower : \u2200 x \u2208 Set.Icc (0:\u211d) 1, 1 \u2264 Real.exp x := by certify_bound\ntheorem exp_upper : \u2200 x \u2208 Set.Icc (0:\u211d) 1, Real.exp x \u2264 3 := by certify_bound\n\ntheorem exp_bounded : \u2200 x \u2208 Set.Icc (0:\u211d) 1, 1 \u2264 Real.exp x \u2227 Real.exp x \u2264 3 :=\n  fun x hx =&gt; \u27e8exp_lower x hx, exp_upper x hx\u27e9\n</code></pre>"},{"location":"choosing-tactics/#native-syntax-vs-expr-ast","title":"\"Native syntax vs Expr AST\"","text":"<p>Most tactics support native syntax, but some require Expr AST:</p> Tactic Native Syntax Expr AST <code>certify_bound</code> \u2713 Recommended \u2713 Supported <code>multivariate_bound</code> \u2713 Recommended \u2713 Supported <code>interval_minimize/maximize</code> \u2713 Recommended \u2713 Supported <code>interval_roots</code> \u2713 Supported \u2713 Works well <code>root_bound</code> \u2713 Supported \u2713 Works well <code>interval_le/ge</code> (low-level) \u2717 \u2713 Required <p>Native syntax (recommended when it works): <pre><code>example : \u2200 x \u2208 Set.Icc (0:\u211d) 1, x * x \u2264 1 := by certify_bound\nexample : \u2200 x \u2208 Set.Icc (0:\u211d) 1, Real.exp x \u2264 3 := by certify_bound 15\n</code></pre></p> <p>Expr AST syntax (more control, always works): <pre><code>open LeanCert.Core in\ndef I01 : IntervalRat := \u27e80, 1, by norm_num\u27e9\n\nopen LeanCert.Core in\nexample : \u2200 x \u2208 I01, Expr.eval (fun _ =&gt; x) (Expr.mul (Expr.var 0) (Expr.var 0)) \u2264 (1 : \u211a) := by\n  certify_bound\n</code></pre></p> <p>When native syntax fails: If you get unification errors with complex expressions (especially with numeric coefficients like <code>2 * x * x</code>), switch to Expr AST. See Troubleshooting for details.</p>"},{"location":"choosing-tactics/#i-have-a-sum-over-vectorsmatrices","title":"\"I have a sum over vectors/matrices\"","text":"<p>Chain simplification tactics to reduce structured expressions before proving bounds:</p> <pre><code>-- Expand finite sum, simplify vector indexing, then close with ring\nexample (a : Fin 3 \u2192 \u211d) :\n    \u2211 k \u2208 Finset.Icc 0 2, (![a 0, a 1, a 2] : Fin 3 \u2192 \u211d) \u27e8k, by omega\u27e9 =\n    a 0 + a 1 + a 2 := by\n  finsum_expand; vec_simp\n</code></pre> <p>Common combinations: - <code>finsum_expand; ring</code> \u2014 expand sum, simplify arithmetic - <code>finsum_expand; vec_simp; ring</code> \u2014 expand sum, reduce vector indexing, simplify - <code>vec_simp; certify_bound</code> \u2014 simplify indexing, then prove bounds</p>"},{"location":"discovery/","title":"Discovery Mode","text":"<p>Discovery mode lets you explore functions before proving things about them. Find bounds, locate extrema, and get witness points\u2014all with rigorous interval arithmetic.</p>"},{"location":"discovery/#interactive-commands","title":"Interactive Commands","text":"<p>Use these in your editor to explore functions. They print results but don't produce proof terms.</p>"},{"location":"discovery/#find_min-minimize","title":"<code>#find_min</code> / <code>#minimize</code>","text":"<p>Find the global minimum of a function on a domain.</p> <pre><code>import LeanCert.Discovery.Commands\n\n-- Single variable\n#find_min (fun x =&gt; x^2 + Real.sin x) on [-2, 2]\n\n-- With custom precision (Taylor depth)\n#find_min (fun x =&gt; Real.exp x - x) on [0, 2] precision 20\n\n-- Multivariate (product of intervals)\n#find_min (fun x y =&gt; x^2 + y^2 - x*y) on [-1, 1] \u00d7 [-1, 1]\n</code></pre> <p>Output: <pre><code>\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n#find_min Results\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n  Minimum bound: -0.210796\n  Upper bound:   -0.209012\n  Width:         0.001784\n  Iterations:    847\n  Verified:      \u2713 (rigorous interval arithmetic)\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n</code></pre></p>"},{"location":"discovery/#find_max-maximize","title":"<code>#find_max</code> / <code>#maximize</code>","text":"<p>Find the global maximum.</p> <pre><code>#find_max (fun x =&gt; Real.sin x * Real.exp (-x)) on [0, 3]\n</code></pre>"},{"location":"discovery/#bounds","title":"<code>#bounds</code>","text":"<p>Find both minimum and maximum in one call.</p> <pre><code>#bounds (fun x =&gt; x^3 - x) on [-2, 2]\n</code></pre> <p>Output: <pre><code>\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n#bounds Results\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n  f(x) \u2208 [-1.154, 1.154]\n\n  Minimum: -1.154 (\u00b1 0.002)\n  Maximum: 1.154 (\u00b1 0.002)\n\n  Total iterations: 1247\n  Verified: \u2713\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n</code></pre></p>"},{"location":"discovery/#eval_interval","title":"<code>#eval_interval</code>","text":"<p>Quick interval evaluation without optimization (just propagate intervals through the expression).</p> <pre><code>#eval_interval (fun x =&gt; Real.exp (Real.sin x)) on [0, 1]\n</code></pre>"},{"location":"discovery/#tactics-for-proofs","title":"Tactics for Proofs","text":"<p>These tactics produce actual proof terms.</p>"},{"location":"discovery/#interval_minimize","title":"<code>interval_minimize</code>","text":"<p>Prove that a minimum exists by finding it.</p> <pre><code>-- Prove: \u2203 m, \u2200 x \u2208 [0,1], x\u00b2 + sin(x) \u2265 m\nexample : \u2203 m : \u211a, \u2200 x \u2208 Set.Icc (0:\u211d) 1, x^2 + Real.sin x \u2265 m := by\n  interval_minimize\n</code></pre>"},{"location":"discovery/#interval_maximize","title":"<code>interval_maximize</code>","text":"<p>Prove that a maximum exists by finding it.</p> <pre><code>-- Prove: \u2203 M, \u2200 x \u2208 [0,1], sin(x) \u2264 M\nexample : \u2203 M : \u211a, \u2200 x \u2208 Set.Icc (0:\u211d) 1, Real.sin x \u2264 M := by\n  interval_maximize\n</code></pre>"},{"location":"discovery/#interval_roots","title":"<code>interval_roots</code>","text":"<p>Prove root existence via sign change (intermediate value theorem).</p> <pre><code>-- Prove \u221a2 exists\ndef I12 : IntervalRat := \u27e81, 2, by norm_num\u27e9\n\nexample : \u2203 x \u2208 I12, x^2 = 2 := by\n  interval_roots\n</code></pre>"},{"location":"discovery/#programmatic-api","title":"Programmatic API","text":"<p>For more control, use the API directly.</p>"},{"location":"discovery/#with-witnesses","title":"With Witnesses","text":"<p>Get not just the bound, but also an approximate location of the extremum:</p> <pre><code>import LeanCert.Engine.Optimization.BoundVerify\n\nopen LeanCert.Core LeanCert.Engine.Optimization\n\ndef e := Expr.add (Expr.mul (Expr.var 0) (Expr.var 0)) (Expr.sin (Expr.var 0))\ndef I : IntervalRat := \u27e8-2, 2, by norm_num\u27e9\n\n#eval\n  let result := findMin1WithWitness e I {}\n  s!\"min \u2248 {result.computedBound}, argmin \u2248 {result.witness.coords}, \u03b5 = {result.epsilon}\"\n</code></pre> <p>Output: <pre><code>min \u2248 -0.210, argmin \u2248 [-0.4502], \u03b5 = 0.001\n</code></pre></p>"},{"location":"discovery/#available-functions","title":"Available Functions","text":"Function Description <code>findMinWithWitness</code> Find minimum with witness point <code>findMaxWithWitness</code> Find maximum with witness point <code>verifyUpperBoundWithWitness</code> Verify f(x) \u2264 bound, get argmax <code>verifyLowerBoundWithWitness</code> Verify f(x) \u2265 bound, get argmin <p>Single-variable versions: <code>findMin1WithWitness</code>, <code>findMax1WithWitness</code>, etc.</p>"},{"location":"discovery/#result-structure","title":"Result Structure","text":"<pre><code>structure BoundVerifyResult where\n  verified : Bool           -- Did verification succeed?\n  computedBound : \u211a         -- The computed bound\n  witness : WitnessPoint    -- Approximate argmin/argmax\n  epsilon : \u211a               -- Width of best box (precision)\n  iterations : Nat          -- Iterations used\n\nstructure WitnessPoint where\n  coords : List \u211a           -- Coordinates of witness point\n  boxWidth : \u211a              -- Width of containing box\n</code></pre>"},{"location":"discovery/#configuration","title":"Configuration","text":"<p>Control precision and iteration limits:</p> <pre><code>let cfg : BoundVerifyConfig := {\n  taylorDepth := 15,        -- Taylor series terms (default: 10)\n  tolerance := 1/10000,     -- Stop when box width &lt; tolerance\n  maxIterations := 2000,    -- Iteration limit (default: 1000)\n  useMonotonicity := true   -- Use gradient info to prune (default: true)\n}\n\nlet result := findMinWithWitness e box cfg\n</code></pre>"},{"location":"discovery/#workflow-explore-prove","title":"Workflow: Explore \u2192 Prove","text":"<p>A typical workflow:</p> <pre><code>-- 1. Explore: What's the minimum of x\u00b2 + sin(x) on [-2, 2]?\n#find_min (fun x =&gt; x^2 + Real.sin x) on [-2, 2]\n-- Output: min \u2248 -0.210\n\n-- 2. Prove: Now that we know it's around -0.21, prove a bound\nexample : \u2200 x \u2208 Set.Icc (-2:\u211d) 2, x^2 + Real.sin x \u2265 -1/4 := by\n  certify_bound\n\n-- 3. Or prove the existential directly\nexample : \u2203 m : \u211a, \u2200 x \u2208 Set.Icc (-2:\u211d) 2, x^2 + Real.sin x \u2265 m := by\n  interval_minimize\n</code></pre>"},{"location":"discovery/#python-sdk","title":"Python SDK","text":"<p>The Python SDK supports discovery:</p> <pre><code>import leancert as lc\n\nx = lc.var('x')\nexpr = x**2 + lc.sin(x)\n\n# Find bounds (min and max)\nresult = lc.find_bounds(expr, {'x': (-2, 2)})\nprint(f\"min \u2208 [{result.min_lo}, {result.min_hi}]\")\nprint(f\"max \u2208 [{result.max_lo}, {result.max_hi}]\")\n\n# Verify a bound (returns bool)\nverified = lc.verify_bound(expr, {'x': (-2, 2)}, lower=-0.25)\nprint(f\"Verified: {verified}\")\n</code></pre> <p>For witnesses (approximate argmin/argmax), use the quantifier synthesis API:</p> <pre><code>from leancert import Solver, synthesize_minimum, var, sin\n\nx = var('x')\nexpr = x**2 + sin(x)\n\nresult = synthesize_minimum(Solver(), expr, {'x': (-2, 2)})\nprint(f\"Success: {result.success}\")\nprint(f\"Witness point: {result.witnesses[0].value}\")  # {'x': -0.45...}\nprint(f\"Rigorous bounds: {result.witnesses[0].rigorous_bounds}\")\n</code></pre>"},{"location":"end-to-end-example/","title":"End-to-End Example: Python to Lean","text":"<p>This guide shows a complete workflow: explore in Python, generate a certificate, verify in Lean.</p>"},{"location":"end-to-end-example/#the-problem","title":"The Problem","text":"<p>We want to prove that <code>x\u00b2 + sin(x) \u2264 2</code> for all <code>x \u2208 [0, 1]</code>.</p>"},{"location":"end-to-end-example/#step-1-explore-in-python","title":"Step 1: Explore in Python","text":"<pre><code>import leancert as lc\n\n# Define the expression\nx = lc.var('x')\nexpr = x**2 + lc.sin(x)\n\n# Find bounds on [0, 1]\nresult = lc.find_bounds(expr, {'x': (0, 1)})\n\nprint(f\"Minimum: {result.min_bound}\")  # ~0\nprint(f\"Maximum: {result.max_bound}\")  # ~1.84\n</code></pre> <p>Output: <pre><code>Minimum: Interval(0, 0.001)\nMaximum: Interval(1.83, 1.85)\n</code></pre></p> <p>The maximum is around 1.84, so <code>\u2264 2</code> should be provable.</p>"},{"location":"end-to-end-example/#step-2-verify-the-bound","title":"Step 2: Verify the Bound","text":"<pre><code># Verify our proposed bound\nverified = lc.verify_bound(expr, {'x': (0, 1)}, upper=2)\nprint(f\"Verified: {verified}\")  # True\n</code></pre>"},{"location":"end-to-end-example/#step-3-generate-lean-code","title":"Step 3: Generate Lean Code","text":"<pre><code># Get the Lean tactic\nprint(result.certificate.to_lean_tactic())\n</code></pre> <p>Output: <pre><code>certify_bound 10\n</code></pre></p>"},{"location":"end-to-end-example/#step-4-prove-in-lean","title":"Step 4: Prove in Lean","text":"<p>Create a Lean file with the formal proof:</p> <pre><code>import LeanCert\n\n-- The theorem we want to prove\ntheorem xsq_plus_sin_bounded :\n    \u2200 x \u2208 Set.Icc (0 : \u211d) 1, x^2 + Real.sin x \u2264 2 := by\n  certify_bound\n</code></pre> <p>That's it! The proof is now formally verified by Lean's kernel.</p>"},{"location":"end-to-end-example/#complete-working-example","title":"Complete Working Example","text":""},{"location":"end-to-end-example/#python-script-explorepy","title":"Python Script (<code>explore.py</code>)","text":"<pre><code>#!/usr/bin/env python3\nimport leancert as lc\n\n# 1. Define expression\nx = lc.var('x')\nexpr = x**2 + lc.sin(x)\ndomain = {'x': (0, 1)}\n\n# 2. Explore bounds\nprint(\"=== Exploring x\u00b2 + sin(x) on [0, 1] ===\")\nresult = lc.find_bounds(expr, domain)\nprint(f\"Range: [{result.min_bound.lo:.4f}, {result.max_bound.hi:.4f}]\")\n\n# 3. Verify specific bound\nbound = 2\nif lc.verify_bound(expr, domain, upper=bound):\n    print(f\"\\n\u2713 Verified: x\u00b2 + sin(x) \u2264 {bound} on [0, 1]\")\n    print(f\"\\nLean proof:\")\n    print(f\"  theorem my_bound : \u2200 x \u2208 Set.Icc (0:\u211d) 1, x^2 + Real.sin x \u2264 {bound} := by\")\n    print(f\"    certify_bound\")\nelse:\n    print(f\"\\n\u2717 Could not verify bound {bound}\")\n\n# 4. Find roots (bonus)\nprint(\"\\n=== Finding roots of x\u00b2 - 2 on [1, 2] ===\")\nroots = lc.find_roots(x**2 - 2, {'x': (1, 2)})\nfor r in roots.intervals:\n    print(f\"Root in [{r.lo:.6f}, {r.hi:.6f}]\")\n</code></pre>"},{"location":"end-to-end-example/#lean-file-verifiedlean","title":"Lean File (<code>Verified.lean</code>)","text":"<pre><code>import LeanCert\n\n/-!\n# Verified Bounds\n\nThese theorems were discovered using the Python SDK and\nformally verified by LeanCert.\n-/\n\n/-- x\u00b2 + sin(x) \u2264 2 on [0, 1] -/\ntheorem xsq_plus_sin_le_2 :\n    \u2200 x \u2208 Set.Icc (0 : \u211d) 1, x^2 + Real.sin x \u2264 2 := by\n  certify_bound\n\n/-- \u221a2 exists in [1, 2] -/\ntheorem sqrt2_exists :\n    \u2203 x \u2208 Set.Icc (1 : \u211d) 2, x^2 = 2 := by\n  interval_roots\n\n/-- \u221a2 is unique in [1, 2] -/\ntheorem sqrt2_unique :\n    \u2203! x \u2208 Set.Icc (1 : \u211d) 2, x * x - 2 = 0 := by\n  interval_unique_root\n</code></pre>"},{"location":"end-to-end-example/#workflow-summary","title":"Workflow Summary","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      Python SDK                         \u2502\n\u2502  \u2022 Symbolic expression building                         \u2502\n\u2502  \u2022 Fast numerical exploration                           \u2502\n\u2502  \u2022 Bound verification with false-positive filtering     \u2502\n\u2502  \u2022 Certificate generation                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 Certificate \u2502\n                    \u2502  (tactic +  \u2502\n                    \u2502   params)   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Lean                             \u2502\n\u2502  \u2022 Formal proof term generation                         \u2502\n\u2502  \u2022 Kernel verification (no trust in Python)            \u2502\n\u2502  \u2022 Auditable, reproducible guarantee                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key insight: Python is an untrusted oracle. It finds candidates quickly, but Lean independently verifies everything. A bug in Python cannot produce a false theorem\u2014Lean's kernel is the final arbiter.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide walks through the main use cases for LeanCert.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install leancert\n</code></pre> <p>That's it - no Lean installation required. The package includes a pre-compiled verification engine.</p>"},{"location":"quickstart/#python-sdk","title":"Python SDK","text":""},{"location":"quickstart/#finding-bounds","title":"Finding Bounds","text":"<pre><code>import leancert as lc\n\nx = lc.var('x')\nexpr = x**2 + lc.sin(x)\n\n# Find min/max on an interval\nresult = lc.find_bounds(expr, {'x': (0, 1)})\n\nprint(f\"Minimum: {result.min_bound}\")\nprint(f\"Maximum: {result.max_bound}\")\n</code></pre>"},{"location":"quickstart/#verifying-a-bound","title":"Verifying a Bound","text":"<pre><code># Verify that x^2 + sin(x) \u2264 2 on [0, 1]\n# Uses adaptive method with false positive filtering by default\nverified = lc.verify_bound(expr, {'x': (0, 1)}, upper=2)\n\nif verified:\n    print(\"Bound verified!\")\n\n# For a certificate that can be exported to Lean, use find_bounds:\nresult = lc.find_bounds(expr, {'x': (0, 1)})\nif result.max_bound.hi &lt;= 2:\n    print(result.certificate.to_lean_tactic())\n</code></pre>"},{"location":"quickstart/#finding-roots","title":"Finding Roots","text":"<pre><code># Find where x^2 - 2 = 0 on [1, 2]\nroots = lc.find_roots(x**2 - 2, {'x': (1, 2)})\n\nfor root in roots.intervals:\n    print(f\"Root in [{root.lo}, {root.hi}]\")\n</code></pre>"},{"location":"quickstart/#symbolic-simplification","title":"Symbolic Simplification","text":"<p>LeanCert automatically simplifies expressions to avoid interval explosion:</p> <pre><code># Without simplification: (x*100 + 5) - (x*100) would have wide bounds\n# With simplification: reduces to 5\nexpr = (x * 100 + 5) - (x * 100)\nsimplified = lc.simplify(expr)  # Returns const(5)\n</code></pre>"},{"location":"quickstart/#lean-tactics","title":"Lean Tactics","text":""},{"location":"quickstart/#point-inequalities-interval_decide","title":"Point Inequalities (<code>interval_decide</code>)","text":"<p>To prove inequalities involving specific numbers (including transcendentals like \u03c0 or e), use <code>interval_decide</code>:</p> <pre><code>import LeanCert.Tactic.IntervalAuto\n\n-- Proves \u03c0 &lt; 3.15\nexample : Real.pi &lt; 3.15 := by interval_decide\n\n-- Proves e &lt; 3\nexample : Real.exp 1 &lt; 3 := by interval_decide\n\n-- For complex expressions with constants\nexample : Real.sin 1 + Real.cos 1 &lt; 1.5 := by interval_decide\n</code></pre>"},{"location":"quickstart/#proving-bounds-certify_bound","title":"Proving Bounds (<code>certify_bound</code>)","text":"<pre><code>import LeanCert.Tactic.IntervalAuto\n\nopen LeanCert.Core\n\n-- Use natural Set.Icc syntax with integer bounds\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x \u2264 3 := by certify_bound 15\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.sin x \u2264 1 := by certify_bound\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, 0 \u2264 Real.exp x := by certify_bound\n\n-- Lower bounds work too\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, 0 \u2264 x * x := by certify_bound\n\n-- Or use explicit IntervalRat for more control\ndef I01 : IntervalRat := \u27e80, 1, by norm_num\u27e9\nexample : \u2200 x \u2208 I01, Real.exp x \u2264 (3 : \u211a) := by certify_bound 15\n</code></pre>"},{"location":"quickstart/#kernel-verified-bounds-certify_kernel","title":"Kernel-Verified Bounds (<code>certify_kernel</code>)","text":"<p>For higher trust, use <code>certify_kernel</code>. Unlike <code>certify_bound</code> which trusts the Lean compiler (<code>native_decide</code>), <code>certify_kernel</code> uses the dyadic backend and reduces proofs entirely within the Lean kernel (<code>decide</code>) when possible.</p> <pre><code>import LeanCert.Tactic.DyadicAuto\n\n-- Same syntax as certify_bound, but uses dyadic backend\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, x * x + Real.sin x \u2264 2 := by\n  certify_kernel\n\n-- Increase precision (bits) for tight bounds\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x \u2264 2.72 := by\n  certify_kernel 100\n\n-- Convenience variants\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x \u2264 2.72 := by\n  certify_kernel_precise  -- 100 bits precision\n\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, x * x \u2264 2 := by\n  certify_kernel_quick    -- 30 bits, faster\n</code></pre> Tactic Backend Verification Trust Level <code>certify_bound</code> Rational <code>native_decide</code> Compiler + Runtime <code>certify_kernel</code> Dyadic <code>decide</code> (when possible) Kernel only"},{"location":"quickstart/#finding-counter-examples-interval_refute","title":"Finding Counter-Examples (<code>interval_refute</code>)","text":"<p>If a bound doesn't hold, use <code>interval_refute</code> to find a counter-example:</p> <pre><code>import LeanCert.Tactic.Refute\n\n-- A false theorem - interval_refute finds where it fails\nexample : \u2200 x \u2208 Set.Icc (-2 : \u211d) 2, x * x \u2264 3 := by\n  interval_refute\n  -- Output: Counter-example found at x \u2248 \u00b12, where x\u00b2 = 4 &gt; 3\n</code></pre>"},{"location":"quickstart/#proving-root-existence","title":"Proving Root Existence","text":"<pre><code>import LeanCert.Tactic.Discovery\n\nopen LeanCert.Core\n\ndef I12 : IntervalRat := \u27e81, 2, by norm_num\u27e9\n\n-- Prove \u221a2 exists via sign change\nexample : \u2203 x \u2208 I12, Expr.eval (fun _ =&gt; x)\n    (Expr.add (Expr.mul (Expr.var 0) (Expr.var 0)) (Expr.neg (Expr.const 2))) = 0 := by\n  interval_roots\n</code></pre>"},{"location":"quickstart/#multivariate-bounds","title":"Multivariate Bounds","text":"<pre><code>import LeanCert.Tactic.IntervalAuto\n\n-- Prove bounds over multiple variables\nexample : \u2200 x \u2208 Set.Icc (0:\u211d) 1, \u2200 y \u2208 Set.Icc (0:\u211d) 1,\n    x + y \u2264 (2 : \u211a) := by\n  multivariate_bound\n\nexample : \u2200 x \u2208 Set.Icc (0:\u211d) 1, \u2200 y \u2208 Set.Icc (0:\u211d) 1, \u2200 z \u2208 Set.Icc (0:\u211d) 1,\n    x + y + z \u2264 (3 : \u211a) := by\n  multivariate_bound\n</code></pre>"},{"location":"quickstart/#proving-absence-of-roots","title":"Proving Absence of Roots","text":"<pre><code>import LeanCert.Tactic.IntervalAuto\n\nopen LeanCert.Core\n\ndef I01 : IntervalRat := \u27e80, 1, by norm_num\u27e9\n\n-- Prove f(x) \u2260 0 by showing function stays positive/negative\nexample : \u2200 x \u2208 I01, Expr.eval (fun _ =&gt; x)\n    (Expr.add (Expr.mul (Expr.var 0) (Expr.var 0)) (Expr.const 1)) \u2260 (0 : \u211d) := by\n  root_bound\n</code></pre>"},{"location":"quickstart/#discovery-commands","title":"Discovery Commands","text":"<p>For interactive exploration in the editor:</p> <pre><code>import LeanCert.Discovery.Commands\n\n-- Find the global minimum\n#find_min (fun x =&gt; x^2 + Real.sin x) on [-2, 2]\n\n-- Explore function behavior\n#explore (Expr.cos (Expr.var 0)) on [0, 4]\n</code></pre>"},{"location":"quickstart/#discovering-bounds-existential","title":"Discovering Bounds (Existential)","text":"<pre><code>import LeanCert.Tactic.Discovery\n\n-- Automatically find and prove a minimum exists\nexample : \u2203 m : \u211a, \u2200 x \u2208 Set.Icc (0:\u211d) 1, x^2 \u2265 m := by\n  interval_minimize\n\n-- Find maximum\nexample : \u2203 M : \u211a, \u2200 x \u2208 Set.Icc (0:\u211d) 1, x^2 \u2264 M := by\n  interval_maximize\n\n-- Multivariate optimization\nexample : \u2203 m : \u211a, \u2200 x \u2208 Set.Icc (0:\u211d) 1, \u2200 y \u2208 Set.Icc (0:\u211d) 1,\n    x*x + y*y \u2265 m := by\n  interval_minimize_mv\n</code></pre>"},{"location":"quickstart/#high-performance-dyadic-backend","title":"High-Performance Dyadic Backend","text":"<p>For deep expressions (neural networks, optimization loops, nested transcendentals), use the dyadic backend to avoid rational denominator explosion:</p> <pre><code>import LeanCert.Engine.IntervalEvalDyadic\n\nopen LeanCert.Core LeanCert.Engine\n\n-- Convert interval to dyadic\ndef I : IntervalDyadic := IntervalDyadic.ofIntervalRat \u27e80, 1, by norm_num\u27e9 (-53)\n\n-- Evaluate with standard precision (53 bits)\ndef result := evalIntervalDyadic expr (fun _ =&gt; I) {}\n\n-- Use fast mode for very deep expressions\ndef fast := evalIntervalDyadic expr (fun _ =&gt; I) DyadicConfig.fast\n\n-- Use high precision for tight bounds\ndef precise := evalIntervalDyadic expr (fun _ =&gt; I) DyadicConfig.highPrecision\n</code></pre> <p>The dyadic backend keeps mantissa size bounded regardless of expression depth, while rational denominators grow exponentially.</p>"},{"location":"quickstart/#direct-api","title":"Direct API","text":"<p>For more control, use the certificate API directly:</p> <pre><code>import LeanCert.Validity\n\nopen LeanCert.Core LeanCert.Engine LeanCert.Validity\n\ndef exprXSq : Expr := Expr.mul (Expr.var 0) (Expr.var 0)\n\ndef exprXSq_core : ExprSupportedCore exprXSq :=\n  ExprSupportedCore.mul (ExprSupportedCore.var 0) (ExprSupportedCore.var 0)\n\ndef I01 : IntervalRat := \u27e80, 1, by norm_num\u27e9\n\n-- Use native_decide to verify computationally\ntheorem xsq_le_one : \u2200 x \u2208 I01, Expr.eval (fun _ =&gt; x) exprXSq \u2264 (1 : \u211a) :=\n  verify_upper_bound exprXSq exprXSq_core I01 1 {} (by native_decide)\n</code></pre>"},{"location":"tactics/","title":"Lean Tactics Reference","text":"<p>Complete reference for all LeanCert tactics.</p>"},{"location":"tactics/#bound-proving","title":"Bound Proving","text":""},{"location":"tactics/#certify_bound","title":"<code>certify_bound</code>","text":"<p>Proves universal bounds over intervals using rational interval arithmetic.</p> <pre><code>import LeanCert.Tactic.IntervalAuto\n\n-- Basic usage\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x \u2264 3 := by certify_bound\n\n-- With Taylor depth (higher = tighter bounds, slower)\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x \u2264 2.72 := by certify_bound 15\n\n-- Lower bounds\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, 0 \u2264 Real.exp x := by certify_bound\n\n-- Strict inequalities\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x &lt; 3 := by certify_bound\n</code></pre> <p>Note: <code>interval_bound</code> is an alias for backward compatibility.</p> <p>Parameters:</p> Parameter Type Default Description <code>depth</code> <code>\u2115</code> 10 Taylor series depth for transcendentals <p>Supported functions: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code> (rational exponents), <code>abs</code>, <code>max</code>, <code>min</code>, <code>sin</code>, <code>cos</code>, <code>exp</code>, <code>sqrt</code>, <code>sinh</code>, <code>cosh</code>, <code>tanh</code>, <code>atan</code>, <code>arsinh</code>, <code>atanh</code>, <code>sinc</code>, <code>erf</code>, <code>log</code>, <code>inv</code></p> <p>Note on rational exponents: general rational exponents like <code>x^(1/3)</code> are lowered to <code>exp(log(x) * q)</code>, which requires the base to be provably positive from interval bounds.</p>"},{"location":"tactics/#certify_kernel","title":"<code>certify_kernel</code>","text":"<p>Proves bounds using dyadic arithmetic. Attempts kernel-only verification (<code>decide</code>) first, falls back to <code>native_decide</code>.</p> <pre><code>import LeanCert.Tactic.DyadicAuto\n\n-- Default precision (53 bits)\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, x * x \u2264 2 := by certify_kernel\n\n-- Custom precision (bits)\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x \u2264 2.72 := by certify_kernel 100\n\n-- Convenience variants\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x \u2264 2.72 := by certify_kernel_precise  -- 100 bits\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, x * x \u2264 2 := by certify_kernel_quick           -- 30 bits\n</code></pre> <p>Note: <code>fast_bound</code> is an alias for backward compatibility.</p> <p>Trust levels:</p> Verification Trusted Components <code>decide</code> (kernel) Lean kernel only <code>native_decide</code> (fallback) Lean kernel + compiler <p>Diagnostics: Enable <code>set_option trace.certify_kernel true</code> to see why kernel verification fails.</p>"},{"location":"tactics/#interval_decide","title":"<code>interval_decide</code>","text":"<p>Proves point inequalities involving specific numbers (transcendentals like \u03c0, e).</p> <pre><code>import LeanCert.Tactic.IntervalAuto\n\nexample : Real.pi &lt; 3.15 := by interval_decide\nexample : Real.exp 1 &lt; 3 := by interval_decide\nexample : Real.sin 1 + Real.cos 1 &lt; 1.5 := by interval_decide\nexample : Real.sqrt 2 &lt; 1.42 := by interval_decide\n</code></pre> <p>Use this for concrete values. For universally quantified bounds, use <code>certify_bound</code>.</p>"},{"location":"tactics/#counter-example-search","title":"Counter-Example Search","text":""},{"location":"tactics/#interval_refute","title":"<code>interval_refute</code>","text":"<p>Searches for counter-examples to disprove false bounds.</p> <pre><code>import LeanCert.Tactic.Refute\n\n-- This bound is false (x\u00b2 can reach 4 on [-2, 2])\nexample : \u2200 x \u2208 Set.Icc (-2 : \u211d) 2, x * x \u2264 3 := by\n  interval_refute\n  -- Output: Counter-example found at x \u2248 \u00b12, where x\u00b2 = 4 &gt; 3\n</code></pre> <p>Output types:</p> Result Meaning <code>Verified</code> Rigorous proof that bound fails at this point <code>Candidate</code> Likely counter-example (may be precision artifact) <p>Configuration:</p> <pre><code>-- With custom settings\nexample : ... := by\n  interval_refute (config := { maxIterations := 100, tolerance := 1e-6 })\n</code></pre>"},{"location":"tactics/#discovery-tactics","title":"Discovery Tactics","text":""},{"location":"tactics/#interval_minimize-interval_maximize","title":"<code>interval_minimize</code> / <code>interval_maximize</code>","text":"<p>Proves existence of global minimum/maximum via branch-and-bound optimization.</p> <pre><code>import LeanCert.Tactic.Discovery\n\n-- Find and prove a lower bound exists\nexample : \u2203 m, \u2200 x \u2208 Set.Icc (0 : \u211d) 2, x * x - x \u2265 m := by\n  interval_minimize\n\n-- With Taylor depth\nexample : \u2203 m, \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.sin x \u2265 m := by\n  interval_minimize 15\n</code></pre>"},{"location":"tactics/#interval_roots","title":"<code>interval_roots</code>","text":"<p>Proves root existence via sign change detection (Intermediate Value Theorem).</p> <p>Native syntax (recommended):</p> <pre><code>import LeanCert.Tactic.Discovery\n\n-- Prove \u221a2 exists in [1, 2]\nexample : \u2203 x \u2208 Set.Icc (1 : \u211d) 2, x^2 - 2 = 0 := by\n  interval_roots\n\n-- Also supports f(x) = c form\nexample : \u2203 x \u2208 Set.Icc (1 : \u211d) 2, x^2 = 2 := by\n  interval_roots\n\n-- Transcendental roots\nexample : \u2203 x \u2208 Set.Icc (1 : \u211d) 2, Real.cos x = 0 := by\n  interval_roots\n</code></pre> <p>Expr AST syntax (also supported):</p> <pre><code>open LeanCert.Core\n\ndef I12 : IntervalRat := \u27e81, 2, by norm_num\u27e9\n\nexample : \u2203 x \u2208 I12, Expr.eval (fun _ =&gt; x)\n    (Expr.add (Expr.mul (Expr.var 0) (Expr.var 0)) (Expr.neg (Expr.const 2))) = 0 := by\n  interval_roots\n</code></pre> <p>How it works: 1. Evaluates expression at interval endpoints 2. Detects sign change (f(lo) &lt; 0 &lt; f(hi) or vice versa) 3. Applies IVT to prove existence</p>"},{"location":"tactics/#interval_unique_root","title":"<code>interval_unique_root</code>","text":"<p>Proves root uniqueness via Newton contraction mapping.</p> <p>Native syntax (recommended):</p> <pre><code>import LeanCert.Tactic.Discovery\n\n-- Prove there's exactly one root of x\u00b2 - 2 in [1, 2]\nexample : \u2203! x \u2208 Set.Icc (1 : \u211d) 2, x^2 - 2 = 0 := by\n  interval_unique_root\n</code></pre> <p>Expr AST syntax (also supported):</p> <pre><code>open LeanCert.Core\n\ndef I12 : IntervalRat := \u27e81, 2, by norm_num\u27e9\ndef expr_x2_minus_2 : Expr := Expr.add (Expr.mul (Expr.var 0) (Expr.var 0)) (Expr.neg (Expr.const 2))\n\nexample : \u2203! x \u2208 I12, Expr.eval (fun _ =&gt; x) expr_x2_minus_2 = 0 := by\n  interval_unique_root\n</code></pre> <p>How it works: 1. Computes Newton operator N(x) = x - f(x)/f'(x) 2. Verifies N maps interval into itself 3. Verifies |N'(x)| &lt; 1 (contraction) 4. Banach fixed-point theorem gives uniqueness</p>"},{"location":"tactics/#interval_integrate","title":"<code>interval_integrate</code>","text":"<p>Proves bounds on definite integrals via verified Riemann sums.</p> <pre><code>import LeanCert.Tactic.Discovery\n\nopen LeanCert.Core LeanCert.Validity.Integration\n\ndef I01 : IntervalRat := \u27e80, 1, by norm_num\u27e9\n\n-- Prove integral is contained in computed interval\nexample : \u222b x in (I01.lo : \u211d)..(I01.hi : \u211d),\n    Expr.eval (fun _ =&gt; x) (Expr.mul (Expr.var 0) (Expr.var 0)) \u2208\n    integrateInterval1Core (Expr.mul (Expr.var 0) (Expr.var 0)) I01 {} := by\n  interval_integrate\n</code></pre> <p>How it works: 1. Partitions interval into subintervals 2. Computes interval bounds on each partition 3. Sums (width \u00d7 bound) for rigorous over/under-approximation</p> <p>Note: The tactic proves membership in the computed interval, not a direct inequality.</p>"},{"location":"tactics/#interactive-commands","title":"Interactive Commands","text":"<p>These commands are for exploration in the editor, not for proofs. Use them to discover bounds before writing theorems.</p>"},{"location":"tactics/#bounds","title":"<code>#bounds</code>","text":"<p>Find both minimum and maximum of a function on an interval.</p> <pre><code>import LeanCert.Discovery.Commands\n\n#bounds (fun x =&gt; x^2 + Real.sin x) on [-2, 2]\n</code></pre> <p>Output: <pre><code>\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n#bounds Results\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n  f(x) \u2208 [-5, 5]\n\n  Minimum: -5 (\u00b1 4.77)\n  Maximum: 5 (\u00b1 0.91)\n\n  Total iterations: 32\n  Verified: \u2713\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n</code></pre></p>"},{"location":"tactics/#find_min-find_max","title":"<code>#find_min</code> / <code>#find_max</code>","text":"<p>Find the minimum or maximum separately, with optional precision control.</p> <pre><code>import LeanCert.Discovery.Commands\n\n-- Basic usage\n#find_min (fun x =&gt; x^2 + Real.sin x) on [-2, 2]\n#find_max (fun x =&gt; Real.exp x - x^2) on [0, 1]\n\n-- Higher precision for tighter bounds\n#find_max (fun x =&gt; Real.exp x) on [0, 1] precision 20\n</code></pre> <p>Syntax: <pre><code>#find_min &lt;function&gt; on [&lt;lo&gt;, &lt;hi&gt;]\n#find_min &lt;function&gt; on [&lt;lo&gt;, &lt;hi&gt;] precision &lt;n&gt;\n</code></pre></p> <p>Parameters: - <code>function</code>: A lambda <code>(fun x =&gt; ...)</code> with the expression - <code>lo</code>, <code>hi</code>: Integer bounds (rationals not supported in syntax) - <code>precision</code>: Optional Taylor depth (default: 10)</p>"},{"location":"tactics/#explore","title":"<code>#explore</code>","text":"<p>Interactive function analysis in the editor. Shows range, extrema, and roots.</p> <pre><code>import LeanCert.Tactic.Discovery\n\n-- Explore sin(x) on [0, 4]\n#explore (Expr.sin (Expr.var 0)) on [0, 4]\n</code></pre> <p>Output includes: - Domain and computed range - Global minimum and maximum with locations - Sign changes (potential roots) - Monotonicity information</p>"},{"location":"tactics/#comparison-table","title":"Comparison Table","text":"Tactic Purpose Trust Speed <code>certify_bound</code> Prove bounds <code>native_decide</code> Medium <code>certify_kernel</code> Prove bounds <code>decide</code> / fallback Fast <code>interval_decide</code> Point inequalities <code>native_decide</code> Fast <code>interval_refute</code> Find counter-examples Verified Slow <code>interval_roots</code> Prove root exists <code>native_decide</code> Medium <code>interval_unique_root</code> Prove root unique <code>native_decide</code> Slow <code>interval_minimize</code> Prove min exists <code>native_decide</code> Slow <code>interval_maximize</code> Prove max exists <code>native_decide</code> Slow <code>interval_integrate</code> Prove integral bounds <code>native_decide</code> Medium <code>discover</code> Auto-route min/max <code>native_decide</code> Slow <code>interval_minimize_mv</code> Multivariate min <code>native_decide</code> Slow <code>interval_maximize_mv</code> Multivariate max <code>native_decide</code> Slow <code>multivariate_bound</code> N-dim bounds <code>native_decide</code> Medium <code>root_bound</code> Prove f(x) \u2260 0 <code>native_decide</code> Medium <code>interval_bound_subdiv</code> Tight bounds via subdivision <code>native_decide</code> Slow <code>interval_argmax</code> Find maximizer point <code>native_decide</code> Slow <code>interval_argmin</code> Find minimizer point <code>native_decide</code> Slow <code>vec_simp</code> Simplify vector indexing <code>dsimp</code> Fast <code>finsum_expand</code> Expand finite sums <code>native_decide</code> Fast"},{"location":"tactics/#additional-tactics","title":"Additional Tactics","text":""},{"location":"tactics/#discover","title":"<code>discover</code>","text":"<p>Meta-tactic that analyzes the goal and automatically routes to <code>interval_minimize</code> or <code>interval_maximize</code>.</p> <pre><code>import LeanCert.Tactic.Discovery\n\n-- Automatically detects \u2265 m and calls interval_minimize\nexample : \u2203 m : \u211a, \u2200 x \u2208 I, f(x) \u2265 m := by discover\n\n-- Automatically detects \u2264 M and calls interval_maximize\nexample : \u2203 M : \u211a, \u2200 x \u2208 I, f(x) \u2264 M := by discover\n</code></pre>"},{"location":"tactics/#interval_minimize_mv-interval_maximize_mv","title":"<code>interval_minimize_mv</code> / <code>interval_maximize_mv</code>","text":"<p>Multivariate versions of minimize/maximize for N-dimensional domains.</p> <pre><code>import LeanCert.Tactic.Discovery\n\n-- Find minimum over 2D domain\nexample : \u2203 m : \u211a, \u2200 x \u2208 Set.Icc (0:\u211d) 1, \u2200 y \u2208 Set.Icc (0:\u211d) 1,\n    x*x + y*y \u2265 m := by\n  interval_minimize_mv\n\n-- Find maximum over 2D domain\nexample : \u2203 M : \u211a, \u2200 x \u2208 Set.Icc (0:\u211d) 1, \u2200 y \u2208 Set.Icc (0:\u211d) 1,\n    x + y \u2264 M := by\n  interval_maximize_mv\n</code></pre> <p>Uses more samples (300) and iterations (2000) than univariate versions.</p>"},{"location":"tactics/#multivariate_bound","title":"<code>multivariate_bound</code>","text":"<p>Proves bounds over multi-variable domains directly.</p> <pre><code>import LeanCert.Tactic.IntervalAuto\n\n-- Prove x + y \u2264 2 on [0,1] \u00d7 [0,1]\nexample : \u2200 x \u2208 Set.Icc (0:\u211d) 1, \u2200 y \u2208 Set.Icc (0:\u211d) 1,\n    x + y \u2264 (2 : \u211a) := by\n  multivariate_bound\n</code></pre>"},{"location":"tactics/#root_bound","title":"<code>root_bound</code>","text":"<p>Proves absence of roots by showing a function is strictly positive or negative.</p> <p>Native syntax (recommended):</p> <pre><code>import LeanCert.Tactic.IntervalAuto\n\n-- x\u00b2 + 1 \u2260 0 on [0, 1] (always positive)\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, x * x + 1 \u2260 0 := by\n  root_bound\n\n-- exp(x) \u2260 0 on [0, 1]\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, Real.exp x \u2260 0 := by\n  root_bound 15\n</code></pre> <p>Expr AST syntax (also supported):</p> <pre><code>open LeanCert.Core\n\ndef I01 : IntervalRat := \u27e80, 1, by norm_num\u27e9\n\nexample : \u2200 x \u2208 I01, Expr.eval (fun _ =&gt; x)\n    (Expr.add (Expr.mul (Expr.var 0) (Expr.var 0)) (Expr.const 1)) \u2260 (0 : \u211d) := by\n  root_bound\n</code></pre>"},{"location":"tactics/#interval_bound_subdiv","title":"<code>interval_bound_subdiv</code>","text":"<p>Proves bounds using progressive subdivision when direct interval evaluation is too loose.</p> <pre><code>import LeanCert.Tactic.IntervalAuto\n\n-- Tighter bound requiring subdivision\nexample : \u2200 x \u2208 Set.Icc (0:\u211d) 1, Real.exp x \u2264 (272/100 : \u211a) := by\n  interval_bound_subdiv 15 3  -- Taylor depth 15, subdivision depth 3\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>depth</code> <code>\u2115</code> 10 Taylor series depth <code>subdivDepth</code> <code>\u2115</code> 2 Number of subdivision levels"},{"location":"tactics/#interval_argmax-interval_argmin","title":"<code>interval_argmax</code> / <code>interval_argmin</code>","text":"<p>Find the point where a function achieves its maximum/minimum.</p> <p><code>interval_argmax</code> - Native syntax (recommended):</p> <pre><code>import LeanCert.Tactic.Discovery\n\n-- Find the maximizer of x\u00b2 on [-1,1] (argmax at endpoints x = \u00b11)\nexample : \u2203 x \u2208 Set.Icc (-1 : \u211d) 1, \u2200 y \u2208 Set.Icc (-1 : \u211d) 1,\n    y * y \u2264 x * x := by\n  interval_argmax\n\n-- Linear function: max of 2x+1 on [0,1] (argmax at x=1)\nexample : \u2203 x \u2208 Set.Icc (0 : \u211d) 1, \u2200 y \u2208 Set.Icc (0 : \u211d) 1,\n    2 * y + 1 \u2264 2 * x + 1 := by\n  interval_argmax\n</code></pre> <p><code>interval_argmin</code> - Native syntax (recommended):</p> <pre><code>-- Find the minimizer of x on [0,1] (argmin at x=0)\nexample : \u2203 x \u2208 Set.Icc (0 : \u211d) 1, \u2200 y \u2208 Set.Icc (0 : \u211d) 1,\n    x \u2264 y := by\n  interval_argmin\n</code></pre> <p>Expr AST syntax (also supported):</p> <pre><code>open LeanCert.Core\n\ndef I_neg1_1 : IntervalRat := \u27e8-1, 1, by norm_num\u27e9\ndef I01 : IntervalRat := \u27e80, 1, by norm_num\u27e9\n\n-- Argmax with Expr AST\nexample : \u2203 x \u2208 I_neg1_1, \u2200 y \u2208 I_neg1_1,\n    Expr.eval (fun _ =&gt; y) (Expr.mul (Expr.var 0) (Expr.var 0)) \u2264\n    Expr.eval (fun _ =&gt; x) (Expr.mul (Expr.var 0) (Expr.var 0)) := by\n  interval_argmax\n\n-- Argmin with Expr AST\nexample : \u2203 x \u2208 I01, \u2200 y \u2208 I01,\n    Expr.eval (fun _ =&gt; x) (Expr.var 0) \u2264\n    Expr.eval (fun _ =&gt; y) (Expr.var 0) := by\n  interval_argmin\n</code></pre> <p>How it works: 1. Runs branch-and-bound optimization to find candidate optimizer <code>xOpt</code> 2. Evaluates <code>f(xOpt)</code> to get a concrete bound <code>c</code> 3. For argmax: Proves <code>\u2200 y \u2208 I, f(y) \u2264 c</code> and <code>c \u2264 f(xOpt)</code>, then applies transitivity 4. For argmin: Proves <code>\u2200 y \u2208 I, c \u2264 f(y)</code> and <code>f(xOpt) \u2264 c</code>, then applies transitivity</p> <p>Limitations: - Works best when the argmax/argmin is at a rational point (e.g., interval endpoints) - For transcendental functions, may require higher Taylor depth - For interior optima at irrational points, consider using <code>interval_maximize</code>/<code>interval_minimize</code> instead</p>"},{"location":"tactics/#low-level-manual-tactics","title":"Low-Level Manual Tactics","text":"<p>For fine-grained control, use these macros from <code>LeanCert.Tactic.Interval</code>:</p> <pre><code>import LeanCert.Tactic.Interval\n\nopen LeanCert.Core LeanCert.Engine\n\ndef xSq : Expr := Expr.mul (Expr.var 0) (Expr.var 0)\ndef xSq_supp : ExprSupportedCore xSq :=\n  ExprSupportedCore.mul (ExprSupportedCore.var 0) (ExprSupportedCore.var 0)\n\n-- Manual bounds with explicit AST and support proof\nexample : \u2200 x \u2208 I01, Expr.eval (fun _ =&gt; x) xSq \u2264 (1 : \u211a) := by\n  interval_le xSq, xSq_supp, I01, 1\n\nexample : \u2200 x \u2208 I01, (0 : \u211a) \u2264 Expr.eval (fun _ =&gt; x) xSq := by\n  interval_ge xSq, xSq_supp, I01, 0\n</code></pre> Macro Purpose <code>interval_le</code> <code>\u2200 x \u2208 I, f(x) \u2264 c</code> <code>interval_ge</code> <code>\u2200 x \u2208 I, c \u2264 f(x)</code> <code>interval_lt</code> <code>\u2200 x \u2208 I, f(x) &lt; c</code> <code>interval_gt</code> <code>\u2200 x \u2208 I, c &lt; f(x)</code> <code>interval_le_pt</code> Pointwise <code>f(x) \u2264 c</code> given <code>x \u2208 I</code> <code>interval_ge_pt</code> Pointwise <code>c \u2264 f(x)</code> given <code>x \u2208 I</code> <p>Extended (noncomputable) versions for expressions with <code>exp</code>: <code>interval_ext_le</code>, <code>interval_ext_ge</code>, <code>interval_ext_lt</code>, <code>interval_ext_gt</code></p> <p>These reduce the goal to a rational inequality that must be proved manually.</p>"},{"location":"tactics/#simplification-tactics","title":"Simplification Tactics","text":""},{"location":"tactics/#vec_simp","title":"<code>vec_simp</code>","text":"<p>Simplifies vector indexing expressions with explicit <code>Fin.mk</code> constructors using a custom <code>dsimproc</code> that extracts the natural number from <code>Fin.mk n proof</code> and walks the <code>vecCons</code> chain directly.</p> <pre><code>import LeanCert.Tactic.VecSimp\n\n-- Basic indexing: reduces ![a, b, c] \u27e8i, proof\u27e9 to the i-th element\nexample : (![1, 2, 3] : Fin 3 \u2192 \u2115) \u27e80, by omega\u27e9 = 1 := by vec_simp\nexample : (![1, 2, 3] : Fin 3 \u2192 \u2115) \u27e81, by omega\u27e9 = 2 := by vec_simp\nexample : (![1, 2, 3] : Fin 3 \u2192 \u2115) \u27e82, by omega\u27e9 = 3 := by vec_simp\n\n-- Symbolic elements\nexample (a b c : \u211d) : (![a, b, c] : Fin 3 \u2192 \u211d) \u27e81, by omega\u27e9 = b := by vec_simp\n\n-- Longer vectors\nexample : (![1, 2, 3, 4, 5] : Fin 5 \u2192 \u2115) \u27e83, by omega\u27e9 = 4 := by vec_simp\n\n-- In expressions (simplifies all vector indexing)\nexample (a b c : \u211d) : (![a, b, c] : Fin 3 \u2192 \u211d) \u27e80, by omega\u27e9 + 1 = a + 1 := by vec_simp\n\n-- Combines well with ring for algebraic manipulation\nexample (a\u2080 a\u2081 : \u211d) :\n    (![a\u2080, a\u2081] : Fin 2 \u2192 \u211d) \u27e80, by omega\u27e9 * (![a\u2080, a\u2081] : Fin 2 \u2192 \u211d) \u27e81, by omega\u27e9 +\n    (![a\u2080, a\u2081] : Fin 2 \u2192 \u211d) \u27e81, by omega\u27e9 * (![a\u2080, a\u2081] : Fin 2 \u2192 \u211d) \u27e80, by omega\u27e9 = 2 * a\u2080 * a\u2081 := by\n  vec_simp; ring\n</code></pre> <p>Why this exists: Mathlib's <code>cons_val</code> simproc uses <code>int?</code> to extract indices, which only matches numeric literals like <code>0</code>, <code>1</code>, <code>2</code>. It doesn't match explicit <code>Fin.mk</code> applications like <code>\u27e80, by omega\u27e9</code>, which commonly appear in proofs (e.g., from <code>finsum_expand</code> or matrix indexing). The <code>vec_simp</code> dsimproc fills that gap by pattern-matching on <code>Fin.mk</code> directly.</p> <p>How it works: A <code>dsimproc</code> (<code>VecSimp.vecConsFinMk</code>) matches applications of <code>vecCons</code> to a <code>Fin.mk n proof</code> index, extracts <code>n</code>, and recursively traverses the cons chain to return the n-th element. This is combined with standard Mathlib vector lemmas (<code>cons_val_zero</code>, <code>cons_val_one</code>, <code>head_cons</code>).</p>"},{"location":"tactics/#finsum_expand","title":"<code>finsum_expand</code>","text":"<p>Expands finite sums over Finsets into explicit additions.</p> <pre><code>import LeanCert.Tactic.FinSumExpand\n\n-- Interval finsets (Icc = closed-closed)\nexample (f : \u2115 \u2192 \u211d) : \u2211 k \u2208 Finset.Icc 1 3, f k = f 1 + f 2 + f 3 := by finsum_expand\n\n-- Single element\nexample (f : \u2115 \u2192 \u211d) : \u2211 k \u2208 Finset.Icc 5 5, f k = f 5 := by finsum_expand\n\n-- Ico (closed-open)\nexample (f : \u2115 \u2192 \u211d) : \u2211 k \u2208 Finset.Ico 1 4, f k = f 1 + f 2 + f 3 := by finsum_expand\n\n-- Ioc (open-closed)\nexample (f : \u2115 \u2192 \u211d) : \u2211 k \u2208 Finset.Ioc 1 3, f k = f 2 + f 3 := by finsum_expand\n\n-- Ioo (open-open)\nexample (f : \u2115 \u2192 \u211d) : \u2211 k \u2208 Finset.Ioo 1 4, f k = f 2 + f 3 := by finsum_expand\n\n-- Iic (unbounded below, closed) - for \u2115, means [0, n]\nexample (f : \u2115 \u2192 \u211d) : \u2211 k \u2208 Finset.Iic 2, f k = f 0 + f 1 + f 2 := by finsum_expand\n\n-- Iio (unbounded below, open) - for \u2115, means [0, n)\nexample (f : \u2115 \u2192 \u211d) : \u2211 k \u2208 Finset.Iio 3, f k = f 0 + f 1 + f 2 := by finsum_expand\n\n-- Empty intervals\nexample (f : \u2115 \u2192 \u211d) : \u2211 k \u2208 Finset.Ico 5 5, f k = 0 := by finsum_expand\n\n-- Explicit finsets\nexample (f : \u2115 \u2192 \u211d) : \u2211 k \u2208 ({1, 3, 7} : Finset \u2115), f k = f 1 + f 3 + f 7 := by finsum_expand\n\n-- Combines with ring for evaluation\nexample : \u2211 k \u2208 Finset.Icc 1 4, (fun n : \u2115 =&gt; (n : \u211d)) k = 10 := by finsum_expand; ring\n\n-- Power series patterns\nexample (a : \u2115 \u2192 \u211d) (r : \u211d) : \u2211 n \u2208 Finset.Icc 1 3, |a n| * r ^ n =\n    |a 1| * r ^ 1 + |a 2| * r ^ 2 + |a 3| * r ^ 3 := by finsum_expand\n</code></pre> <p>Supported interval types:</p> Interval Meaning Example <code>Finset.Icc a b</code> [a, b] closed-closed <code>Icc 1 3</code> \u2192 {1, 2, 3} <code>Finset.Ico a b</code> [a, b) closed-open <code>Ico 1 4</code> \u2192 {1, 2, 3} <code>Finset.Ioc a b</code> (a, b] open-closed <code>Ioc 1 3</code> \u2192 {2, 3} <code>Finset.Ioo a b</code> (a, b) open-open <code>Ioo 1 4</code> \u2192 {2, 3} <code>Finset.Iic n</code> [0, n] for \u2115 <code>Iic 2</code> \u2192 {0, 1, 2} <code>Finset.Iio n</code> [0, n) for \u2115 <code>Iio 3</code> \u2192 {0, 1, 2} <code>{a, b, ...}</code> Explicit set <code>{1, 3, 7}</code> <code>\u2211 i : Fin n, f i</code> Fin univ <code>Fin 3</code> \u2192 {0, 1, 2} <p>How it works: Uses <code>Finset.sum_cons</code> and <code>Finset.sum_empty</code> rewriting combined with <code>native_decide</code> to evaluate finset membership. For <code>Fin n</code> sums, uses <code>Fin.sum_univ_ofNat</code> when <code>n</code> is a literal.</p> <p>Why this exists: When proving bounds involving finite sums, you often need to expand them for arithmetic simplification. Without this tactic, you'd need to manually define \"bridge lemmas\" for each specific range.</p>"},{"location":"tactics/#common-patterns","title":"Common Patterns","text":""},{"location":"tactics/#proving-a-function-is-bounded","title":"Proving a function is bounded","text":"<pre><code>-- Upper and lower bound\nexample : \u2200 x \u2208 Set.Icc (0 : \u211d) 1, 0 \u2264 Real.sin x \u2227 Real.sin x \u2264 1 := by\n  constructor &lt;;&gt; certify_bound\n</code></pre>"},{"location":"tactics/#proving-a-root-exists-and-is-unique","title":"Proving a root exists and is unique","text":"<pre><code>-- First existence, then uniqueness\nexample : \u2203 x \u2208 I, f x = 0 := by interval_roots\nexample : \u2203! x \u2208 I, f x = 0 := by interval_unique_root\n</code></pre>"},{"location":"tactics/#debugging-failed-proofs","title":"Debugging failed proofs","text":"<pre><code>set_option trace.certify_bound true    -- See computation details\nset_option trace.certify_kernel true   -- See kernel verification status\n\n-- If bound too tight, try:\n-- 1. Increase Taylor depth: certify_bound 20\n-- 2. Use certify_kernel_precise for more bits\n-- 3. Use interval_refute to check if bound is actually false\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>Common issues and how to fix them.</p>"},{"location":"troubleshooting/#tactic-failures","title":"Tactic Failures","text":""},{"location":"troubleshooting/#native_decide-evaluated-that-the-proposition-is-false","title":"\"native_decide evaluated that the proposition is false\"","text":"<pre><code>error: Tactic `native_decide` evaluated that the proposition\n  checkUpperBound ... = true\nis false\n</code></pre> <p>Cause: The bound you're trying to prove is too tight for the current Taylor depth.</p> <p>Solutions:</p> <ol> <li> <p>Increase Taylor depth: <pre><code>-- Instead of\nexample : \u2200 x \u2208 I, Real.exp x \u2264 2.72 := by certify_bound\n\n-- Try\nexample : \u2200 x \u2208 I, Real.exp x \u2264 2.72 := by certify_bound 20\n</code></pre></p> </li> <li> <p>Use a looser bound: <pre><code>-- exp(1) \u2248 2.718, so 2.72 may be too tight\n-- Try 2.75 or 3 instead\nexample : \u2200 x \u2208 I, Real.exp x \u2264 3 := by certify_bound\n</code></pre></p> </li> <li> <p>Use subdivision for tight bounds: <pre><code>example : \u2200 x \u2208 I, Real.exp x \u2264 2.72 := by interval_bound_subdiv 15 3\n</code></pre></p> </li> <li> <p>Check if the bound is actually true: <pre><code>-- Use discovery to see what bounds actually hold\n#bounds (fun x =&gt; Real.exp x) on [0, 1]\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#could-not-unify-expreval-with-the-goal","title":"\"could not unify ... Expr.eval ... with the goal\"","text":"<pre><code>error: Tactic `apply` failed: could not unify the conclusion of the term\n  \u2200 x \u2208 I, Expr.eval (fun x_1 =&gt; x) (...) \u2264 \u2191c\nwith the goal\n  \u2200 x \u2208 I, &lt;your expression&gt; \u2264 \u2191c\n</code></pre> <p>Cause: The tactic reified your expression to an <code>Expr</code> AST, but it doesn't match the goal syntactically.</p> <p>Note: As of v1.2, most cases are now handled automatically. Expressions with numeric coefficients like <code>2 * x * x + 3 * x + 1</code> should work out of the box. If you still encounter this error, try the solutions below.</p> <p>This may still happen with: - Very complex nested coefficient expressions - Custom definitions that aren't unfolded - Unusual type coercions</p> <p>Solutions:</p> <ol> <li> <p>First, just try it - most expressions now work:    <pre><code>-- These all work now:\nexample : \u2200 x \u2208 I, 2 * x * x + 3 * x + 1 \u2264 6 := by certify_bound  -- \u2713\nexample : \u2200 x \u2208 I, x * x - x + 1 \u2264 2 := by certify_bound           -- \u2713\nexample : \u2200 x \u2208 I, 2 * Real.sin x + x * x \u2264 3 := by certify_bound  -- \u2713\n</code></pre></p> </li> <li> <p>If it still fails, build the Expr AST explicitly: <pre><code>open LeanCert.Core\n\ndef myExpr : Expr := Expr.add\n  (Expr.mul (Expr.const 2) (Expr.mul (Expr.var 0) (Expr.var 0)))\n  (Expr.const 1)\n\ndef myExpr_core : ExprSupportedCore myExpr := ...\n\nexample : \u2200 x \u2208 I, Expr.eval (fun _ =&gt; x) myExpr \u2264 5 := by\n  interval_le myExpr, myExpr_core, I, 5\n</code></pre></p> </li> <li> <p>Use the low-level tactics with explicit arguments: <pre><code>example : \u2200 x \u2208 I01, Expr.eval (fun _ =&gt; x) quadExpr \u2264 (5 : \u211a) := by\n  interval_le quadExpr, quadExpr_core, I01, 5\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#unsolved-goals-with-multivariate-bounds","title":"\"unsolved goals\" with multivariate bounds","text":"<pre><code>error: unsolved goals\nx\u271d : \u211d\na\u271d : x\u271d \u2208 I01\n\u22a2 \u2200 (y : \u211d), \u2191I01.lo \u2264 y \u2192 y \u2264 \u2191I01.hi \u2192 x\u271d + y \u2264 2\n</code></pre> <p>Cause: You used <code>certify_bound</code> for a multivariate goal, but it only handles single-variable bounds.</p> <p>Solution: Use <code>multivariate_bound</code>: <pre><code>-- Instead of\nexample : \u2200 x \u2208 I, \u2200 y \u2208 J, x + y \u2264 2 := by certify_bound  -- Fails\n\n-- Use\nexample : \u2200 x \u2208 I, \u2200 y \u2208 J, x + y \u2264 2 := by multivariate_bound\n</code></pre></p>"},{"location":"troubleshooting/#cannot-parse-as-integer-314159","title":"\"Cannot parse as integer: 3.14159\"","text":"<pre><code>error: Cannot parse as integer: 3.14159\n</code></pre> <p>Cause: Discovery commands only accept integer bounds, not floats.</p> <p>Solution: Use rational approximations: <pre><code>-- Instead of\n#bounds (fun x =&gt; Real.sin x) on [0, 3.14159]  -- Fails\n\n-- Use integers\n#bounds (fun x =&gt; Real.sin x) on [0, 4]\n\n-- Or define a rational interval for tactics\ndef I_0_pi : IntervalRat := \u27e80, 314159/100000, by norm_num\u27e9\n</code></pre></p>"},{"location":"troubleshooting/#warning-messages","title":"Warning Messages","text":""},{"location":"troubleshooting/#optimization-gap-exceeds-tolerance","title":"\"Optimization gap exceeds tolerance\"","text":"<pre><code>warning: \u26a0\ufe0f Optimization gap [-0.17, 0] exceeds tolerance 1/1000.\nConsider increasing maxIterations or taylorDepth.\n</code></pre> <p>Cause: The branch-and-bound algorithm didn't converge to the requested precision, but the proof still succeeded because the discovered bound is valid.</p> <p>When to worry: Only if you need tighter bounds. The proof is still correct.</p> <p>Solutions: <pre><code>-- Increase Taylor depth\nexample : \u2203 m, \u2200 x \u2208 I, f x \u2265 m := by interval_minimize 20\n\n-- Or just accept slightly looser bounds (the proof is still valid)\n</code></pre></p>"},{"location":"troubleshooting/#expression-support","title":"Expression Support","text":""},{"location":"troubleshooting/#what-works-with-raw-lean-syntax","title":"What works with raw Lean syntax?","text":"<p>Works well: <pre><code>-- Basic arithmetic\nx * x + 1\nx^3\nx^(-2)\nx^(5/2)\nx^(-3/2)\n\n-- Simple coefficients\nx * x + x + 1\n\n-- Transcendentals\nReal.sin x\nReal.cos x\nReal.exp x\nReal.sin x + Real.cos x\nReal.exp (Real.sin x)\n</code></pre></p> <p>Requires positive base (lowered via exp/log): <pre><code>-- General rational exponents (base must be provably &gt; 0)\nx^(1/3)\nx^(2/3)\nx^(1/5)\n</code></pre></p> <p>These are reified as <code>exp(log(x) * q)</code>. The tactic automatically proves <code>0 &lt; x</code> from <code>Set.Icc</code> domain hypotheses when the lower bound is positive.</p>"},{"location":"troubleshooting/#what-requires-expr-ast-syntax","title":"What requires Expr AST syntax?","text":"<p>Always use Expr AST for: - <code>interval_roots</code> (root existence) - <code>root_bound</code> (root absence) - Low-level tactics (<code>interval_le</code>, <code>interval_ge</code>, etc.)</p> <p>Example: <pre><code>open LeanCert.Core\n\ndef I12 : IntervalRat := \u27e81, 2, by norm_num\u27e9\n\n-- Root existence requires Expr AST\nexample : \u2203 x \u2208 I12, Expr.eval (fun _ =&gt; x)\n    (Expr.add (Expr.mul (Expr.var 0) (Expr.var 0))\n              (Expr.neg (Expr.const 2))) = 0 := by\n  interval_roots\n</code></pre></p>"},{"location":"troubleshooting/#precision-and-taylor-depth","title":"Precision and Taylor Depth","text":""},{"location":"troubleshooting/#when-to-increase-taylor-depth","title":"When to increase Taylor depth","text":"Situation Recommended Depth Polynomials only 10 (default) Single transcendental (<code>sin x</code>, <code>exp x</code>) 10-15 Composed transcendentals (<code>exp(sin x)</code>) 15-20 Tight bounds (within 1% of true value) 20-30 Very tight bounds Use <code>interval_bound_subdiv</code>"},{"location":"troubleshooting/#when-to-use-fast_bound-dyadic","title":"When to use <code>fast_bound</code> (dyadic)","text":"<p>Use the dyadic backend when: - Deeply nested expressions: <code>sin(cos(sin(x)))</code> - Many operations: <code>x\u2081 + x\u2082 + ... + x\u2081\u2080\u2080</code> - Proofs with rational backend timeout or are slow</p> <pre><code>-- Dyadic handles nesting well\nexample : \u2200 x \u2208 I, Real.cos (Real.sin (Real.cos x)) \u2264 1 := by fast_bound\n\n-- Equivalent but may be slower/fail with many terms\nexample : \u2200 x \u2208 I, Real.cos (Real.sin (Real.cos x)) \u2264 1 := by certify_bound\n</code></pre>"},{"location":"troubleshooting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"troubleshooting/#enable-tracing","title":"Enable tracing","text":"<pre><code>set_option trace.certify_bound true in\nexample : \u2200 x \u2208 I, f x \u2264 c := by certify_bound\n\nset_option trace.certify_kernel true in\nexample : \u2200 x \u2208 I, f x \u2264 c := by certify_kernel\n</code></pre>"},{"location":"troubleshooting/#use-discovery-to-check-bounds","title":"Use discovery to check bounds","text":"<p>Before writing a theorem, verify the bound holds: <pre><code>-- See what bounds actually hold\n#bounds (fun x =&gt; your_expression) on [lo, hi]\n\n-- Then prove with margin\n-- If #bounds says max \u2248 2.72, prove \u2264 3\n</code></pre></p>"},{"location":"troubleshooting/#use-interval_refute-to-check-false-bounds","title":"Use <code>interval_refute</code> to check false bounds","text":"<pre><code>-- Is this bound even true?\nexample : \u2200 x \u2208 Set.Icc (-2 : \u211d) 2, x * x \u2264 3 := by\n  interval_refute  -- Finds counterexample at x = \u00b12\n\n-- The bound is false! x\u00b2 = 4 &gt; 3 at endpoints\n</code></pre>"},{"location":"troubleshooting/#common-patterns","title":"Common Patterns","text":""},{"location":"troubleshooting/#discovery-proof-workflow","title":"Discovery \u2192 Proof workflow","text":"<pre><code>-- Step 1: Explore\n#bounds (fun x =&gt; Real.exp x + Real.sin x) on [0, 1]\n-- Output: f(x) \u2208 [1, 3.56]\n\n-- Step 2: Pick safe bounds (with margin)\n-- Discovery says max \u2248 3.56, so prove \u2264 4\n\n-- Step 3: Prove\nexample : \u2200 x \u2208 Set.Icc (0:\u211d) 1, Real.exp x + Real.sin x \u2264 4 := by\n  certify_bound 15\n</code></pre>"},{"location":"troubleshooting/#let-leancert-find-bounds-for-you","title":"Let LeanCert find bounds for you","text":"<pre><code>-- Don't know what bound to use? Let LeanCert discover it:\nexample : \u2203 M : \u211a, \u2200 x \u2208 Set.Icc (0:\u211d) 1, Real.exp x \u2264 M := by\n  interval_maximize 15\n-- LeanCert finds M and proves it!\n</code></pre>"},{"location":"api/adaptive/","title":"Adaptive Verification","text":"<p>The <code>adaptive</code> module provides domain splitting strategies and proof assembly for verifying complex expressions that fail on the full domain.</p>"},{"location":"api/adaptive/#overview","title":"Overview","text":"<p>When interval arithmetic over a large domain produces bounds that are too loose, adaptive verification splits the domain into smaller regions, verifies each independently, and assembles a combined proof.</p> <pre><code>import leancert as lc\nfrom leancert.adaptive import verify_bound_adaptive\n\nx = lc.var('x')\nwith lc.Solver() as solver:\n    # May need splitting to prove tight bound\n    result = verify_bound_adaptive(\n        solver,\n        lc.sin(x) * lc.cos(x),\n        {'x': (0, 6.28)},\n        upper=0.5\n    )\n\n    print(result.verified)      # True\n    print(result.total_splits)  # Number of domain splits needed\n    print(result.lean_proof)    # Combined Lean proof\n</code></pre>"},{"location":"api/adaptive/#when-to-use-adaptive-verification","title":"When to Use Adaptive Verification","text":"<p>Use adaptive verification when:</p> <ol> <li>Tight bounds fail - The expression's true range is close to the bound you're proving</li> <li>Large domains - Interval arithmetic accumulates overestimation over wide intervals</li> <li>Oscillating functions - Functions like <code>sin</code>, <code>cos</code> need subdivision to capture behavior</li> <li>Near-boundary behavior - Values approach the bound only in small regions</li> </ol>"},{"location":"api/adaptive/#function-api","title":"Function API","text":"<pre><code>from leancert.adaptive import verify_bound_adaptive, AdaptiveConfig, SplitStrategy\n\nresult = verify_bound_adaptive(\n    solver,           # lc.Solver instance\n    expr,             # Expression to verify\n    domain,           # {'x': (lo, hi)} or Box\n    upper=None,       # Upper bound to prove\n    lower=None,       # Lower bound to prove\n    adaptive_config=AdaptiveConfig(),  # Splitting configuration\n    solver_config=lc.Config()          # Interval arithmetic config\n)\n</code></pre>"},{"location":"api/adaptive/#splitting-strategies","title":"Splitting Strategies","text":"<p>Configure the splitting strategy via <code>AdaptiveConfig</code>:</p> <pre><code>from leancert.adaptive import AdaptiveConfig, SplitStrategy\n\n# Bisection - splits domain in half\nconfig = AdaptiveConfig(strategy=SplitStrategy.BISECT)\n\n# Worst-point guided (default) - splits where bound is nearly violated\nconfig = AdaptiveConfig(strategy=SplitStrategy.WORST_POINT)\n\n# Gradient-guided - uses derivative info to guide splits\nconfig = AdaptiveConfig(strategy=SplitStrategy.GRADIENT_GUIDED)\n\n# Largest-first - splits largest subdomain first\nconfig = AdaptiveConfig(strategy=SplitStrategy.LARGEST_FIRST)\n\n# Algebraic - splits at roots/critical points\nconfig = AdaptiveConfig(strategy=SplitStrategy.ALGEBRAIC)\n\n# Auto - automatically selects best strategy\nconfig = AdaptiveConfig(strategy=SplitStrategy.AUTO)\n</code></pre>"},{"location":"api/adaptive/#configuration","title":"Configuration","text":"<pre><code>from leancert.adaptive import AdaptiveConfig, SplitStrategy\n\nconfig = AdaptiveConfig(\n    max_splits=64,              # Maximum number of domain splits\n    max_depth=10,               # Maximum recursion depth\n    strategy=SplitStrategy.WORST_POINT,  # Splitting strategy\n    parallel=True,              # Verify subdomains in parallel\n    max_workers=None,           # Number of parallel workers (None=auto)\n    min_width=1e-10,            # Stop subdividing below this width\n    min_volume=None,            # Stop subdividing below this volume\n    timeout_per_subdomain_ms=10000,  # Timeout per subdomain\n    compute_gradients=False,    # Compute gradients for guided splitting\n)\n\nresult = verify_bound_adaptive(\n    solver, expr, domain, upper=bound,\n    adaptive_config=config\n)\n</code></pre>"},{"location":"api/adaptive/#multivariate-domains","title":"Multivariate Domains","text":"<p>For multivariate functions, splitting occurs along all dimensions:</p> <pre><code>x, y = lc.var('x'), lc.var('y')\nexpr = x**2 + y**2 - x*y\n\nresult = verify_bound_adaptive(\n    solver,\n    expr,\n    {'x': (-1, 1), 'y': (-1, 1)},\n    upper=3.0\n)\n\nprint(result.total_splits)  # May split into multiple regions\n</code></pre>"},{"location":"api/adaptive/#result-structure","title":"Result Structure","text":"<p>The <code>AdaptiveResult</code> contains:</p> <pre><code>@dataclass\nclass AdaptiveResult:\n    verified: bool                    # Whether the bound was proven\n    subdomains: list[Subdomain]       # All subdomains considered\n    results: list[SubdomainResult]    # Results per subdomain\n    total_splits: int                 # Total number of splits\n    failing_subdomain: Optional[Subdomain]  # First failing region (if any)\n    lean_proof: Optional[str]         # Combined Lean proof\n    certificate: Optional[Certificate] # Verification certificate\n    total_time_ms: float              # Total verification time\n    unverified_volume: float          # Volume of unverified regions\n</code></pre>"},{"location":"api/adaptive/#proof-assembly","title":"Proof Assembly","text":"<p>After verifying all subdomains, proofs are assembled:</p> <pre><code>result = verify_bound_adaptive(solver, expr, domain, upper=bound)\n\n# Access the combined Lean proof\nprint(result.lean_proof)\n# Output:\n# -- CEGAR-generated proof via domain splitting\n# -- Expression: ...\n# -- Bound: upper \u2264 ...\n# -- Verified in N subdomains\n# apply union_bound_of_subdomains\n# ...\n</code></pre>"},{"location":"api/adaptive/#convenience-function","title":"Convenience Function","text":"<p>For quick use, there's also a module-level function:</p> <pre><code>import leancert as lc\n\nx = lc.var('x')\nresult = lc.verify_bound_adaptive(\n    solver, lc.exp(x), {'x': (0, 2)}, upper=8.0\n)\n</code></pre>"},{"location":"api/adaptive/#performance-tips","title":"Performance Tips","text":"<ol> <li>Start with low <code>max_splits</code> - Increase only if verification fails</li> <li>Use <code>WORST_POINT</code> strategy for tight bounds (default)</li> <li>Use <code>ALGEBRAIC</code> strategy for functions with known critical points</li> <li>Enable <code>parallel=True</code> for large domains (default)</li> <li>Check <code>result.total_splits</code> - High counts suggest the bound is too tight</li> </ol>"},{"location":"api/adaptive/#see-also","title":"See Also","text":"<ul> <li>Quantifier Synthesis - High-level synthesis using adaptive verification</li> <li>Solver API - Low-level verification methods</li> <li>Troubleshooting - Common verification failures</li> </ul>"},{"location":"api/config/","title":"Configuration","text":"<p>LeanCert supports multiple arithmetic backends for different performance/precision tradeoffs.</p>"},{"location":"api/config/#backend-selection","title":"Backend Selection","text":"<pre><code>import leancert as lc\n\n# Default: Dyadic arithmetic (fast, ~15 decimal digits)\nresult = lc.find_bounds(expr, domain)\n\n# Explicit Dyadic with custom precision\nresult = lc.find_bounds(expr, domain, config=lc.Config.dyadic(precision=-100))\n\n# Affine: 50-90% tighter bounds for correlated variables\nresult = lc.find_bounds(expr, domain, config=lc.Config.affine())\n\n# Rational: Exact arithmetic (slower, use when precision matters)\nresult = lc.find_bounds(expr, domain, config=lc.Config(backend=lc.Backend.RATIONAL))\n</code></pre>"},{"location":"api/config/#backend-enum","title":"Backend Enum","text":""},{"location":"api/config/#leancert.config.Backend","title":"<code>leancert.config.Backend</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Backend selection for interval arithmetic.</p> <ul> <li>RATIONAL: Standard rational arithmetic. Exact but can suffer from             denominator explosion on deep expressions.</li> <li>DYADIC: High-performance dyadic arithmetic (n * 2^e). Avoids           denominator explosion by using fixed-precision outward rounding.           10-100x faster for complex expressions like neural networks.</li> <li>AFFINE: Affine arithmetic that tracks correlations between variables.           Solves the \"dependency problem\" (e.g., x-x gives [0,0] not [-2,2]).           50-90% tighter bounds for expressions with repeated variables.</li> </ul> Source code in <code>python/leancert/config.py</code> <pre><code>class Backend(Enum):\n    \"\"\"\n    Backend selection for interval arithmetic.\n\n    - RATIONAL: Standard rational arithmetic. Exact but can suffer from\n                denominator explosion on deep expressions.\n    - DYADIC: High-performance dyadic arithmetic (n * 2^e). Avoids\n              denominator explosion by using fixed-precision outward rounding.\n              10-100x faster for complex expressions like neural networks.\n    - AFFINE: Affine arithmetic that tracks correlations between variables.\n              Solves the \"dependency problem\" (e.g., x-x gives [0,0] not [-2,2]).\n              50-90% tighter bounds for expressions with repeated variables.\n    \"\"\"\n    RATIONAL = \"rational\"\n    DYADIC = \"dyadic\"\n    AFFINE = \"affine\"\n</code></pre>"},{"location":"api/config/#comparison","title":"Comparison","text":"Backend Speed Precision Best For <code>DYADIC</code> (default) 10-100x faster ~15 decimal digits Neural networks, deep expressions <code>AFFINE</code> Similar to Rational Tighter bounds Repeated variables, LayerNorm <code>RATIONAL</code> Baseline Exact When exact precision is required"},{"location":"api/config/#config-class","title":"Config Class","text":""},{"location":"api/config/#leancert.config.Config","title":"<code>leancert.config.Config</code>  <code>dataclass</code>","text":"<p>Configuration for verification requests.</p> <p>Attributes:</p> Name Type Description <code>taylor_depth</code> <code>int</code> <p>Depth of Taylor expansion for interval arithmetic.          Higher values give tighter bounds but are slower.</p> <code>max_iters</code> <code>int</code> <p>Maximum iterations for optimization/root finding.</p> <code>tolerance</code> <code>Fraction</code> <p>Desired precision (as a fraction).</p> <code>use_monotonicity</code> <code>bool</code> <p>Use monotonicity pruning in optimization.</p> <code>timeout_sec</code> <code>float</code> <p>Timeout in seconds.</p> <code>backend</code> <code>Backend</code> <p>Interval arithmetic backend (RATIONAL, DYADIC, or AFFINE).</p> <code>dyadic_config</code> <code>Optional[DyadicConfig]</code> <p>Configuration for Dyadic backend (if backend is DYADIC).</p> <code>affine_config</code> <code>Optional[AffineConfig]</code> <p>Configuration for Affine backend (if backend is AFFINE).</p> <code>race_strategies</code> <code>bool</code> <p>If True, race multiple backends in parallel and use             the first to succeed. Useful for unknown expressions.</p> <code>incremental_refinement</code> <code>bool</code> <p>If True, iteratively refine bounds to find the                    tightest provable bound.</p> <code>target_bound</code> <code>Optional[float]</code> <p>Optional target bound for incremental refinement. If set,          refinement stops when this bound is proven or exceeded.</p> <code>timeout_ms</code> <code>int</code> <p>Timeout in milliseconds for racing/refinement operations.</p> Source code in <code>python/leancert/config.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"\n    Configuration for verification requests.\n\n    Attributes:\n        taylor_depth: Depth of Taylor expansion for interval arithmetic.\n                     Higher values give tighter bounds but are slower.\n        max_iters: Maximum iterations for optimization/root finding.\n        tolerance: Desired precision (as a fraction).\n        use_monotonicity: Use monotonicity pruning in optimization.\n        timeout_sec: Timeout in seconds.\n        backend: Interval arithmetic backend (RATIONAL, DYADIC, or AFFINE).\n        dyadic_config: Configuration for Dyadic backend (if backend is DYADIC).\n        affine_config: Configuration for Affine backend (if backend is AFFINE).\n        race_strategies: If True, race multiple backends in parallel and use\n                        the first to succeed. Useful for unknown expressions.\n        incremental_refinement: If True, iteratively refine bounds to find the\n                               tightest provable bound.\n        target_bound: Optional target bound for incremental refinement. If set,\n                     refinement stops when this bound is proven or exceeded.\n        timeout_ms: Timeout in milliseconds for racing/refinement operations.\n    \"\"\"\n    taylor_depth: int = 10\n    max_iters: int = 1000\n    tolerance: Fraction = Fraction(1, 1000)\n    use_monotonicity: bool = True\n    timeout_sec: float = 60.0\n    backend: Backend = Backend.DYADIC\n    dyadic_config: Optional[DyadicConfig] = None\n    affine_config: Optional[AffineConfig] = None\n    # Witness synthesis options\n    race_strategies: bool = False\n    incremental_refinement: bool = False\n    target_bound: Optional[float] = None\n    timeout_ms: int = 30000\n\n    def __post_init__(self):\n        # Convert tolerance to Fraction if given as float\n        if isinstance(self.tolerance, float):\n            self.tolerance = Fraction(self.tolerance).limit_denominator(10**12)\n        # Auto-create dyadic config if using dyadic backend\n        if self.backend == Backend.DYADIC and self.dyadic_config is None:\n            self.dyadic_config = DyadicConfig()\n        # Auto-create affine config if using affine backend\n        if self.backend == Backend.AFFINE and self.affine_config is None:\n            self.affine_config = AffineConfig()\n\n    @classmethod\n    def low_precision(cls) -&gt; Config:\n        \"\"\"Fast, lower precision configuration.\"\"\"\n        return cls(\n            taylor_depth=5,\n            max_iters=100,\n            tolerance=Fraction(1, 100),\n        )\n\n    @classmethod\n    def medium_precision(cls) -&gt; Config:\n        \"\"\"Balanced precision/speed configuration (default).\"\"\"\n        return cls()\n\n    @classmethod\n    def high_precision(cls) -&gt; Config:\n        \"\"\"High precision configuration.\"\"\"\n        return cls(\n            taylor_depth=20,\n            max_iters=5000,\n            tolerance=Fraction(1, 100000),\n        )\n\n    @classmethod\n    def dyadic(cls, precision: int = -53) -&gt; Config:\n        \"\"\"\n        Configuration using Dyadic backend for high performance.\n\n        Recommended for deep expressions, neural networks, or when\n        rational arithmetic is too slow.\n\n        Args:\n            precision: Dyadic precision (default -53, IEEE double-like).\n        \"\"\"\n        return cls(\n            backend=Backend.DYADIC,\n            dyadic_config=DyadicConfig(precision=precision),\n        )\n\n    @classmethod\n    def dyadic_fast(cls) -&gt; Config:\n        \"\"\"Fast Dyadic configuration with lower precision.\"\"\"\n        return cls(\n            taylor_depth=8,\n            max_iters=500,\n            tolerance=Fraction(1, 100),\n            backend=Backend.DYADIC,\n            dyadic_config=DyadicConfig.fast(),\n        )\n\n    @classmethod\n    def dyadic_high_precision(cls) -&gt; Config:\n        \"\"\"High precision Dyadic configuration.\"\"\"\n        return cls(\n            taylor_depth=20,\n            max_iters=5000,\n            tolerance=Fraction(1, 100000),\n            backend=Backend.DYADIC,\n            dyadic_config=DyadicConfig.high_precision(),\n        )\n\n    @classmethod\n    def affine(cls) -&gt; Config:\n        \"\"\"\n        Configuration using Affine backend for tight bounds.\n\n        Recommended for expressions with repeated variables where the\n        dependency problem causes interval over-approximation.\n\n        Example:\n            x - x on [-1, 1]:\n            - Interval gives [-2, 2]\n            - Affine gives [0, 0] (exact!)\n        \"\"\"\n        return cls(\n            backend=Backend.AFFINE,\n            affine_config=AffineConfig(),\n        )\n\n    @classmethod\n    def affine_compact(cls) -&gt; Config:\n        \"\"\"Affine configuration with noise symbol consolidation.\"\"\"\n        return cls(\n            backend=Backend.AFFINE,\n            affine_config=AffineConfig.compact(),\n        )\n\n    def to_kernel(self) -&gt; dict:\n        \"\"\"Convert to kernel-compatible format.\"\"\"\n        return {\n            'taylorDepth': self.taylor_depth,\n            'maxIters': self.max_iters,\n            'tolerance': {'n': self.tolerance.numerator, 'd': self.tolerance.denominator},\n            'useMonotonicity': self.use_monotonicity,\n        }\n\n    def to_dyadic_kernel(self) -&gt; dict:\n        \"\"\"Convert Dyadic config to kernel-compatible format.\"\"\"\n        dc = self.dyadic_config or DyadicConfig()\n        return {\n            'precision': dc.precision,\n            'taylorDepth': self.taylor_depth,\n            'roundAfterOps': dc.round_after_ops,\n        }\n\n    def to_affine_kernel(self) -&gt; dict:\n        \"\"\"Convert Affine config to kernel-compatible format.\"\"\"\n        ac = self.affine_config or AffineConfig()\n        return {\n            'taylorDepth': self.taylor_depth,\n            'maxNoiseSymbols': ac.max_noise_symbols,\n        }\n\n    def __repr__(self) -&gt; str:\n        backend_str = f\", backend={self.backend.value}\" if self.backend != Backend.DYADIC else \"\"\n        return (\n            f\"Config(taylor_depth={self.taylor_depth}, \"\n            f\"max_iters={self.max_iters}, \"\n            f\"tolerance={self.tolerance}{backend_str})\"\n        )\n</code></pre>"},{"location":"api/config/#leancert.config.Config.taylor_depth","title":"<code>taylor_depth = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.max_iters","title":"<code>max_iters = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.tolerance","title":"<code>tolerance = Fraction(1, 1000)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.use_monotonicity","title":"<code>use_monotonicity = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.timeout_sec","title":"<code>timeout_sec = 60.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.backend","title":"<code>backend = Backend.DYADIC</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.dyadic_config","title":"<code>dyadic_config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.affine_config","title":"<code>affine_config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.race_strategies","title":"<code>race_strategies = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.incremental_refinement","title":"<code>incremental_refinement = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.target_bound","title":"<code>target_bound = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.timeout_ms","title":"<code>timeout_ms = 30000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#leancert.config.Config.low_precision","title":"<code>low_precision()</code>  <code>classmethod</code>","text":"<p>Fast, lower precision configuration.</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef low_precision(cls) -&gt; Config:\n    \"\"\"Fast, lower precision configuration.\"\"\"\n    return cls(\n        taylor_depth=5,\n        max_iters=100,\n        tolerance=Fraction(1, 100),\n    )\n</code></pre>"},{"location":"api/config/#leancert.config.Config.medium_precision","title":"<code>medium_precision()</code>  <code>classmethod</code>","text":"<p>Balanced precision/speed configuration (default).</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef medium_precision(cls) -&gt; Config:\n    \"\"\"Balanced precision/speed configuration (default).\"\"\"\n    return cls()\n</code></pre>"},{"location":"api/config/#leancert.config.Config.high_precision","title":"<code>high_precision()</code>  <code>classmethod</code>","text":"<p>High precision configuration.</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef high_precision(cls) -&gt; Config:\n    \"\"\"High precision configuration.\"\"\"\n    return cls(\n        taylor_depth=20,\n        max_iters=5000,\n        tolerance=Fraction(1, 100000),\n    )\n</code></pre>"},{"location":"api/config/#leancert.config.Config.dyadic","title":"<code>dyadic(precision=-53)</code>  <code>classmethod</code>","text":"<p>Configuration using Dyadic backend for high performance.</p> <p>Recommended for deep expressions, neural networks, or when rational arithmetic is too slow.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>int</code> <p>Dyadic precision (default -53, IEEE double-like).</p> <code>-53</code> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef dyadic(cls, precision: int = -53) -&gt; Config:\n    \"\"\"\n    Configuration using Dyadic backend for high performance.\n\n    Recommended for deep expressions, neural networks, or when\n    rational arithmetic is too slow.\n\n    Args:\n        precision: Dyadic precision (default -53, IEEE double-like).\n    \"\"\"\n    return cls(\n        backend=Backend.DYADIC,\n        dyadic_config=DyadicConfig(precision=precision),\n    )\n</code></pre>"},{"location":"api/config/#leancert.config.Config.dyadic_fast","title":"<code>dyadic_fast()</code>  <code>classmethod</code>","text":"<p>Fast Dyadic configuration with lower precision.</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef dyadic_fast(cls) -&gt; Config:\n    \"\"\"Fast Dyadic configuration with lower precision.\"\"\"\n    return cls(\n        taylor_depth=8,\n        max_iters=500,\n        tolerance=Fraction(1, 100),\n        backend=Backend.DYADIC,\n        dyadic_config=DyadicConfig.fast(),\n    )\n</code></pre>"},{"location":"api/config/#leancert.config.Config.dyadic_high_precision","title":"<code>dyadic_high_precision()</code>  <code>classmethod</code>","text":"<p>High precision Dyadic configuration.</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef dyadic_high_precision(cls) -&gt; Config:\n    \"\"\"High precision Dyadic configuration.\"\"\"\n    return cls(\n        taylor_depth=20,\n        max_iters=5000,\n        tolerance=Fraction(1, 100000),\n        backend=Backend.DYADIC,\n        dyadic_config=DyadicConfig.high_precision(),\n    )\n</code></pre>"},{"location":"api/config/#leancert.config.Config.affine","title":"<code>affine()</code>  <code>classmethod</code>","text":"<p>Configuration using Affine backend for tight bounds.</p> <p>Recommended for expressions with repeated variables where the dependency problem causes interval over-approximation.</p> Example <p>x - x on [-1, 1]: - Interval gives [-2, 2] - Affine gives [0, 0] (exact!)</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef affine(cls) -&gt; Config:\n    \"\"\"\n    Configuration using Affine backend for tight bounds.\n\n    Recommended for expressions with repeated variables where the\n    dependency problem causes interval over-approximation.\n\n    Example:\n        x - x on [-1, 1]:\n        - Interval gives [-2, 2]\n        - Affine gives [0, 0] (exact!)\n    \"\"\"\n    return cls(\n        backend=Backend.AFFINE,\n        affine_config=AffineConfig(),\n    )\n</code></pre>"},{"location":"api/config/#leancert.config.Config.affine_compact","title":"<code>affine_compact()</code>  <code>classmethod</code>","text":"<p>Affine configuration with noise symbol consolidation.</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef affine_compact(cls) -&gt; Config:\n    \"\"\"Affine configuration with noise symbol consolidation.\"\"\"\n    return cls(\n        backend=Backend.AFFINE,\n        affine_config=AffineConfig.compact(),\n    )\n</code></pre>"},{"location":"api/config/#factory-methods","title":"Factory Methods","text":"<pre><code># Precision presets\nlc.Config.low_precision()     # Fast, ~2 decimal places\nlc.Config.medium_precision()  # Default, ~3 decimal places\nlc.Config.high_precision()    # Slow, ~5 decimal places\n\n# Backend presets\nlc.Config.dyadic()            # IEEE double-like precision\nlc.Config.dyadic_fast()       # Lower precision, faster\nlc.Config.dyadic_high_precision()  # ~30 decimal digits\n\nlc.Config.affine()            # Affine arithmetic (tight bounds)\nlc.Config.affine_compact()    # With noise symbol consolidation\n</code></pre>"},{"location":"api/config/#dyadicconfig","title":"DyadicConfig","text":""},{"location":"api/config/#leancert.config.DyadicConfig","title":"<code>leancert.config.DyadicConfig</code>  <code>dataclass</code>","text":"<p>Configuration for Dyadic arithmetic backend.</p> <p>Attributes:</p> Name Type Description <code>precision</code> <code>int</code> <p>Minimum exponent for outward rounding. -53 gives IEEE       double-like precision (~15 decimal digits). Use -100 for       higher precision, -30 for faster computation.</p> <code>round_after_ops</code> <code>int</code> <p>Round after this many operations. 0 means round             after every operation (most sound, slightly slower).</p> Source code in <code>python/leancert/config.py</code> <pre><code>@dataclass\nclass DyadicConfig:\n    \"\"\"\n    Configuration for Dyadic arithmetic backend.\n\n    Attributes:\n        precision: Minimum exponent for outward rounding. -53 gives IEEE\n                  double-like precision (~15 decimal digits). Use -100 for\n                  higher precision, -30 for faster computation.\n        round_after_ops: Round after this many operations. 0 means round\n                        after every operation (most sound, slightly slower).\n    \"\"\"\n    precision: int = -53\n    round_after_ops: int = 0\n\n    @classmethod\n    def ieee_double(cls) -&gt; DyadicConfig:\n        \"\"\"IEEE double-like precision (~15 decimal digits).\"\"\"\n        return cls(precision=-53)\n\n    @classmethod\n    def high_precision(cls) -&gt; DyadicConfig:\n        \"\"\"High precision (~30 decimal digits).\"\"\"\n        return cls(precision=-100)\n\n    @classmethod\n    def fast(cls) -&gt; DyadicConfig:\n        \"\"\"Fast mode with lower precision (~9 decimal digits).\"\"\"\n        return cls(precision=-30)\n</code></pre>"},{"location":"api/config/#leancert.config.DyadicConfig.fast","title":"<code>fast()</code>  <code>classmethod</code>","text":"<p>Fast mode with lower precision (~9 decimal digits).</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef fast(cls) -&gt; DyadicConfig:\n    \"\"\"Fast mode with lower precision (~9 decimal digits).\"\"\"\n    return cls(precision=-30)\n</code></pre>"},{"location":"api/config/#leancert.config.DyadicConfig.high_precision","title":"<code>high_precision()</code>  <code>classmethod</code>","text":"<p>High precision (~30 decimal digits).</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef high_precision(cls) -&gt; DyadicConfig:\n    \"\"\"High precision (~30 decimal digits).\"\"\"\n    return cls(precision=-100)\n</code></pre>"},{"location":"api/config/#leancert.config.DyadicConfig.ieee_double","title":"<code>ieee_double()</code>  <code>classmethod</code>","text":"<p>IEEE double-like precision (~15 decimal digits).</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef ieee_double(cls) -&gt; DyadicConfig:\n    \"\"\"IEEE double-like precision (~15 decimal digits).\"\"\"\n    return cls(precision=-53)\n</code></pre>"},{"location":"api/config/#precision-levels","title":"Precision Levels","text":"Precision Decimal Digits Use Case <code>-30</code> ~9 Fast prototyping <code>-53</code> ~15 Default (IEEE double-like) <code>-100</code> ~30 High-precision verification <pre><code># Custom Dyadic configuration\nconfig = lc.Config(\n    backend=lc.Backend.DYADIC,\n    dyadic_config=lc.DyadicConfig(precision=-100)\n)\n</code></pre>"},{"location":"api/config/#affineconfig","title":"AffineConfig","text":""},{"location":"api/config/#leancert.config.AffineConfig","title":"<code>leancert.config.AffineConfig</code>  <code>dataclass</code>","text":"<p>Configuration for Affine arithmetic backend.</p> <p>Affine arithmetic tracks correlations between variables, solving the \"dependency problem\" in interval arithmetic. For example: - Interval: x - x on [-1, 1] gives [-2, 2] - Affine: x - x on [-1, 1] gives [0, 0] (exact!)</p> <p>Attributes:</p> Name Type Description <code>max_noise_symbols</code> <code>int</code> <p>Maximum noise symbols before consolidation.               0 means no limit. Higher limits give tighter               bounds but use more memory.</p> Source code in <code>python/leancert/config.py</code> <pre><code>@dataclass\nclass AffineConfig:\n    \"\"\"\n    Configuration for Affine arithmetic backend.\n\n    Affine arithmetic tracks correlations between variables, solving the\n    \"dependency problem\" in interval arithmetic. For example:\n    - Interval: x - x on [-1, 1] gives [-2, 2]\n    - Affine: x - x on [-1, 1] gives [0, 0] (exact!)\n\n    Attributes:\n        max_noise_symbols: Maximum noise symbols before consolidation.\n                          0 means no limit. Higher limits give tighter\n                          bounds but use more memory.\n    \"\"\"\n    max_noise_symbols: int = 0\n\n    @classmethod\n    def default(cls) -&gt; AffineConfig:\n        \"\"\"Default configuration with no symbol limit.\"\"\"\n        return cls()\n\n    @classmethod\n    def compact(cls) -&gt; AffineConfig:\n        \"\"\"Compact mode that consolidates noise symbols.\"\"\"\n        return cls(max_noise_symbols=100)\n</code></pre>"},{"location":"api/config/#leancert.config.AffineConfig.compact","title":"<code>compact()</code>  <code>classmethod</code>","text":"<p>Compact mode that consolidates noise symbols.</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef compact(cls) -&gt; AffineConfig:\n    \"\"\"Compact mode that consolidates noise symbols.\"\"\"\n    return cls(max_noise_symbols=100)\n</code></pre>"},{"location":"api/config/#leancert.config.AffineConfig.default","title":"<code>default()</code>  <code>classmethod</code>","text":"<p>Default configuration with no symbol limit.</p> Source code in <code>python/leancert/config.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; AffineConfig:\n    \"\"\"Default configuration with no symbol limit.\"\"\"\n    return cls()\n</code></pre>"},{"location":"api/config/#the-dependency-problem","title":"The Dependency Problem","text":"<p>Standard interval arithmetic loses correlations between variables:</p> <pre><code>x = lc.var('x')\n\n# Interval arithmetic: x - x on [-1, 1] gives [-2, 2]\nresult_interval = lc.find_bounds(x - x, {'x': (-1, 1)})\nprint(result_interval.max_hi)  # 2.0 (overapproximation!)\n\n# Affine arithmetic: x - x on [-1, 1] gives [0, 0]\nresult_affine = lc.find_bounds(x - x, {'x': (-1, 1)}, config=lc.Config.affine())\nprint(result_affine.max_hi)  # 0.0 (exact!)\n</code></pre> <p>Affine arithmetic tracks linear correlations, giving tighter bounds for:</p> <ul> <li>Expressions with repeated variables (<code>x*x - x*x</code>)</li> <li>LayerNorm in transformers (mean/variance correlation)</li> <li>Control systems with rotation matrices</li> </ul> <pre><code># Custom Affine configuration\nconfig = lc.Config(\n    backend=lc.Backend.AFFINE,\n    affine_config=lc.AffineConfig(max_noise_symbols=100)\n)\n</code></pre>"},{"location":"api/config/#witness-synthesis-options","title":"Witness Synthesis Options","text":"<p>These options control the behavior of <code>synthesize_*_witness</code> methods.</p>"},{"location":"api/config/#race_strategies","title":"race_strategies","text":"<p>When <code>True</code>, races multiple backends (dyadic, affine, rational) in parallel and uses the first to complete successfully. Useful for unknown expressions where you don't know which backend will perform best.</p> <pre><code>config = lc.Config(race_strategies=True, timeout_ms=5000)\nresult = solver.synthesize_min_witness(expr, domain, config=config)\nprint(result.strategy_used)  # Which backend won\n</code></pre>"},{"location":"api/config/#incremental_refinement","title":"incremental_refinement","text":"<p>When <code>True</code>, iteratively refines the bound using binary search to find the tightest provable value. Returns a history of refinement attempts.</p> <pre><code>config = lc.Config(incremental_refinement=True)\nresult = solver.synthesize_max_witness(expr, domain, config=config)\nprint(result.refinement_history)\n# [{'bound': 2.8, 'status': 'verified'}, {'bound': 2.75, 'status': 'verified'}, ...]\n</code></pre>"},{"location":"api/config/#target_bound","title":"target_bound","text":"<p>Sets a target bound for incremental refinement. Refinement stops when this bound is proven or exceeded.</p> <pre><code>config = lc.Config(incremental_refinement=True, target_bound=2.72)\nresult = solver.synthesize_max_witness(lc.exp(x), {'x': (0, 1)}, config=config)\n</code></pre>"},{"location":"api/config/#timeout_ms","title":"timeout_ms","text":"<p>Timeout in milliseconds for racing and refinement operations (default: 30000).</p> <pre><code>config = lc.Config(race_strategies=True, timeout_ms=10000)  # 10 second timeout\n</code></pre>"},{"location":"api/config/#examples","title":"Examples","text":""},{"location":"api/config/#neural-network-verification","title":"Neural Network Verification","text":"<p>For neural networks, use Dyadic for speed:</p> <pre><code>import leancert as lc\n\n# Neural network expression (deep computation graph)\nnet_output = build_network_expr(weights, biases)\n\n# Dyadic is 10-100x faster than rational for deep expressions\nconfig = lc.Config.dyadic()\nresult = lc.find_bounds(net_output, input_domain, config=config)\n</code></pre>"},{"location":"api/config/#transformer-layernorm","title":"Transformer LayerNorm","text":"<p>For transformers with LayerNorm, use Affine for tight bounds:</p> <pre><code>import leancert as lc\n\n# LayerNorm has correlated mean/variance computation\nlayernorm_expr = build_layernorm_expr(x, gamma, beta)\n\n# Affine arithmetic tracks correlations\nconfig = lc.Config.affine()\nresult = lc.find_bounds(layernorm_expr, input_domain, config=config)\n</code></pre>"},{"location":"api/config/#high-precision-proofs","title":"High-Precision Proofs","text":"<p>For formal proofs requiring maximum precision:</p> <pre><code>import leancert as lc\n\nconfig = lc.Config.high_precision()\nresult = lc.find_bounds(expr, domain, config=config)\n\n# Export certificate for Lean verification\nresult.certificate.save(\"proof.json\")\n</code></pre>"},{"location":"api/config/#custom-configuration","title":"Custom Configuration","text":"<pre><code>from fractions import Fraction\nimport leancert as lc\n\nconfig = lc.Config(\n    taylor_depth=15,           # More Taylor terms\n    max_iters=2000,            # More optimization iterations\n    tolerance=Fraction(1, 10000),  # Tighter tolerance\n    use_monotonicity=True,     # Enable monotonicity pruning\n    timeout_sec=120.0,         # 2 minute timeout\n    backend=lc.Backend.DYADIC,\n    dyadic_config=lc.DyadicConfig(precision=-80),\n)\n\nresult = lc.find_bounds(expr, domain, config=config)\n</code></pre>"},{"location":"api/config/#witness-synthesis-with-racing","title":"Witness Synthesis with Racing","text":"<p>For complex expressions where you don't know the best backend:</p> <pre><code>import leancert as lc\n\nx = lc.var('x')\nexpr = lc.exp(x) * lc.sin(x)  # Unknown which backend is best\n\nwith lc.Solver() as solver:\n    # Race all backends, use first to succeed\n    config = lc.Config(race_strategies=True, timeout_ms=10000)\n    result = solver.synthesize_min_witness(expr, {'x': (0, 3)}, config=config)\n\n    print(f\"Winner: {result.strategy_used}\")\n    print(f\"Minimum witness: {result.witness_value}\")\n    print(result.to_lean_tactic())\n</code></pre>"},{"location":"api/config/#incremental-refinement-for-tight-bounds","title":"Incremental Refinement for Tight Bounds","text":"<p>Find the tightest provable bound through iterative refinement:</p> <pre><code>import leancert as lc\n\nx = lc.var('x')\n\nwith lc.Solver() as solver:\n    # Find tightest provable upper bound for exp(x) on [0, 1]\n    config = lc.Config(incremental_refinement=True)\n    result = solver.synthesize_max_witness(lc.exp(x), {'x': (0, 1)}, config=config)\n\n    print(f\"Tightest bound: {float(result.witness_value):.6f}\")\n    print(f\"Refinement steps: {len(result.refinement_history)}\")\n    for step in result.refinement_history:\n        print(f\"  {step['bound']:.6f} -&gt; {step['status']}\")\n</code></pre>"},{"location":"api/expr/","title":"Expressions and Domains","text":""},{"location":"api/expr/#building-expressions","title":"Building Expressions","text":"<p>LeanCert uses symbolic expressions that are reified to the Lean AST.</p>"},{"location":"api/expr/#variables","title":"Variables","text":"<pre><code>import leancert as lc\n\nx = lc.var('x')\ny = lc.var('y')\n</code></pre>"},{"location":"api/expr/#constants","title":"Constants","text":"<pre><code>c = lc.const(3.14159)\nhalf = lc.const(1, 2)  # Fraction 1/2\n</code></pre>"},{"location":"api/expr/#arithmetic","title":"Arithmetic","text":"<pre><code>expr = x**2 + 2*x + 1\nexpr = (x + y) / (x - y)\n</code></pre>"},{"location":"api/expr/#transcendental-functions","title":"Transcendental Functions","text":"<pre><code>lc.sin(x)\nlc.cos(x)\nlc.exp(x)\nlc.log(x)\nlc.sqrt(x)\nlc.tan(x)\nlc.atan(x)\nlc.sinh(x)\nlc.cosh(x)\nlc.tanh(x)\nlc.arsinh(x)\nlc.atanh(x)\nlc.abs(x)\n</code></pre>"},{"location":"api/expr/#special-functions","title":"Special Functions","text":"<pre><code>lc.sinc(x)  # sin(x)/x with sinc(0) = 1\nlc.erf(x)   # Error function\n</code></pre>"},{"location":"api/expr/#minmaxclamp","title":"Min/Max/Clamp","text":"<pre><code>lc.Min(x, y)\nlc.Max(x, y)\nlc.clamp(x, lo, hi)  # Equivalent to Min(Max(x, lo), hi)\n</code></pre>"},{"location":"api/expr/#domain-specification","title":"Domain Specification","text":""},{"location":"api/expr/#intervals","title":"Intervals","text":"<pre><code>from leancert import Interval\n\nI = Interval(0, 1)       # [0, 1]\nI = Interval(-1, 1)      # [-1, 1]\nI = Interval(\"1/3\", 1)   # [1/3, 1] (exact rational)\n</code></pre>"},{"location":"api/expr/#boxes-multi-dimensional","title":"Boxes (Multi-dimensional)","text":"<pre><code>from leancert import Box\n\n# Using a dictionary\nbox = Box({'x': (0, 1), 'y': (-1, 1)})\n\n# Or pass directly to solver functions\nresult = lc.find_bounds(x + y, {'x': (0, 1), 'y': (0, 1)})\n</code></pre>"},{"location":"api/expr/#simplification","title":"Simplification","text":"<p>LeanCert includes symbolic simplification to mitigate the dependency problem in interval arithmetic.</p>"},{"location":"api/expr/#leancert.simplify.simplify","title":"<code>leancert.simplify.simplify(expr)</code>","text":"<p>Simplify an expression algebraically.</p> <p>This applies multiple simplification strategies: 1. Constant folding (2 + 3 -&gt; 5) 2. Identity removal (x + 0 -&gt; x, x * 1 -&gt; x) 3. Zero propagation (x * 0 -&gt; 0) 4. Negation simplification (--x -&gt; x) 5. Like term collection in polynomial form 6. Subexpression cancellation</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to simplify</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>Simplified expression (mathematically equivalent)</p> Source code in <code>python/leancert/simplify.py</code> <pre><code>def simplify(expr: Expr) -&gt; Expr:\n    \"\"\"\n    Simplify an expression algebraically.\n\n    This applies multiple simplification strategies:\n    1. Constant folding (2 + 3 -&gt; 5)\n    2. Identity removal (x + 0 -&gt; x, x * 1 -&gt; x)\n    3. Zero propagation (x * 0 -&gt; 0)\n    4. Negation simplification (--x -&gt; x)\n    5. Like term collection in polynomial form\n    6. Subexpression cancellation\n\n    Args:\n        expr: Expression to simplify\n\n    Returns:\n        Simplified expression (mathematically equivalent)\n    \"\"\"\n    # Convert to polynomial form, simplify, convert back\n    poly = to_polynomial(expr)\n    if poly is not None:\n        return from_polynomial(poly)\n\n    # Fall back to recursive simplification for non-polynomial expressions\n    return _simplify_recursive(expr)\n</code></pre>"},{"location":"api/expr/#leancert.simplify.expand","title":"<code>leancert.simplify.expand(expr)</code>","text":"<p>Fully expand an expression (distribute multiplication over addition).</p> <p>This is useful when you want to expose all terms for cancellation.</p> Source code in <code>python/leancert/simplify.py</code> <pre><code>def expand(expr: Expr) -&gt; Expr:\n    \"\"\"\n    Fully expand an expression (distribute multiplication over addition).\n\n    This is useful when you want to expose all terms for cancellation.\n    \"\"\"\n    poly = to_polynomial(expr)\n    if poly is not None:\n        return from_polynomial(poly)\n    return _simplify_recursive(expr)\n</code></pre>"},{"location":"api/expr/#example","title":"Example","text":"<pre><code>x = lc.var('x')\n\n# Without simplification, (x*100 + 5) - (x*100) on [0, 1e10]\n# would give bounds like [-1e12, 1e12] due to dependency\n\n# With simplification, it reduces to 5\nexpr = (x * 100 + 5) - (x * 100)\nsimplified = lc.simplify(expr)\n# simplified is const(5)\n</code></pre>"},{"location":"api/expr/#expression-reference","title":"Expression Reference","text":""},{"location":"api/expr/#leancert.expr.Expr","title":"<code>leancert.expr.Expr</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for symbolic expressions.</p> <p>Expressions are immutable and can be composed using Python operators. They track their free variables and can be compiled to kernel representation.</p> Source code in <code>python/leancert/expr.py</code> <pre><code>class Expr(ABC):\n    \"\"\"\n    Base class for symbolic expressions.\n\n    Expressions are immutable and can be composed using Python operators.\n    They track their free variables and can be compiled to kernel representation.\n    \"\"\"\n\n    @abstractmethod\n    def free_vars(self) -&gt; FrozenSet[str]:\n        \"\"\"Return all variable names used in this expression.\"\"\"\n        ...\n\n    @abstractmethod\n    def compile(self, var_order: list[str]) -&gt; KernelExpr:\n        \"\"\"\n        Compile to De Bruijn representation given variable ordering.\n\n        Args:\n            var_order: List of variable names. Index in list = De Bruijn index.\n\n        Returns:\n            JSON-serializable dict for the Lean kernel.\n\n        Raises:\n            CompilationError: If a variable is not in var_order.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def evaluate(self, env: EvalEnv) -&gt; EvalResult:\n        \"\"\"\n        Evaluate the expression concretely using Python math.\n\n        Used for counterexample verification to filter false positives.\n        When the solver reports a potential bug, we evaluate the expression\n        at the reported point using standard Python arithmetic. If the\n        concrete value doesn't violate the bound, it's a false positive\n        caused by interval over-approximation.\n\n        Args:\n            env: Dictionary mapping variable names to concrete values.\n\n        Returns:\n            The concrete value (float for transcendentals, Fraction for polynomials).\n\n        Raises:\n            ValueError: If a required variable is not in env.\n        \"\"\"\n        ...\n\n    # Operator overloading for natural math syntax\n    def __neg__(self) -&gt; Expr:\n        return Neg(self)\n\n    def __add__(self, other: ExprLike) -&gt; Expr:\n        return Add(self, _to_expr(other))\n\n    def __radd__(self, other: ExprLike) -&gt; Expr:\n        return Add(_to_expr(other), self)\n\n    def __sub__(self, other: ExprLike) -&gt; Expr:\n        return Sub(self, _to_expr(other))\n\n    def __rsub__(self, other: ExprLike) -&gt; Expr:\n        return Sub(_to_expr(other), self)\n\n    def __mul__(self, other: ExprLike) -&gt; Expr:\n        return Mul(self, _to_expr(other))\n\n    def __rmul__(self, other: ExprLike) -&gt; Expr:\n        return Mul(_to_expr(other), self)\n\n    def __truediv__(self, other: ExprLike) -&gt; Expr:\n        return Div(self, _to_expr(other))\n\n    def __rtruediv__(self, other: ExprLike) -&gt; Expr:\n        return Div(_to_expr(other), self)\n\n    def __pow__(self, n: int) -&gt; Expr:\n        if not isinstance(n, int) or n &lt; 0:\n            raise ValueError(\"Only non-negative integer powers are supported\")\n        return Pow(self, n)\n</code></pre>"},{"location":"api/expr/#leancert.expr.Expr.free_vars","title":"<code>free_vars()</code>  <code>abstractmethod</code>","text":"<p>Return all variable names used in this expression.</p> Source code in <code>python/leancert/expr.py</code> <pre><code>@abstractmethod\ndef free_vars(self) -&gt; FrozenSet[str]:\n    \"\"\"Return all variable names used in this expression.\"\"\"\n    ...\n</code></pre>"},{"location":"api/expr/#leancert.expr.var","title":"<code>leancert.expr.var(name)</code>","text":"<p>Create a symbolic variable with the given name.</p> Source code in <code>python/leancert/expr.py</code> <pre><code>def var(name: str) -&gt; Variable:\n    \"\"\"Create a symbolic variable with the given name.\"\"\"\n    if not isinstance(name, str):\n        raise TypeError(f\"Variable name must be a string, got {type(name).__name__}\")\n    if not name:\n        raise ValueError(\"Variable name cannot be empty\")\n    return Variable(name)\n</code></pre>"},{"location":"api/expr/#leancert.expr.const","title":"<code>leancert.expr.const(value)</code>","text":"<p>Create a constant expression.</p> Source code in <code>python/leancert/expr.py</code> <pre><code>def const(value: Union[int, float, Fraction]) -&gt; Const:\n    \"\"\"Create a constant expression.\"\"\"\n    return Const(value)\n</code></pre>"},{"location":"api/lipschitz/","title":"Lipschitz Bounds","text":"<p>LeanCert can compute verified Lipschitz constants for expressions, enabling rigorous continuity proofs and error bounds.</p>"},{"location":"api/lipschitz/#overview","title":"Overview","text":"<p>A function <code>f</code> is Lipschitz continuous with constant <code>L</code> if:</p> \\[|f(x) - f(y)| \\leq L \\cdot |x - y|\\] <p>for all <code>x, y</code> in the domain. LeanCert computes <code>L</code> by bounding the derivative:</p> \\[L = \\sup_{x \\in I} |f'(x)|\\] <p>This is justified by the Mean Value Theorem: for differentiable <code>f</code>, there exists <code>c</code> between <code>x</code> and <code>y</code> such that <code>f(x) - f(y) = f'(c)(x - y)</code>.</p>"},{"location":"api/lipschitz/#computing-lipschitz-bounds","title":"Computing Lipschitz Bounds","text":"<pre><code>import leancert as lc\n\nx = lc.var('x')\nwith lc.Solver() as solver:\n    result = solver.compute_lipschitz_bound(\n        lc.sin(x),\n        {'x': (0, 3.14159)}\n    )\n\n    print(result.lipschitz_bound)   # 1.0 (since |cos(x)| \u2264 1)\n    print(result.gradient_bounds)   # {'x': Interval(-1, 1)}\n</code></pre>"},{"location":"api/lipschitz/#lipschitzresult","title":"LipschitzResult","text":"<p>The <code>LipschitzResult</code> dataclass contains:</p> Field Type Description <code>lipschitz_bound</code> <code>Fraction</code> Verified Lipschitz constant L <code>gradient_bounds</code> <code>dict[str, Interval]</code> Derivative bounds per variable <code>certificate</code> <code>Certificate</code> Lean-verifiable proof data"},{"location":"api/lipschitz/#methods","title":"Methods","text":""},{"location":"api/lipschitz/#delta_for_epsilonepsilon-float-float","title":"<code>delta_for_epsilon(epsilon: float) -&gt; float</code>","text":"<p>Compute the \u03b4 that guarantees \u03b5-\u03b4 continuity:</p> <pre><code>result = solver.compute_lipschitz_bound(expr, domain)\n\n# For any \u03b5, this \u03b4 guarantees |f(x) - f(a)| &lt; \u03b5 when |x - a| &lt; \u03b4\ndelta = result.delta_for_epsilon(0.001)  # \u03b4 = \u03b5/L\n</code></pre>"},{"location":"api/lipschitz/#to_lean_tactic-str","title":"<code>to_lean_tactic() -&gt; str</code>","text":"<p>Generate Lean proof code:</p> <pre><code>print(result.to_lean_tactic())\n# Output:\n# -- Lipschitz bound for sin(x) on [0, \u03c0]\n# -- L = 1, derived from |\u2202f/\u2202x| \u2264 1\n# apply lipschitz_continuous_of_bound\n# \u00b7 exact 1\n# \u00b7 interval_deriv_bound\n</code></pre>"},{"location":"api/lipschitz/#multivariate-functions","title":"Multivariate Functions","text":"<p>For multivariate functions, the Lipschitz constant is derived from the gradient norm:</p> \\[L = \\sup_{x \\in I} \\|\\nabla f(x)\\|_\\infty = \\max_i \\sup_{x \\in I} |\\partial f / \\partial x_i|\\] <pre><code>x, y = lc.var('x'), lc.var('y')\nexpr = x**2 + y**2\n\nresult = solver.compute_lipschitz_bound(\n    expr,\n    {'x': (-1, 1), 'y': (-1, 1)}\n)\n\nprint(result.gradient_bounds)\n# {'x': Interval(-2, 2), 'y': Interval(-2, 2)}\nprint(result.lipschitz_bound)  # 2.0 (max of |2x|, |2y| over domain)\n</code></pre>"},{"location":"api/lipschitz/#applications","title":"Applications","text":""},{"location":"api/lipschitz/#1-continuity-proofs-","title":"1. Continuity Proofs (\u03b5-\u03b4)","text":"<p>The primary use case is proving continuity:</p> <pre><code>from leancert.quantifier import QuantifierSynthesizer\n\nsynth = QuantifierSynthesizer(solver)\nresult = synth.epsilon_delta(\n    lc.exp(x),\n    variable='x',\n    point=0.0,\n    limit=1.0,  # exp(0) = 1\n    neighborhood_radius=1.0\n)\n# Uses Lipschitz bound L\u2248e to derive \u03b4=\u03b5/L\n</code></pre>"},{"location":"api/lipschitz/#2-error-propagation","title":"2. Error Propagation","text":"<p>Bound how input errors affect outputs:</p> <pre><code>result = solver.compute_lipschitz_bound(expr, domain)\nL = float(result.lipschitz_bound)\n\ninput_error = 1e-6\noutput_error_bound = L * input_error\n</code></pre>"},{"location":"api/lipschitz/#3-numerical-stability-analysis","title":"3. Numerical Stability Analysis","text":"<p>Verify that small perturbations produce small changes:</p> <pre><code># Check if neural network output is stable\nresult = solver.compute_lipschitz_bound(nn_expr, input_bounds)\nif result.lipschitz_bound &lt; 10:\n    print(\"Network is reasonably stable\")\n</code></pre>"},{"location":"api/lipschitz/#how-it-works","title":"How It Works","text":"<ol> <li>Symbolic Differentiation: The expression AST is differentiated symbolically</li> <li>Interval Evaluation: Derivative bounds are computed via interval arithmetic</li> <li>Lipschitz Extraction: <code>L = max(|lo|, |hi|)</code> for each gradient component</li> <li>Certificate Generation: The Lean kernel verifies the derivative bounds</li> </ol> <p>The Lean bridge exposes this via the <code>deriv_interval</code> method:</p> <pre><code># Low-level access (usually use compute_lipschitz_bound instead)\nresult = client.deriv_interval(expr_json, box_json, taylor_depth=10)\n# Returns: {'gradients': [...], 'lipschitz_bound': '3/2'}\n</code></pre>"},{"location":"api/lipschitz/#configuration","title":"Configuration","text":"<pre><code>config = lc.Config(\n    taylor_depth=20,  # Higher depth = tighter derivative bounds\n)\nresult = solver.compute_lipschitz_bound(expr, domain, config=config)\n</code></pre>"},{"location":"api/lipschitz/#see-also","title":"See Also","text":"<ul> <li>Quantifier Synthesis - Uses Lipschitz bounds for \u03b5-\u03b4 proofs</li> <li>Golden Theorems - Theoretical foundations</li> </ul>"},{"location":"api/quantifier/","title":"Quantifier Synthesis","text":"<p>The <code>quantifier</code> module provides verified witness synthesis for quantified mathematical statements. All witnesses are validated through the Lean kernel, ensuring soundness.</p>"},{"location":"api/quantifier/#overview","title":"Overview","text":"<p>Quantifier synthesis automates the construction of witnesses for common proof patterns:</p> <pre><code>import leancert as lc\nfrom leancert.quantifier import QuantifierSynthesizer\n\nx = lc.var('x')\nwith lc.Solver() as solver:\n    synth = QuantifierSynthesizer(solver)\n\n    # Prove \u2200 x \u2208 [0, 6], 1 + sin(x) \u2265 0\n    result = synth.forall_sign(1 + lc.sin(x), {'x': (0, 6)}, sign='non_negative')\n    print(result.success)  # True\n</code></pre>"},{"location":"api/quantifier/#supported-patterns","title":"Supported Patterns","text":"Pattern Goal Form Method Verification <code>FORALL_SIGN</code> <code>\u2200 x \u2208 I, f(x) \u2265 0</code> <code>forall_sign()</code> Interval arithmetic <code>EXISTS_ROOT</code> <code>\u2203 x \u2208 I, f(x) = 0</code> <code>exists_root()</code> Root finding <code>EXISTS_FORALL_BOUND</code> <code>\u2203 M, \u2200 x \u2208 I, \\|f(x)\\| \u2264 M</code> <code>exists_forall_bound()</code> Global optimization <code>MINIMUM_WITNESS</code> <code>\u2203 m, \u2200 x \u2208 I, f(x) \u2265 m</code> <code>minimum_witness()</code> Global optimization <code>MAXIMUM_WITNESS</code> <code>\u2203 M, \u2200 x \u2208 I, f(x) \u2264 M</code> <code>maximum_witness()</code> Global optimization <code>EPSILON_DELTA</code> <code>\u2200 \u03b5&gt;0, \u2203 \u03b4&gt;0, \\|x-a\\|&lt;\u03b4 \u2192 \\|f(x)-L\\|&lt;\u03b5</code> <code>epsilon_delta()</code> Lipschitz bounds"},{"location":"api/quantifier/#pattern-details","title":"Pattern Details","text":""},{"location":"api/quantifier/#forall_sign-universal-sign-conditions","title":"FORALL_SIGN - Universal Sign Conditions","text":"<p>Proves that a function maintains a sign condition over an entire interval.</p> <pre><code># Prove \u2200 x \u2208 [0, 6], 1 + sin(x) \u2265 0\nresult = synth.forall_sign(\n    1 + lc.sin(x),\n    {'x': (0, 6)},\n    sign='non_negative'  # or 'positive', 'negative', 'non_positive'\n)\n\nprint(result.success)     # True\nprint(result.lean_proof)  # Lean proof code\n</code></pre> <p>How it works: Uses interval arithmetic to compute rigorous bounds over the domain. The Lean kernel verifies that the interval satisfies the sign condition.</p> <p>Note: For tight bounds (like <code>sin(x) \u2265 0</code> on <code>[0, \u03c0]</code>), interval arithmetic may be too conservative. Use adaptive verification for such cases.</p>"},{"location":"api/quantifier/#exists_root-existential-root-witnesses","title":"EXISTS_ROOT - Existential Root Witnesses","text":"<p>Proves existence of a root by finding a concrete witness.</p> <pre><code># Prove \u2203 x \u2208 [1, 2], x\u00b2 - 2 = 0 (i.e., \u221a2 exists)\nresult = synth.exists_root(\n    x**2 - 2,\n    {'x': (1, 2)}\n)\n\nprint(result.success)     # True\nprint(result.witnesses)   # [Witness(value={'x': 1.414...}, ...)]\n</code></pre> <p>How it works: Uses bisection or Newton's method to locate a root, then verifies via interval evaluation that a sign change occurs.</p>"},{"location":"api/quantifier/#minimum_witness-global-minimum","title":"MINIMUM_WITNESS - Global Minimum","text":"<p>Synthesizes a verified lower bound witness.</p> <pre><code># Prove \u2203 m, \u2200 x \u2208 [0, 2\u03c0], cos(x) \u2265 m\nresult = synth.minimum_witness(\n    lc.cos(x),\n    {'x': (0, 6.28318)}\n)\n\nprint(result.success)              # True\nprint(result.witnesses[0].value)   # {'x': 3.14159} (point where min achieved)\nprint(result.witnesses[0].rigorous_bounds)  # Interval[-1, 0]\n</code></pre> <p>How it works: Calls <code>solver.synthesize_min_witness()</code> which uses verified branch-and-bound optimization. The witness includes both the minimum value and the point where it's achieved.</p>"},{"location":"api/quantifier/#maximum_witness-global-maximum","title":"MAXIMUM_WITNESS - Global Maximum","text":"<p>Synthesizes a verified upper bound witness.</p> <pre><code># Prove \u2203 M, \u2200 x \u2208 [0, 1], exp(x) \u2264 M\nresult = synth.maximum_witness(\n    lc.exp(x),\n    {'x': (0, 1)}\n)\n\nprint(result.success)              # True\nprint(result.witnesses[0].value)   # {'x': 1.0}\nprint(result.witnesses[0].rigorous_bounds)  # Interval containing e\n</code></pre>"},{"location":"api/quantifier/#exists_forall_bound-absolute-bound-witness","title":"EXISTS_FORALL_BOUND - Absolute Bound Witness","text":"<p>Proves existence of an absolute bound over the domain.</p> <pre><code># Prove \u2203 M, \u2200 x \u2208 [-1, 1], |sin(x)| \u2264 M\nresult = synth.exists_forall_bound(\n    lc.sin(x),\n    {'x': (-1, 1)},\n    abs_bound=True\n)\n\nprint(result.success)     # True\nprint(result.witnesses)   # Contains the bound M\n</code></pre>"},{"location":"api/quantifier/#epsilon_delta-continuity-proofs","title":"EPSILON_DELTA - Continuity Proofs","text":"<p>Proves continuity at a point via the \u03b5-\u03b4 definition using Lipschitz bounds.</p> <pre><code># Prove sin is continuous at x=0 with limit 0:\n# \u2200 \u03b5 &gt; 0, \u2203 \u03b4 &gt; 0, |x - 0| &lt; \u03b4 \u2192 |sin(x) - 0| &lt; \u03b5\nresult = synth.epsilon_delta(\n    lc.sin(x),\n    variable='x',\n    point=0.0,\n    limit=0.0,  # sin(0) = 0\n    neighborhood_radius=1.0\n)\n\nprint(result.success)     # True\nprint(result.message)     # 'VERIFIED: Lipschitz L=1.000000, \u03b4=\u03b5/L for 3 \u03b5 values'\nprint(result.witnesses)   # [Witness(value=0.1, variable='\u03b4(\u03b5=0.1)', ...), ...]\n</code></pre> <p>How it works: Computes a verified Lipschitz constant <code>L</code> via derivative bounds (see Lipschitz Bounds). Then <code>\u03b4 = \u03b5/L</code> satisfies the continuity condition by the Mean Value Theorem.</p>"},{"location":"api/quantifier/#result-structure","title":"Result Structure","text":"<p>All methods return a <code>QuantifierResult</code>:</p> <pre><code>@dataclass\nclass QuantifierResult:\n    pattern: QuantifierPattern    # Which pattern was used\n    success: bool                 # Whether synthesis succeeded\n    witnesses: list[Witness]      # Synthesized witnesses\n    lean_proof: Optional[str]     # Generated Lean proof code\n    message: str                  # Human-readable status\n    certificate: Optional[Certificate]  # Verification certificate\n</code></pre> <p>Each <code>Witness</code> contains:</p> <pre><code>@dataclass\nclass Witness:\n    value: Union[float, dict[str, float]]  # Witness value or point\n    variable: str                           # Variable name\n    witness_type: str                       # 'point', 'bound', etc.\n    rigorous_bounds: Optional[Interval]     # Verified interval bounds\n    certificate: Optional[Certificate]      # Lean-verifiable proof data\n</code></pre>"},{"location":"api/quantifier/#proof-generation","title":"Proof Generation","text":"<p>All synthesis methods generate Lean-compatible proof code:</p> <pre><code>result = synth.minimum_witness(x**2 - 2*x + 1, {'x': (0, 2)})\n\nprint(result.lean_proof)\n# Output:\n# -- Auto-synthesized minimum witness\n# -- Witness value: 0.0000000000\n# -- Achieved at: x = 1.000000\n# ...\n</code></pre>"},{"location":"api/quantifier/#error-handling","title":"Error Handling","text":"<p>When synthesis fails, check the result:</p> <pre><code>result = synth.forall_sign(lc.sin(x), {'x': (0, 4)}, sign='positive')\n\nif not result.success:\n    print(result.message)  # Explains why it failed\n</code></pre>"},{"location":"api/quantifier/#see-also","title":"See Also","text":"<ul> <li>Lipschitz Bounds - How \u03b5-\u03b4 proofs derive \u03b4 from Lipschitz constants</li> <li>Adaptive Verification - Domain splitting for complex expressions</li> <li>Solver API - Low-level witness synthesis methods</li> </ul>"},{"location":"api/solver/","title":"Solver API","text":"<p>The <code>Solver</code> class is the main entry point for the Python SDK. It manages communication with the Lean kernel and handles the verification lifecycle.</p>"},{"location":"api/solver/#solver-class","title":"Solver Class","text":""},{"location":"api/solver/#leancert.solver.Solver","title":"<code>leancert.solver.Solver</code>","text":"<p>High-level interface for LeanCert verification.</p> <p>Manages compilation and communication with the Lean kernel. Use as a context manager for automatic cleanup.</p> Example <p>with Solver() as solver:     x = var('x')     result = solver.find_bounds(x**2, {'x': (0, 1)})</p>"},{"location":"api/solver/#leancert.solver.Solver.__init__","title":"<code>__init__(client=None, auto_simplify=True, auto_affine=True)</code>","text":"<p>Initialize the solver.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Optional[LeanClient]</code> <p>Optional LeanClient instance. If None, creates a new one.</p> <code>None</code> <code>auto_simplify</code> <code>bool</code> <p>If True (default), automatically simplify expressions           before sending to the kernel. This reduces the dependency           problem in interval arithmetic by canceling like terms.</p> <code>True</code> <code>auto_affine</code> <code>bool</code> <p>If True (default), automatically switch to Affine backend         for expressions with the dependency problem (same variable         appears multiple times). This gives much tighter bounds         for expressions like x - x, x * (1 - x), etc.</p> <code>True</code>"},{"location":"api/solver/#leancert.solver.Solver.find_bounds","title":"<code>find_bounds(expr, domain, config=Config())</code>","text":"<p>Find global minimum and maximum bounds.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to analyze.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Domain specification (Interval, Box, tuple, or dict).</p> required <code>config</code> <code>Config</code> <p>Solver configuration. Defaults to DYADIC backend.    For expressions with repeated variables (e.g., x - x, x*(1-x)),    AFFINE backend is automatically used for tighter bounds.</p> <code>Config()</code> <p>Returns:</p> Type Description <code>BoundsResult</code> <p>BoundsResult with verified min/max intervals.</p> Example"},{"location":"api/solver/#leancert.solver.Solver.find_bounds--default-uses-dyadic-backend-fast-avoids-denominator-explosion","title":"Default: uses Dyadic backend (fast, avoids denominator explosion)","text":"<p>result = solver.find_bounds(x**2, {'x': (-1, 1)})</p>"},{"location":"api/solver/#leancert.solver.Solver.find_bounds--dependency-problem-auto-detected-uses-affine-for-tight-bounds","title":"Dependency problem auto-detected, uses Affine for tight bounds:","text":"<p>result = solver.find_bounds(x - x, {'x': (-1, 1)})  # Returns ~[0, 0]</p>"},{"location":"api/solver/#leancert.solver.Solver.find_bounds--explicit-backend-choice-overrides-auto-selection","title":"Explicit backend choice overrides auto-selection:","text":"<p>result = solver.find_bounds(expr, domain, Config.affine())</p>"},{"location":"api/solver/#leancert.solver.Solver.find_roots","title":"<code>find_roots(expr, domain, config=Config())</code>","text":"<p>Find roots of a univariate expression.</p> <p>Uses interval bisection with sign change detection. The algorithm subdivides the domain and checks each subinterval for roots.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to find roots of.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Search domain (must be 1D).</p> required <code>config</code> <code>Config</code> <p>Solver configuration.</p> <code>Config()</code> <p>Returns:</p> Type Description <code>RootsResult</code> <p>RootsResult with root intervals. Each RootInterval has a status:</p> <code>RootsResult</code> <ul> <li>'confirmed': Sign change detected (f(lo) and f(hi) have opposite signs). The Intermediate Value Theorem GUARANTEES a root exists in this interval. This is mathematically certain.</li> </ul> <code>RootsResult</code> <ul> <li>'possible': The interval contains zero but no sign change was detected. This can happen when:</li> <li>The root is a tangent point (e.g., x\u00b2 = 0 at x=0)</li> <li>Interval bounds are too loose to detect sign change</li> <li>Multiple roots in the interval cancel out A root MAY exist but is not proven.</li> </ul> <code>RootsResult</code> <ul> <li>'no_root': The interval provably contains no roots (f(x) is bounded away from zero throughout the interval).</li> </ul> Example <p>result = solver.find_roots(x**2 - 1, {'x': (-2, 2)}) for root in result.roots: ...     print(f\"{root.interval}: {root.status}\") [-1.001, -0.999]: confirmed  # Sign change proves root at x=-1 [0.999, 1.001]: confirmed    # Sign change proves root at x=1</p>"},{"location":"api/solver/#leancert.solver.Solver.find_unique_root","title":"<code>find_unique_root(expr, domain, config=Config())</code>","text":"<p>Find a unique root using interval Newton method.</p> <p>This method uses interval Newton iteration to prove both EXISTENCE and UNIQUENESS of a root. It's mathematically stronger than find_roots() which only proves existence.</p> <p>The interval Newton method works by: 1. Computing the interval derivative f'([x]) 2. Performing Newton step: N(x) = m - f(m)/f'([x]) where m = midpoint 3. If N(x) \u2282 [x] (contracts), uniqueness is proven by Brouwer fixed point</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to find root of.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Search domain (must be 1D).</p> required <code>config</code> <code>Config</code> <p>Solver configuration.</p> <code>Config()</code> <p>Returns:</p> Type Description <code>UniqueRootResult</code> <p>UniqueRootResult with:</p> <code>UniqueRootResult</code> <ul> <li>unique: True if a unique root is PROVEN to exist</li> </ul> <code>UniqueRootResult</code> <ul> <li>interval: Containing interval for the root</li> </ul> <code>UniqueRootResult</code> <ul> <li>reason: Explanation of the result:</li> <li>'contraction': Newton iteration contracted, proving uniqueness</li> <li>'no_contraction': Could not prove uniqueness (root may still exist)</li> <li>'no_root': Interval provably contains no roots</li> </ul> Note <p>'no_contraction' does NOT mean no root exists. It means uniqueness couldn't be proven. The interval might: - Contain multiple roots - Be too wide for Newton to contract - Have a nearly-zero derivative (ill-conditioned)</p> <p>Use find_roots() first to locate candidate intervals, then find_unique_root() on smaller subintervals if uniqueness matters.</p>"},{"location":"api/solver/#leancert.solver.Solver.verify_bound","title":"<code>verify_bound(expr, domain, upper=None, lower=None, config=Config(), method='adaptive')</code>","text":"<p>Verify that expression satisfies given bounds with False Positive Filtering.</p> <p>Pipeline: 1. Symbolic Simplification (handles dependency problem) 2. Global Optimization (Branch &amp; Bound) 3. Counterexample Concretization (filters false positives)</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to verify.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Domain specification.</p> required <code>upper</code> <code>Optional[float]</code> <p>Upper bound to verify (expr &lt;= upper).</p> <code>None</code> <code>lower</code> <code>Optional[float]</code> <p>Lower bound to verify (expr &gt;= lower).</p> <code>None</code> <code>config</code> <code>Config</code> <p>Solver configuration.</p> <code>Config()</code> <code>method</code> <code>str</code> <p>Verification method - 'adaptive' (default, uses optimization    with false positive filtering) or 'interval' (fast, conservative).</p> <code>'adaptive'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if verified.</p> <p>Raises:</p> Type Description <code>VerificationFailed</code> <p>If bound verification fails AND is confirmed by                concrete evaluation (not a false positive).</p> <code>ValueError</code> <p>If method is invalid or no bounds specified.</p>"},{"location":"api/solver/#leancert.solver.Solver.integrate","title":"<code>integrate(expr, domain, partitions=10, config=Config())</code>","text":"<p>Compute rigorous integral bounds.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to integrate.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Integration domain.</p> required <code>partitions</code> <code>int</code> <p>Number of partitions.</p> <code>10</code> <code>config</code> <code>Config</code> <p>Solver configuration.</p> <code>Config()</code> <p>Returns:</p> Type Description <code>IntegralResult</code> <p>IntegralResult with verified bounds.</p>"},{"location":"api/solver/#leancert.solver.Solver.synthesize_min_witness","title":"<code>synthesize_min_witness(expr, domain, config=Config())</code>","text":"<p>Synthesize a witness for \u2203 m, \u2200 x \u2208 I, f(x) \u2265 m.</p> <p>Finds the global minimum of the expression over the domain and returns a witness value m along with the point where the minimum is achieved.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to minimize.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Domain specification.</p> required <code>config</code> <code>Config</code> <p>Solver configuration. Use race_strategies=True to try    multiple backends in parallel.</p> <code>Config()</code> <p>Returns:</p> Type Description <code>MinWitnessResult</code> <p>MinWitnessResult containing the witness value and point.</p> Example <p>result = solver.synthesize_min_witness(x**2, {'x': (-1, 1)}) print(result.witness_value)  # ~0 print(result.to_lean_tactic())  # Lean proof code</p>"},{"location":"api/solver/#leancert.solver.Solver.synthesize_max_witness","title":"<code>synthesize_max_witness(expr, domain, config=Config())</code>","text":"<p>Synthesize a witness for \u2203 M, \u2200 x \u2208 I, f(x) \u2264 M.</p> <p>Finds the global maximum of the expression over the domain and returns a witness value M along with the point where the maximum is achieved.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to maximize.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Domain specification.</p> required <code>config</code> <code>Config</code> <p>Solver configuration.</p> <code>Config()</code> <p>Returns:</p> Type Description <code>MaxWitnessResult</code> <p>MaxWitnessResult containing the witness value and point.</p>"},{"location":"api/solver/#leancert.solver.Solver.synthesize_root_witness","title":"<code>synthesize_root_witness(expr, domain, config=Config())</code>","text":"<p>Synthesize a witness for \u2203 x \u2208 I, f(x) = 0.</p> <p>Finds a root of the expression in the domain and returns a witness point along with the enclosing interval.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to find root of.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Search domain (must be 1D).</p> required <code>config</code> <code>Config</code> <p>Solver configuration.</p> <code>Config()</code> <p>Returns:</p> Type Description <code>RootWitnessResult</code> <p>RootWitnessResult containing the witness point and interval.</p> <p>Raises:</p> Type Description <code>VerificationFailed</code> <p>If no root can be found/proven.</p>"},{"location":"api/solver/#leancert.solver.Solver.compute_lipschitz_bound","title":"<code>compute_lipschitz_bound(expr, domain, config=Config())</code>","text":"<p>Compute a verified Lipschitz bound for an expression over a domain.</p> <p>Uses forward-mode automatic differentiation to bound all partial derivatives |\u2202f/\u2202x\u1d62| over the domain. The Lipschitz constant is L = max_i sup_{x \u2208 domain} |\u2202f/\u2202x\u1d62(x)|.</p> <p>This is VERIFIED by the Lean kernel - the derivative bounds are computed using interval arithmetic with correctness proofs.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to compute Lipschitz bound for.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Domain over which to compute the bound.</p> required <code>config</code> <code>Config</code> <p>Solver configuration.</p> <code>Config()</code> <p>Returns:</p> Type Description <code>'LipschitzResult'</code> <p>LipschitzResult containing: - lipschitz_bound: The verified Lipschitz constant L - gradient_bounds: Dict mapping variable names to derivative intervals - certificate: Verification certificate</p> Example <p>solver = Solver() x = var('x') result = solver.compute_lipschitz_bound(x**2, {'x': (0, 1)}) print(result.lipschitz_bound)  # Should be 2 (max of |2x| on [0,1]) 2</p> <p>Use case (\u03b5-\u03b4 continuity):     If L is the Lipschitz constant, then for any \u03b5 &gt; 0,     setting \u03b4 = \u03b5/L guarantees |f(x) - f(a)| &lt; \u03b5 whenever |x - a| &lt; \u03b4.</p>"},{"location":"api/solver/#leancert.solver.Solver.diagnose_bound_failure","title":"<code>diagnose_bound_failure(expr, domain, upper=None, lower=None, config=Config())</code>","text":"<p>Diagnose why a bound verification would fail.</p> <p>This is the foundation for Counterexample-Guided Proof Refinement (CEGPR). It finds the worst-case point and suggests a bound that would succeed.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to analyze.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Domain specification.</p> required <code>upper</code> <code>Optional[float]</code> <p>Upper bound to check.</p> <code>None</code> <code>lower</code> <code>Optional[float]</code> <p>Lower bound to check.</p> <code>None</code> <code>config</code> <code>Config</code> <p>Solver configuration.</p> <code>Config()</code> <p>Returns:</p> Type Description <code>Optional[FailureDiagnosis]</code> <p>FailureDiagnosis if the bound would fail, None if it would succeed.</p>"},{"location":"api/solver/#convenience-functions","title":"Convenience Functions","text":"<p>These standalone functions use a default solver instance for quick scripting.</p>"},{"location":"api/solver/#leancert.solver.find_bounds","title":"<code>leancert.solver.find_bounds(expr, domain, config=Config())</code>","text":"<p>Find global min/max bounds for an expression.</p> Source code in <code>python/leancert/solver.py</code> <pre><code>def find_bounds(\n    expr: Expr,\n    domain: Union[Interval, Box, tuple, dict],\n    config: Config = Config(),\n) -&gt; BoundsResult:\n    \"\"\"Find global min/max bounds for an expression.\"\"\"\n    return _get_solver().find_bounds(expr, domain, config)\n</code></pre>"},{"location":"api/solver/#leancert.solver.find_roots","title":"<code>leancert.solver.find_roots(expr, domain, config=Config())</code>","text":"<p>Find roots of a univariate expression.</p> <p>Returns RootInterval objects with status: - 'confirmed': Sign change detected, root GUARANTEED by IVT - 'possible': Contains zero but no sign change (may or may not have root) - 'no_root': Provably no roots in interval</p> Source code in <code>python/leancert/solver.py</code> <pre><code>def find_roots(\n    expr: Expr,\n    domain: Union[Interval, Box, tuple, dict],\n    config: Config = Config(),\n) -&gt; RootsResult:\n    \"\"\"\n    Find roots of a univariate expression.\n\n    Returns RootInterval objects with status:\n    - 'confirmed': Sign change detected, root GUARANTEED by IVT\n    - 'possible': Contains zero but no sign change (may or may not have root)\n    - 'no_root': Provably no roots in interval\n    \"\"\"\n    return _get_solver().find_roots(expr, domain, config)\n</code></pre>"},{"location":"api/solver/#leancert.solver.find_unique_root","title":"<code>leancert.solver.find_unique_root(expr, domain, config=Config())</code>","text":"<p>Find a unique root using interval Newton method.</p> <p>Returns UniqueRootResult with: - unique=True: A unique root is PROVEN to exist (Newton contracted) - unique=False with reason='no_contraction': Couldn't prove uniqueness   (root may still exist, try a smaller interval) - unique=False with reason='no_root': Provably no roots</p> Source code in <code>python/leancert/solver.py</code> <pre><code>def find_unique_root(\n    expr: Expr,\n    domain: Union[Interval, Box, tuple, dict],\n    config: Config = Config(),\n) -&gt; UniqueRootResult:\n    \"\"\"\n    Find a unique root using interval Newton method.\n\n    Returns UniqueRootResult with:\n    - unique=True: A unique root is PROVEN to exist (Newton contracted)\n    - unique=False with reason='no_contraction': Couldn't prove uniqueness\n      (root may still exist, try a smaller interval)\n    - unique=False with reason='no_root': Provably no roots\n    \"\"\"\n    return _get_solver().find_unique_root(expr, domain, config)\n</code></pre>"},{"location":"api/solver/#leancert.solver.verify_bound","title":"<code>leancert.solver.verify_bound(expr, domain, upper=None, lower=None, config=Config(), method='adaptive')</code>","text":"<p>Verify that an expression satisfies bounds with false positive filtering.</p> <p>This function uses global optimization with counterexample concretization to filter false positives caused by interval over-approximation.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to verify.</p> required <code>domain</code> <code>Union[Interval, Box, tuple, dict]</code> <p>Domain specification.</p> required <code>upper</code> <code>Optional[float]</code> <p>Upper bound to verify (expr &lt;= upper).</p> <code>None</code> <code>lower</code> <code>Optional[float]</code> <p>Lower bound to verify (expr &gt;= lower).</p> <code>None</code> <code>config</code> <code>Config</code> <p>Solver configuration.</p> <code>Config()</code> <code>method</code> <code>str</code> <p>'adaptive' (default, uses optimization with false positive    filtering) or 'interval' (fast, conservative).</p> <code>'adaptive'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if verified.</p> <p>Raises:</p> Type Description <code>VerificationFailed</code> <p>If bound verification fails AND is confirmed by                concrete evaluation (not a false positive).</p> Source code in <code>python/leancert/solver.py</code> <pre><code>def verify_bound(\n    expr: Expr,\n    domain: Union[Interval, Box, tuple, dict],\n    upper: Optional[float] = None,\n    lower: Optional[float] = None,\n    config: Config = Config(),\n    method: str = 'adaptive',\n) -&gt; bool:\n    \"\"\"Verify that an expression satisfies bounds with false positive filtering.\n\n    This function uses global optimization with counterexample concretization\n    to filter false positives caused by interval over-approximation.\n\n    Args:\n        expr: Expression to verify.\n        domain: Domain specification.\n        upper: Upper bound to verify (expr &lt;= upper).\n        lower: Lower bound to verify (expr &gt;= lower).\n        config: Solver configuration.\n        method: 'adaptive' (default, uses optimization with false positive\n               filtering) or 'interval' (fast, conservative).\n\n    Returns:\n        True if verified.\n\n    Raises:\n        VerificationFailed: If bound verification fails AND is confirmed by\n                           concrete evaluation (not a false positive).\n    \"\"\"\n    return _get_solver().verify_bound(expr, domain, upper, lower, config, method)\n</code></pre>"},{"location":"api/solver/#leancert.solver.integrate","title":"<code>leancert.solver.integrate(expr, domain, partitions=10, config=Config())</code>","text":"<p>Compute rigorous integral bounds.</p> Source code in <code>python/leancert/solver.py</code> <pre><code>def integrate(\n    expr: Expr,\n    domain: Union[Interval, Box, tuple, dict],\n    partitions: int = 10,\n    config: Config = Config(),\n) -&gt; IntegralResult:\n    \"\"\"Compute rigorous integral bounds.\"\"\"\n    return _get_solver().integrate(expr, domain, partitions, config)\n</code></pre>"},{"location":"api/solver/#witness-synthesis","title":"Witness Synthesis","text":"<p>LeanCert can automatically synthesize witnesses for existential proof goals. This allows Lean to delegate witness construction to Python, which finds witnesses via optimization or root-finding and returns certificate-checked results.</p>"},{"location":"api/solver/#supported-goal-forms","title":"Supported Goal Forms","text":"Goal Form Method Description <code>\u2203 m, \u2200 x \u2208 I, f(x) \u2265 m</code> <code>synthesize_min_witness</code> Find global minimum witness <code>\u2203 M, \u2200 x \u2208 I, f(x) \u2264 M</code> <code>synthesize_max_witness</code> Find global maximum witness <code>\u2203 x \u2208 I, f(x) = 0</code> <code>synthesize_root_witness</code> Find root existence witness"},{"location":"api/solver/#example-minimum-witness","title":"Example: Minimum Witness","text":"<pre><code>import leancert as lc\n\nx = lc.var('x')\nwith lc.Solver() as solver:\n    # Synthesize witness for \u2203 m, \u2200 x \u2208 [0,1], x\u00b2 \u2265 m\n    result = solver.synthesize_min_witness(x**2, {'x': (0, 1)})\n\n    print(result.witness_value)   # ~0 (the minimum)\n    print(result.witness_point)   # WitnessPoint(x=0.0, f=0.0)\n    print(result.to_lean_tactic())  # Lean proof code\n</code></pre>"},{"location":"api/solver/#example-root-witness","title":"Example: Root Witness","text":"<pre><code>import leancert as lc\n\nx = lc.var('x')\nwith lc.Solver() as solver:\n    # Synthesize witness for \u2203 x \u2208 [0.5, 1.5], x\u00b2 - 1 = 0\n    result = solver.synthesize_root_witness(x**2 - 1, {'x': (0.5, 1.5)})\n\n    print(result.witness_point)   # WitnessPoint(x\u22481.0, f\u22480.0)\n    print(result.proof_method)    # 'newton_contraction' or 'sign_change'\n</code></pre>"},{"location":"api/solver/#proof-strategy-racing","title":"Proof Strategy Racing","text":"<p>For unknown expressions, race multiple backends in parallel:</p> <pre><code>config = lc.Config(race_strategies=True, timeout_ms=5000)\nresult = solver.synthesize_min_witness(expr, domain, config=config)\nprint(result.strategy_used)  # 'dyadic', 'affine', or 'rational'\n</code></pre>"},{"location":"api/solver/#incremental-refinement","title":"Incremental Refinement","text":"<p>Find the tightest provable bound:</p> <pre><code>config = lc.Config(incremental_refinement=True)\nresult = solver.synthesize_max_witness(lc.exp(x), {'x': (0, 1)}, config=config)\nprint(result.refinement_history)  # [{bound: 2.8, status: 'verified'}, ...]\n</code></pre>"},{"location":"api/solver/#lipschitz-bounds","title":"Lipschitz Bounds","text":"<p>LeanCert can compute verified Lipschitz constants for expressions by bounding derivatives via interval arithmetic.</p> <pre><code>import leancert as lc\n\nx = lc.var('x')\nwith lc.Solver() as solver:\n    result = solver.compute_lipschitz_bound(\n        lc.sin(x),\n        {'x': (0, 3.14159)}\n    )\n\n    print(result.lipschitz_bound)   # Fraction(1, 1) = 1.0\n    print(result.gradient_bounds)   # {'x': Interval(-1, 1)}\n\n    # Use for \u03b5-\u03b4 continuity: \u03b4 = \u03b5/L\n    delta = result.delta_for_epsilon(0.01)  # 0.01\n</code></pre> <p>See Lipschitz Bounds for detailed documentation.</p>"},{"location":"api/solver/#failure-diagnosis-cegpr","title":"Failure Diagnosis (CEGPR)","text":"<p>The <code>diagnose_bound_failure</code> method supports Counterexample-Guided Proof Refinement by analyzing why a bound verification would fail:</p> <pre><code>x = lc.var('x')\nwith lc.Solver() as solver:\n    # Try to prove exp(x) \u2264 2.5 on [0,1] - this fails!\n    diagnosis = solver.diagnose_bound_failure(\n        lc.exp(x), {'x': (0, 1)}, upper=2.5\n    )\n\n    if diagnosis:\n        print(diagnosis.failure_type)    # 'bound_too_tight'\n        print(diagnosis.margin)          # -0.218... (negative = violated)\n        print(diagnosis.worst_point)     # {'x': 0.999...}\n        print(diagnosis.suggested_bound) # 2.746... (would succeed)\n</code></pre>"},{"location":"api/types/","title":"Result Types","text":"<p>LeanCert returns rich result objects containing both numerical data and verification certificates.</p>"},{"location":"api/types/#boundsresult","title":"BoundsResult","text":"<p>Returned by <code>find_bounds()</code>.</p>"},{"location":"api/types/#leancert.result.BoundsResult","title":"<code>leancert.result.BoundsResult</code>  <code>dataclass</code>","text":"<p>Result of finding global bounds.</p> <p>Contains intervals enclosing the minimum and maximum values, along with a verification certificate.</p> Access Patterns Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass BoundsResult:\n    \"\"\"\n    Result of finding global bounds.\n\n    Contains intervals enclosing the minimum and maximum values,\n    along with a verification certificate.\n\n    Access Patterns:\n        # Get the interval bounds (Interval objects)\n        result.min_bound  # Interval containing true minimum\n        result.max_bound  # Interval containing true maximum\n\n        # Get exact Fraction endpoints\n        result.min_bound.lo  # Lower bound of min interval (rigorous)\n        result.max_bound.hi  # Upper bound of max interval (rigorous)\n\n        # Get float approximations (for comparisons/display)\n        result.min_lo  # float(min_bound.lo) - guaranteed lower bound\n        result.min_hi  # float(min_bound.hi) - upper estimate of minimum\n        result.max_lo  # float(max_bound.lo) - lower estimate of maximum\n        result.max_hi  # float(max_bound.hi) - guaranteed upper bound\n\n        # Get midpoint approximations\n        result.min_value  # midpoint of min_bound (approximate)\n        result.max_value  # midpoint of max_bound (approximate)\n    \"\"\"\n    min_bound: Interval\n    max_bound: Interval\n    verified: bool\n    certificate: Optional[Certificate] = None\n\n    # --- Convenience float accessors for bounds ---\n\n    @property\n    def min_lo(self) -&gt; float:\n        \"\"\"Guaranteed lower bound on minimum value.\"\"\"\n        return float(self.min_bound.lo)\n\n    @property\n    def min_hi(self) -&gt; float:\n        \"\"\"Upper estimate of minimum value.\"\"\"\n        return float(self.min_bound.hi)\n\n    @property\n    def max_lo(self) -&gt; float:\n        \"\"\"Lower estimate of maximum value.\"\"\"\n        return float(self.max_bound.lo)\n\n    @property\n    def max_hi(self) -&gt; float:\n        \"\"\"Guaranteed upper bound on maximum value.\"\"\"\n        return float(self.max_bound.hi)\n\n    @property\n    def min_value(self) -&gt; float:\n        \"\"\"Approximate minimum (midpoint of min_bound).\"\"\"\n        return float(self.min_bound.midpoint())\n\n    @property\n    def max_value(self) -&gt; float:\n        \"\"\"Approximate maximum (midpoint of max_bound).\"\"\"\n        return float(self.max_bound.midpoint())\n\n    def save(self, path: str) -&gt; None:\n        \"\"\"Save the certificate to a file.\"\"\"\n        if self.certificate:\n            self.certificate.save(path)\n        else:\n            raise ValueError(\"No certificate available to save\")\n\n    def __repr__(self) -&gt; str:\n        status = \"verified\" if self.verified else \"unverified\"\n        return (\n            f\"BoundsResult(\\n\"\n            f\"  min_bound={self.min_bound},\\n\"\n            f\"  max_bound={self.max_bound},\\n\"\n            f\"  verified={self.verified}\\n\"\n            f\")\"\n        )\n</code></pre>"},{"location":"api/types/#leancert.result.BoundsResult--get-the-interval-bounds-interval-objects","title":"Get the interval bounds (Interval objects)","text":"<p>result.min_bound  # Interval containing true minimum result.max_bound  # Interval containing true maximum</p>"},{"location":"api/types/#leancert.result.BoundsResult--get-exact-fraction-endpoints","title":"Get exact Fraction endpoints","text":"<p>result.min_bound.lo  # Lower bound of min interval (rigorous) result.max_bound.hi  # Upper bound of max interval (rigorous)</p>"},{"location":"api/types/#leancert.result.BoundsResult--get-float-approximations-for-comparisonsdisplay","title":"Get float approximations (for comparisons/display)","text":"<p>result.min_lo  # float(min_bound.lo) - guaranteed lower bound result.min_hi  # float(min_bound.hi) - upper estimate of minimum result.max_lo  # float(max_bound.lo) - lower estimate of maximum result.max_hi  # float(max_bound.hi) - guaranteed upper bound</p>"},{"location":"api/types/#leancert.result.BoundsResult--get-midpoint-approximations","title":"Get midpoint approximations","text":"<p>result.min_value  # midpoint of min_bound (approximate) result.max_value  # midpoint of max_bound (approximate)</p>"},{"location":"api/types/#leancert.result.BoundsResult.max_hi","title":"<code>max_hi</code>  <code>property</code>","text":"<p>Guaranteed upper bound on maximum value.</p>"},{"location":"api/types/#leancert.result.BoundsResult.max_lo","title":"<code>max_lo</code>  <code>property</code>","text":"<p>Lower estimate of maximum value.</p>"},{"location":"api/types/#leancert.result.BoundsResult.max_value","title":"<code>max_value</code>  <code>property</code>","text":"<p>Approximate maximum (midpoint of max_bound).</p>"},{"location":"api/types/#leancert.result.BoundsResult.min_hi","title":"<code>min_hi</code>  <code>property</code>","text":"<p>Upper estimate of minimum value.</p>"},{"location":"api/types/#leancert.result.BoundsResult.min_lo","title":"<code>min_lo</code>  <code>property</code>","text":"<p>Guaranteed lower bound on minimum value.</p>"},{"location":"api/types/#leancert.result.BoundsResult.min_value","title":"<code>min_value</code>  <code>property</code>","text":"<p>Approximate minimum (midpoint of min_bound).</p>"},{"location":"api/types/#leancert.result.BoundsResult.save","title":"<code>save(path)</code>","text":"<p>Save the certificate to a file.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def save(self, path: str) -&gt; None:\n    \"\"\"Save the certificate to a file.\"\"\"\n    if self.certificate:\n        self.certificate.save(path)\n    else:\n        raise ValueError(\"No certificate available to save\")\n</code></pre>"},{"location":"api/types/#rootsresult","title":"RootsResult","text":"<p>Returned by <code>find_roots()</code>.</p>"},{"location":"api/types/#leancert.result.RootsResult","title":"<code>leancert.result.RootsResult</code>  <code>dataclass</code>","text":"<p>Result of finding roots.</p> <p>Contains intervals that may contain roots, with status indicating the certainty level.</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass RootsResult:\n    \"\"\"\n    Result of finding roots.\n\n    Contains intervals that may contain roots, with status indicating\n    the certainty level.\n    \"\"\"\n    roots: list[RootInterval]\n    iterations: int\n    verified: bool\n    certificate: Optional[Certificate] = None\n\n    def confirmed_roots(self) -&gt; list[RootInterval]:\n        \"\"\"Return only roots with confirmed sign change.\"\"\"\n        return [r for r in self.roots if r.status == 'confirmed']\n\n    def possible_roots(self) -&gt; list[RootInterval]:\n        \"\"\"Return roots that may exist but aren't confirmed.\"\"\"\n        return [r for r in self.roots if r.status == 'possible']\n\n    def __repr__(self) -&gt; str:\n        confirmed = len(self.confirmed_roots())\n        total = len(self.roots)\n        return f\"RootsResult({confirmed}/{total} confirmed, {self.iterations} iterations)\"\n</code></pre>"},{"location":"api/types/#leancert.result.RootsResult.confirmed_roots","title":"<code>confirmed_roots()</code>","text":"<p>Return only roots with confirmed sign change.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def confirmed_roots(self) -&gt; list[RootInterval]:\n    \"\"\"Return only roots with confirmed sign change.\"\"\"\n    return [r for r in self.roots if r.status == 'confirmed']\n</code></pre>"},{"location":"api/types/#leancert.result.RootsResult.possible_roots","title":"<code>possible_roots()</code>","text":"<p>Return roots that may exist but aren't confirmed.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def possible_roots(self) -&gt; list[RootInterval]:\n    \"\"\"Return roots that may exist but aren't confirmed.\"\"\"\n    return [r for r in self.roots if r.status == 'possible']\n</code></pre>"},{"location":"api/types/#rootinterval","title":"RootInterval","text":"<p>Represents an isolating interval for a root.</p>"},{"location":"api/types/#leancert.result.RootInterval","title":"<code>leancert.result.RootInterval</code>  <code>dataclass</code>","text":"<p>A single root interval with its status.</p> Access Patterns <p>root.interval       # The Interval object root.status         # 'confirmed', 'possible', 'no_root', 'unique' root.lo             # float lower bound of interval root.hi             # float upper bound of interval root.value          # float midpoint (approximate root location) root.width          # float interval width (uncertainty)</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass RootInterval:\n    \"\"\"\n    A single root interval with its status.\n\n    Access Patterns:\n        root.interval       # The Interval object\n        root.status         # 'confirmed', 'possible', 'no_root', 'unique'\n        root.lo             # float lower bound of interval\n        root.hi             # float upper bound of interval\n        root.value          # float midpoint (approximate root location)\n        root.width          # float interval width (uncertainty)\n    \"\"\"\n    interval: Interval\n    status: str  # 'confirmed', 'possible', 'no_root', 'unique'\n\n    @property\n    def lo(self) -&gt; float:\n        \"\"\"Lower bound of root interval.\"\"\"\n        return float(self.interval.lo)\n\n    @property\n    def hi(self) -&gt; float:\n        \"\"\"Upper bound of root interval.\"\"\"\n        return float(self.interval.hi)\n\n    @property\n    def value(self) -&gt; float:\n        \"\"\"Approximate root value (midpoint of interval).\"\"\"\n        return float(self.interval.midpoint())\n\n    @property\n    def width(self) -&gt; float:\n        \"\"\"Width of root interval (uncertainty measure).\"\"\"\n        return float(self.interval.width())\n\n    def __repr__(self) -&gt; str:\n        return f\"RootInterval({self.interval}, status='{self.status}')\"\n</code></pre>"},{"location":"api/types/#leancert.result.RootInterval.hi","title":"<code>hi</code>  <code>property</code>","text":"<p>Upper bound of root interval.</p>"},{"location":"api/types/#leancert.result.RootInterval.lo","title":"<code>lo</code>  <code>property</code>","text":"<p>Lower bound of root interval.</p>"},{"location":"api/types/#leancert.result.RootInterval.value","title":"<code>value</code>  <code>property</code>","text":"<p>Approximate root value (midpoint of interval).</p>"},{"location":"api/types/#leancert.result.RootInterval.width","title":"<code>width</code>  <code>property</code>","text":"<p>Width of root interval (uncertainty measure).</p>"},{"location":"api/types/#uniquerootresult","title":"UniqueRootResult","text":"<p>Returned by <code>find_unique_root()</code>.</p>"},{"location":"api/types/#leancert.result.UniqueRootResult","title":"<code>leancert.result.UniqueRootResult</code>  <code>dataclass</code>","text":"<p>Result of unique root finding via Newton contraction.</p> <p>When Newton iteration contracts, it proves both existence AND uniqueness of a root in the interval. This is a mathematically stronger result than ordinary root finding (which only proves existence via sign change).</p> Access Patterns <p>result.unique       # bool - True if unique root proven result.interval     # Interval object containing the root result.reason       # 'newton_contraction', 'no_contraction', 'newton_step_failed' result.lo           # float lower bound result.hi           # float upper bound result.root_value   # float midpoint (approximate root) result.width        # float interval width (uncertainty)</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass UniqueRootResult:\n    \"\"\"\n    Result of unique root finding via Newton contraction.\n\n    When Newton iteration contracts, it proves both existence AND uniqueness\n    of a root in the interval. This is a mathematically stronger result\n    than ordinary root finding (which only proves existence via sign change).\n\n    Access Patterns:\n        result.unique       # bool - True if unique root proven\n        result.interval     # Interval object containing the root\n        result.reason       # 'newton_contraction', 'no_contraction', 'newton_step_failed'\n        result.lo           # float lower bound\n        result.hi           # float upper bound\n        result.root_value   # float midpoint (approximate root)\n        result.width        # float interval width (uncertainty)\n    \"\"\"\n    unique: bool  # True if unique root proven\n    interval: Interval  # Refined interval containing the root\n    reason: str  # 'newton_contraction', 'no_contraction', 'newton_step_failed'\n    certificate: Optional[Certificate] = None\n\n    @property\n    def lo(self) -&gt; float:\n        \"\"\"Lower bound of root interval.\"\"\"\n        return float(self.interval.lo)\n\n    @property\n    def hi(self) -&gt; float:\n        \"\"\"Upper bound of root interval.\"\"\"\n        return float(self.interval.hi)\n\n    @property\n    def root_value(self) -&gt; float:\n        \"\"\"Approximate root value (midpoint of interval).\"\"\"\n        return float(self.interval.midpoint())\n\n    @property\n    def width(self) -&gt; float:\n        \"\"\"Width of root interval (uncertainty measure).\"\"\"\n        return float(self.interval.width())\n\n    def __repr__(self) -&gt; str:\n        if self.unique:\n            return f\"UniqueRootResult(UNIQUE root in {self.interval})\"\n        return f\"UniqueRootResult(not proven unique, {self.reason})\"\n</code></pre>"},{"location":"api/types/#leancert.result.UniqueRootResult.hi","title":"<code>hi</code>  <code>property</code>","text":"<p>Upper bound of root interval.</p>"},{"location":"api/types/#leancert.result.UniqueRootResult.lo","title":"<code>lo</code>  <code>property</code>","text":"<p>Lower bound of root interval.</p>"},{"location":"api/types/#leancert.result.UniqueRootResult.root_value","title":"<code>root_value</code>  <code>property</code>","text":"<p>Approximate root value (midpoint of interval).</p>"},{"location":"api/types/#leancert.result.UniqueRootResult.width","title":"<code>width</code>  <code>property</code>","text":"<p>Width of root interval (uncertainty measure).</p>"},{"location":"api/types/#integralresult","title":"IntegralResult","text":"<p>Returned by <code>integrate()</code>.</p>"},{"location":"api/types/#leancert.result.IntegralResult","title":"<code>leancert.result.IntegralResult</code>  <code>dataclass</code>","text":"<p>Result of numerical integration.</p> <p>Contains an interval enclosing the true integral value.</p> Access Patterns <p>result.bounds       # Interval object enclosing true integral result.verified     # bool verification status result.lo           # float guaranteed lower bound result.hi           # float guaranteed upper bound result.value        # float midpoint (approximate integral) result.error        # float maximum error (interval width)</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass IntegralResult:\n    \"\"\"\n    Result of numerical integration.\n\n    Contains an interval enclosing the true integral value.\n\n    Access Patterns:\n        result.bounds       # Interval object enclosing true integral\n        result.verified     # bool verification status\n        result.lo           # float guaranteed lower bound\n        result.hi           # float guaranteed upper bound\n        result.value        # float midpoint (approximate integral)\n        result.error        # float maximum error (interval width)\n    \"\"\"\n    bounds: Interval\n    verified: bool\n    certificate: Optional[Certificate] = None\n\n    @property\n    def lo(self) -&gt; float:\n        \"\"\"Guaranteed lower bound on integral.\"\"\"\n        return float(self.bounds.lo)\n\n    @property\n    def hi(self) -&gt; float:\n        \"\"\"Guaranteed upper bound on integral.\"\"\"\n        return float(self.bounds.hi)\n\n    @property\n    def value(self) -&gt; float:\n        \"\"\"Approximate integral value (midpoint).\"\"\"\n        return float(self.bounds.midpoint())\n\n    @property\n    def error(self) -&gt; float:\n        \"\"\"Maximum error (width of bounds interval).\"\"\"\n        return float(self.bounds.width())\n\n    def error_bound(self) -&gt; Fraction:\n        \"\"\"Maximum error (width of the bounds interval). Returns exact Fraction.\"\"\"\n        return self.bounds.width()\n\n    def __repr__(self) -&gt; str:\n        return f\"IntegralResult(bounds={self.bounds}, error&lt;={self.error:.2e})\"\n</code></pre>"},{"location":"api/types/#leancert.result.IntegralResult.error","title":"<code>error</code>  <code>property</code>","text":"<p>Maximum error (width of bounds interval).</p>"},{"location":"api/types/#leancert.result.IntegralResult.hi","title":"<code>hi</code>  <code>property</code>","text":"<p>Guaranteed upper bound on integral.</p>"},{"location":"api/types/#leancert.result.IntegralResult.lo","title":"<code>lo</code>  <code>property</code>","text":"<p>Guaranteed lower bound on integral.</p>"},{"location":"api/types/#leancert.result.IntegralResult.value","title":"<code>value</code>  <code>property</code>","text":"<p>Approximate integral value (midpoint).</p>"},{"location":"api/types/#leancert.result.IntegralResult.error_bound","title":"<code>error_bound()</code>","text":"<p>Maximum error (width of the bounds interval). Returns exact Fraction.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def error_bound(self) -&gt; Fraction:\n    \"\"\"Maximum error (width of the bounds interval). Returns exact Fraction.\"\"\"\n    return self.bounds.width()\n</code></pre>"},{"location":"api/types/#certificate","title":"Certificate","text":"<p>Contains the verification certificate that can be exported to Lean.</p>"},{"location":"api/types/#leancert.result.Certificate","title":"<code>leancert.result.Certificate</code>  <code>dataclass</code>","text":"<p>A verification certificate that can be saved and reloaded.</p> <p>Certificates contain all the information needed to reproduce and verify a computation.</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass Certificate:\n    \"\"\"\n    A verification certificate that can be saved and reloaded.\n\n    Certificates contain all the information needed to reproduce\n    and verify a computation.\n    \"\"\"\n    operation: str\n    expr_json: dict[str, Any]\n    domain_json: list[dict[str, Any]]\n    result_json: dict[str, Any]\n    verified: bool\n    lean_version: str\n    leancert_version: str\n    computation_time_ms: Optional[float] = None\n    metadata: dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert to JSON-serializable dictionary.\"\"\"\n        return {\n            'operation': self.operation,\n            'expr': self.expr_json,\n            'domain': self.domain_json,\n            'result': self.result_json,\n            'verified': self.verified,\n            'lean_version': self.lean_version,\n            'leancert_version': self.leancert_version,\n            'computation_time_ms': self.computation_time_ms,\n            'metadata': self.metadata,\n        }\n\n    def save(self, path: str) -&gt; None:\n        \"\"\"Save certificate to a JSON file.\"\"\"\n        with open(path, 'w') as f:\n            json.dump(self.to_dict(), f, indent=2)\n\n    @classmethod\n    def load(cls, path: str) -&gt; Certificate:\n        \"\"\"Load certificate from a JSON file.\"\"\"\n        with open(path) as f:\n            data = json.load(f)\n\n        return cls(\n            operation=data['operation'],\n            expr_json=data['expr'],\n            domain_json=data['domain'],\n            result_json=data['result'],\n            verified=data['verified'],\n            lean_version=data['lean_version'],\n            leancert_version=data['leancert_version'],\n            computation_time_ms=data.get('computation_time_ms'),\n            metadata=data.get('metadata', {}),\n        )\n\n    def hash(self) -&gt; str:\n        \"\"\"Compute SHA256 hash of the certificate content.\"\"\"\n        # Create deterministic JSON string\n        content = json.dumps(self.to_dict(), sort_keys=True)\n        return hashlib.sha256(content.encode()).hexdigest()\n\n    def to_lean_tactic(self) -&gt; str:\n        \"\"\"\n        Generate Lean tactic code that reproduces the verified proof.\n\n        Returns a string of Lean code that can be pasted into a Lean file.\n        This provides the \"round trip\" - Python finds the certificate,\n        then generates Lean code that verifies it.\n\n        Example output for find_bounds:\n            theorem bound_check : \u2200 x \u2208 Set.Icc 0 1, x^2 \u2264 1 := by\n              interval_bound 10\n\n        Example output for verify_bound:\n            theorem upper_bound_check : \u2200 x \u2208 I, f x \u2264 1.5 := by\n              interval_bound 10\n        \"\"\"\n        lines = []\n        lines.append(f\"-- Certificate hash: {self.hash()[:16]}...\")\n        lines.append(f\"-- Generated from: {self.operation}\")\n        lines.append(\"\")\n\n        if self.operation == 'find_bounds':\n            lines.extend(self._to_lean_find_bounds())\n        elif self.operation == 'verify_bound':\n            lines.extend(self._to_lean_verify_bound())\n        elif self.operation == 'find_roots':\n            lines.extend(self._to_lean_find_roots())\n        elif self.operation == 'integrate':\n            lines.extend(self._to_lean_integrate())\n        else:\n            lines.append(f\"-- Unknown operation: {self.operation}\")\n            lines.append(f\"-- Raw result: {self.result_json}\")\n\n        return '\\n'.join(lines)\n\n    def _to_lean_find_bounds(self) -&gt; list[str]:\n        \"\"\"Generate Lean code for find_bounds operation.\"\"\"\n        lines = []\n        expr_lean = self._expr_to_lean(self.expr_json)\n        min_lo = self.result_json.get('min', {}).get('lo', {})\n        min_hi = self.result_json.get('min', {}).get('hi', {})\n        max_lo = self.result_json.get('max', {}).get('lo', {})\n        max_hi = self.result_json.get('max', {}).get('hi', {})\n        taylor_depth = self.metadata.get('taylor_depth', 10)\n\n        is_multivariate = len(self.domain_json) &gt; 1\n\n        lines.append(f\"-- Expression: {expr_lean}\")\n        lines.append(f\"-- Domain: {self._domain_to_lean_comment(self.domain_json)}\")\n        lines.append(\"\")\n        # Show full intervals so users see both the proven bound and the tight estimate\n        # min_lo is the proven lower bound, min_hi is the tight upper estimate of the minimum\n        lines.append(f\"-- Min \u2208 [{self._rat_to_float(min_lo):.6f}, {self._rat_to_float(min_hi):.6f}]\")\n        lines.append(f\"-- Max \u2208 [{self._rat_to_float(max_lo):.6f}, {self._rat_to_float(max_hi):.6f}]\")\n        lines.append(\"\")\n        lines.append(\"theorem bounds_check :\")\n\n        if is_multivariate:\n            # Generate proper nested forall syntax for multivariate\n            quantifiers = self._domain_to_lean_quantifiers(self.domain_json)\n            lines.append(f\"    {quantifiers}\")\n            lines.append(f\"    {self._rat_to_float(min_lo):.6f} \u2264 {expr_lean} \u2227 {expr_lean} \u2264 {self._rat_to_float(max_hi):.6f} := by\")\n            lines.append(f\"  multivariate_bound\")\n        else:\n            domain_lean = self._domain_to_lean(self.domain_json)\n            lines.append(f\"    \u2200 x \u2208 {domain_lean}, {self._rat_to_float(min_lo):.6f} \u2264 {expr_lean} \u2227 {expr_lean} \u2264 {self._rat_to_float(max_hi):.6f} := by\")\n            lines.append(f\"  interval_bound {taylor_depth}\")\n\n        return lines\n\n    def _to_lean_verify_bound(self) -&gt; list[str]:\n        \"\"\"Generate Lean code for verify_bound operation.\"\"\"\n        lines = []\n        expr_lean = self._expr_to_lean(self.expr_json)\n        domain_lean = self._domain_to_lean(self.domain_json)\n        taylor_depth = self.metadata.get('taylor_depth', 10)\n\n        bound_type = self.result_json.get('bound_type', 'unknown')\n        bound_value = self.result_json.get('bound_value', 0)\n\n        lines.append(f\"-- Expression: {expr_lean}\")\n        lines.append(f\"-- Domain: {domain_lean}\")\n        lines.append(\"\")\n\n        if bound_type == 'upper':\n            lines.append(f\"theorem upper_bound_check : \u2200 x \u2208 {domain_lean}, {expr_lean} \u2264 {bound_value} := by\")\n        elif bound_type == 'lower':\n            lines.append(f\"theorem lower_bound_check : \u2200 x \u2208 {domain_lean}, {bound_value} \u2264 {expr_lean} := by\")\n        else:\n            lines.append(f\"theorem bound_check : \u2200 x \u2208 {domain_lean}, ... := by\")\n\n        lines.append(f\"  interval_bound {taylor_depth}\")\n\n        return lines\n\n    def _to_lean_find_roots(self) -&gt; list[str]:\n        \"\"\"Generate Lean code for find_roots operation.\"\"\"\n        lines = []\n        expr_lean = self._expr_to_lean(self.expr_json)\n\n        lines.append(f\"-- Expression: {expr_lean}\")\n        lines.append(\"-- Root existence verified via IVT (sign change)\")\n        lines.append(\"\")\n        lines.append(\"-- Roots found:\")\n\n        roots = self.result_json.get('roots', [])\n        for i, root in enumerate(roots):\n            lo = self._rat_to_float(root.get('lo', {}))\n            hi = self._rat_to_float(root.get('hi', {}))\n            status = root.get('status', 'unknown')\n            lines.append(f\"-- Root {i+1}: [{lo:.6f}, {hi:.6f}] (status: {status})\")\n\n        lines.append(\"\")\n        lines.append(\"-- To verify existence, use:\")\n        lines.append(\"-- theorem root_exists : \u2203 x \u2208 I, f x = 0 := by\")\n        lines.append(\"--   interval_root &lt;root_interval&gt;\")\n\n        return lines\n\n    def _to_lean_integrate(self) -&gt; list[str]:\n        \"\"\"Generate Lean code for integrate operation.\"\"\"\n        lines = []\n        expr_lean = self._expr_to_lean(self.expr_json)\n        lo = self.result_json.get('lo', {})\n        hi = self.result_json.get('hi', {})\n        taylor_depth = self.metadata.get('taylor_depth', 10)\n\n        lines.append(f\"-- Expression: {expr_lean}\")\n        lines.append(f\"-- Integral bounds: [{self._rat_to_float(lo):.6f}, {self._rat_to_float(hi):.6f}]\")\n        lines.append(\"\")\n        lines.append(f\"-- theorem integral_bound : \u222b x in I, {expr_lean} \u2208 bounds := by\")\n        lines.append(f\"--   interval_integrate {taylor_depth}\")\n\n        return lines\n\n    def _expr_to_lean(self, expr: dict) -&gt; str:\n        \"\"\"Convert expression JSON to Lean syntax (approximate).\"\"\"\n        kind = expr.get('kind', '')\n\n        if kind == 'const':\n            val = expr.get('val', {})\n            n, d = val.get('n', 0), val.get('d', 1)\n            if d == 1:\n                return str(n)\n            return f\"({n}/{d})\"\n        elif kind == 'var':\n            idx = expr.get('idx', 0)\n            return f\"x{idx}\" if idx &gt; 0 else \"x\"\n        elif kind == 'add':\n            e1 = self._expr_to_lean(expr.get('e1', {}))\n            e2 = self._expr_to_lean(expr.get('e2', {}))\n            return f\"({e1} + {e2})\"\n        elif kind == 'mul':\n            e1 = self._expr_to_lean(expr.get('e1', {}))\n            e2 = self._expr_to_lean(expr.get('e2', {}))\n            return f\"({e1} * {e2})\"\n        elif kind == 'neg':\n            e = self._expr_to_lean(expr.get('e', {}))\n            return f\"(-{e})\"\n        elif kind == 'div':\n            e1 = self._expr_to_lean(expr.get('e1', {}))\n            e2 = self._expr_to_lean(expr.get('e2', {}))\n            return f\"({e1} / {e2})\"\n        elif kind == 'pow':\n            base = self._expr_to_lean(expr.get('base', {}))\n            exp = expr.get('exp', 0)\n            return f\"({base}^{exp})\"\n        elif kind in ('sin', 'cos', 'exp', 'log', 'sqrt', 'tan', 'atan', 'inv', 'arsinh', 'atanh', 'sinc', 'erf'):\n            e = self._expr_to_lean(expr.get('e', {}))\n            return f\"Real.{kind} {e}\"\n        else:\n            return f\"&lt;{kind}?&gt;\"\n\n    def _domain_to_lean(self, domain: list) -&gt; str:\n        \"\"\"Convert domain JSON to Lean syntax for single variable.\"\"\"\n        if len(domain) == 1:\n            lo = self._rat_to_float(domain[0].get('lo', {}))\n            hi = self._rat_to_float(domain[0].get('hi', {}))\n            return f\"Set.Icc {lo} {hi}\"\n        else:\n            # For multivariate, use first interval (caller should use _domain_to_lean_quantifiers)\n            lo = self._rat_to_float(domain[0].get('lo', {}))\n            hi = self._rat_to_float(domain[0].get('hi', {}))\n            return f\"Set.Icc {lo} {hi}\"\n\n    def _domain_to_lean_comment(self, domain: list) -&gt; str:\n        \"\"\"Convert domain JSON to human-readable comment format.\"\"\"\n        if len(domain) == 1:\n            lo = self._rat_to_float(domain[0].get('lo', {}))\n            hi = self._rat_to_float(domain[0].get('hi', {}))\n            return f\"Set.Icc {lo} {hi}\"\n        else:\n            intervals = []\n            var_names = self._get_var_names(len(domain))\n            for i, d in enumerate(domain):\n                lo = self._rat_to_float(d.get('lo', {}))\n                hi = self._rat_to_float(d.get('hi', {}))\n                intervals.append(f\"{var_names[i]} \u2208 [{lo}, {hi}]\")\n            return \" \u00d7 \".join(intervals)\n\n    def _domain_to_lean_quantifiers(self, domain: list) -&gt; str:\n        \"\"\"Convert domain JSON to nested forall quantifiers for Lean.\"\"\"\n        var_names = self._get_var_names(len(domain))\n        parts = []\n        for i, d in enumerate(domain):\n            lo = self._rat_to_float(d.get('lo', {}))\n            hi = self._rat_to_float(d.get('hi', {}))\n            parts.append(f\"\u2200 {var_names[i]} \u2208 Set.Icc {lo} {hi},\")\n        return \" \".join(parts)\n\n    def _get_var_names(self, count: int) -&gt; list[str]:\n        \"\"\"Get variable names for the given count.\"\"\"\n        if count == 1:\n            return ['x']\n        elif count == 2:\n            return ['x', 'y']\n        elif count == 3:\n            return ['x', 'y', 'z']\n        else:\n            return [f'x{i}' for i in range(count)]\n\n    def _rat_to_float(self, rat: dict) -&gt; float:\n        \"\"\"Convert rational JSON to float.\"\"\"\n        n = rat.get('n', 0)\n        d = rat.get('d', 1)\n        return n / d if d != 0 else 0.0\n\n    def __repr__(self) -&gt; str:\n        status = \"verified\" if self.verified else \"unverified\"\n        return f\"Certificate({self.operation}, {status}, hash={self.hash()[:8]}...)\"\n</code></pre>"},{"location":"api/types/#leancert.result.Certificate.to_lean_tactic","title":"<code>to_lean_tactic()</code>","text":"<p>Generate Lean tactic code that reproduces the verified proof.</p> <p>Returns a string of Lean code that can be pasted into a Lean file. This provides the \"round trip\" - Python finds the certificate, then generates Lean code that verifies it.</p> Example output for find_bounds <p>theorem bound_check : \u2200 x \u2208 Set.Icc 0 1, x^2 \u2264 1 := by   interval_bound 10</p> Example output for verify_bound <p>theorem upper_bound_check : \u2200 x \u2208 I, f x \u2264 1.5 := by   interval_bound 10</p> Source code in <code>python/leancert/result.py</code> <pre><code>def to_lean_tactic(self) -&gt; str:\n    \"\"\"\n    Generate Lean tactic code that reproduces the verified proof.\n\n    Returns a string of Lean code that can be pasted into a Lean file.\n    This provides the \"round trip\" - Python finds the certificate,\n    then generates Lean code that verifies it.\n\n    Example output for find_bounds:\n        theorem bound_check : \u2200 x \u2208 Set.Icc 0 1, x^2 \u2264 1 := by\n          interval_bound 10\n\n    Example output for verify_bound:\n        theorem upper_bound_check : \u2200 x \u2208 I, f x \u2264 1.5 := by\n          interval_bound 10\n    \"\"\"\n    lines = []\n    lines.append(f\"-- Certificate hash: {self.hash()[:16]}...\")\n    lines.append(f\"-- Generated from: {self.operation}\")\n    lines.append(\"\")\n\n    if self.operation == 'find_bounds':\n        lines.extend(self._to_lean_find_bounds())\n    elif self.operation == 'verify_bound':\n        lines.extend(self._to_lean_verify_bound())\n    elif self.operation == 'find_roots':\n        lines.extend(self._to_lean_find_roots())\n    elif self.operation == 'integrate':\n        lines.extend(self._to_lean_integrate())\n    else:\n        lines.append(f\"-- Unknown operation: {self.operation}\")\n        lines.append(f\"-- Raw result: {self.result_json}\")\n\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"api/types/#leancert.result.Certificate.save","title":"<code>save(path)</code>","text":"<p>Save certificate to a JSON file.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def save(self, path: str) -&gt; None:\n    \"\"\"Save certificate to a JSON file.\"\"\"\n    with open(path, 'w') as f:\n        json.dump(self.to_dict(), f, indent=2)\n</code></pre>"},{"location":"api/types/#leancert.result.Certificate.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>Load certificate from a JSON file.</p> Source code in <code>python/leancert/result.py</code> <pre><code>@classmethod\ndef load(cls, path: str) -&gt; Certificate:\n    \"\"\"Load certificate from a JSON file.\"\"\"\n    with open(path) as f:\n        data = json.load(f)\n\n    return cls(\n        operation=data['operation'],\n        expr_json=data['expr'],\n        domain_json=data['domain'],\n        result_json=data['result'],\n        verified=data['verified'],\n        lean_version=data['lean_version'],\n        leancert_version=data['leancert_version'],\n        computation_time_ms=data.get('computation_time_ms'),\n        metadata=data.get('metadata', {}),\n    )\n</code></pre>"},{"location":"api/types/#verifyresult","title":"VerifyResult","text":"<p>Returned by <code>verify_bound()</code>.</p>"},{"location":"api/types/#leancert.result.VerifyResult","title":"<code>leancert.result.VerifyResult</code>  <code>dataclass</code>","text":"<p>Result of bound verification.</p> <p>Indicates whether a claimed bound was verified.</p> Access Patterns <p>result.verified         # bool - True if bound verified result.computed_bound   # Interval object with actual computed bound result.lo               # float lower bound of computed interval result.hi               # float upper bound of computed interval result.value            # float midpoint of computed interval</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass VerifyResult:\n    \"\"\"\n    Result of bound verification.\n\n    Indicates whether a claimed bound was verified.\n\n    Access Patterns:\n        result.verified         # bool - True if bound verified\n        result.computed_bound   # Interval object with actual computed bound\n        result.lo               # float lower bound of computed interval\n        result.hi               # float upper bound of computed interval\n        result.value            # float midpoint of computed interval\n    \"\"\"\n    verified: bool\n    computed_bound: Interval\n    certificate: Optional[Certificate] = None\n\n    @property\n    def lo(self) -&gt; float:\n        \"\"\"Lower bound of computed interval.\"\"\"\n        return float(self.computed_bound.lo)\n\n    @property\n    def hi(self) -&gt; float:\n        \"\"\"Upper bound of computed interval.\"\"\"\n        return float(self.computed_bound.hi)\n\n    @property\n    def value(self) -&gt; float:\n        \"\"\"Midpoint of computed interval.\"\"\"\n        return float(self.computed_bound.midpoint())\n\n    def __repr__(self) -&gt; str:\n        status = \"VERIFIED\" if self.verified else \"FAILED\"\n        return f\"VerifyResult({status}, computed={self.computed_bound})\"\n</code></pre>"},{"location":"api/types/#leancert.result.VerifyResult.hi","title":"<code>hi</code>  <code>property</code>","text":"<p>Upper bound of computed interval.</p>"},{"location":"api/types/#leancert.result.VerifyResult.lo","title":"<code>lo</code>  <code>property</code>","text":"<p>Lower bound of computed interval.</p>"},{"location":"api/types/#leancert.result.VerifyResult.value","title":"<code>value</code>  <code>property</code>","text":"<p>Midpoint of computed interval.</p>"},{"location":"api/types/#witness-synthesis-results","title":"Witness Synthesis Results","text":"<p>These types support auto-witness synthesis for existential proof goals.</p>"},{"location":"api/types/#witnesspoint","title":"WitnessPoint","text":"<p>A concrete witness point with variable values and function value.</p>"},{"location":"api/types/#leancert.result.WitnessPoint","title":"<code>leancert.result.WitnessPoint</code>  <code>dataclass</code>","text":"<p>A concrete witness point with variable values and function value.</p> <p>This represents a specific point in the domain along with the function value at that point. Used for existential proofs where we need to exhibit a concrete witness.</p> <p>Attributes:</p> Name Type Description <code>values</code> <code>dict[str, Fraction]</code> <p>Dictionary mapping variable names to their witness values (exact Fractions)</p> <code>function_value</code> <code>Fraction</code> <p>The function value at the witness point (exact Fraction)</p> <code>interval</code> <code>dict[str, tuple[Fraction, Fraction]]</code> <p>Dictionary mapping variable names to (lo, hi) tuples representing       the enclosing interval from which this witness was derived</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass WitnessPoint:\n    \"\"\"\n    A concrete witness point with variable values and function value.\n\n    This represents a specific point in the domain along with the function\n    value at that point. Used for existential proofs where we need to\n    exhibit a concrete witness.\n\n    Attributes:\n        values: Dictionary mapping variable names to their witness values (exact Fractions)\n        function_value: The function value at the witness point (exact Fraction)\n        interval: Dictionary mapping variable names to (lo, hi) tuples representing\n                  the enclosing interval from which this witness was derived\n    \"\"\"\n    values: dict[str, Fraction]\n    function_value: Fraction\n    interval: dict[str, tuple[Fraction, Fraction]]\n\n    def value_at(self, var_name: str) -&gt; float:\n        \"\"\"Get the float value of a variable at this witness point.\"\"\"\n        return float(self.values.get(var_name, 0))\n\n    @property\n    def function_value_float(self) -&gt; float:\n        \"\"\"Get the function value as a float.\"\"\"\n        return float(self.function_value)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert to JSON-serializable dictionary.\"\"\"\n        return {\n            'values': {k: {'n': v.numerator, 'd': v.denominator} for k, v in self.values.items()},\n            'function_value': {'n': self.function_value.numerator, 'd': self.function_value.denominator},\n            'interval': {\n                k: {'lo': {'n': lo.numerator, 'd': lo.denominator},\n                    'hi': {'n': hi.numerator, 'd': hi.denominator}}\n                for k, (lo, hi) in self.interval.items()\n            },\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; 'WitnessPoint':\n        \"\"\"Create from JSON dictionary.\"\"\"\n        values = {k: Fraction(v['n'], v['d']) for k, v in data['values'].items()}\n        function_value = Fraction(data['function_value']['n'], data['function_value']['d'])\n        interval = {\n            k: (Fraction(v['lo']['n'], v['lo']['d']), Fraction(v['hi']['n'], v['hi']['d']))\n            for k, v in data['interval'].items()\n        }\n        return cls(values=values, function_value=function_value, interval=interval)\n\n    def __repr__(self) -&gt; str:\n        vals = ', '.join(f'{k}={float(v):.6f}' for k, v in self.values.items())\n        return f\"WitnessPoint({vals}, f={self.function_value_float:.6f})\"\n</code></pre>"},{"location":"api/types/#leancert.result.WitnessPoint.function_value_float","title":"<code>function_value_float</code>  <code>property</code>","text":"<p>Get the function value as a float.</p>"},{"location":"api/types/#leancert.result.WitnessPoint.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create from JSON dictionary.</p> Source code in <code>python/leancert/result.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; 'WitnessPoint':\n    \"\"\"Create from JSON dictionary.\"\"\"\n    values = {k: Fraction(v['n'], v['d']) for k, v in data['values'].items()}\n    function_value = Fraction(data['function_value']['n'], data['function_value']['d'])\n    interval = {\n        k: (Fraction(v['lo']['n'], v['lo']['d']), Fraction(v['hi']['n'], v['hi']['d']))\n        for k, v in data['interval'].items()\n    }\n    return cls(values=values, function_value=function_value, interval=interval)\n</code></pre>"},{"location":"api/types/#leancert.result.WitnessPoint.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to JSON-serializable dictionary.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to JSON-serializable dictionary.\"\"\"\n    return {\n        'values': {k: {'n': v.numerator, 'd': v.denominator} for k, v in self.values.items()},\n        'function_value': {'n': self.function_value.numerator, 'd': self.function_value.denominator},\n        'interval': {\n            k: {'lo': {'n': lo.numerator, 'd': lo.denominator},\n                'hi': {'n': hi.numerator, 'd': hi.denominator}}\n            for k, (lo, hi) in self.interval.items()\n        },\n    }\n</code></pre>"},{"location":"api/types/#leancert.result.WitnessPoint.value_at","title":"<code>value_at(var_name)</code>","text":"<p>Get the float value of a variable at this witness point.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def value_at(self, var_name: str) -&gt; float:\n    \"\"\"Get the float value of a variable at this witness point.\"\"\"\n    return float(self.values.get(var_name, 0))\n</code></pre>"},{"location":"api/types/#minwitnessresult","title":"MinWitnessResult","text":"<p>Returned by <code>synthesize_min_witness()</code>. Proves: <code>\u2203 m, \u2200 x \u2208 I, f(x) \u2265 m</code></p>"},{"location":"api/types/#leancert.result.MinWitnessResult","title":"<code>leancert.result.MinWitnessResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>WitnessResult</code></p> <p>Result of synthesizing a minimum witness.</p> <p>Proves: \u2203 m, \u2200 x \u2208 I, f(x) \u2265 m</p> <p>Attributes:</p> Name Type Description <code>witness_value</code> <code>Fraction</code> <p>The witness value m (exact Fraction)</p> <code>witness_point</code> <code>Optional[WitnessPoint]</code> <p>The point where the minimum is achieved</p> <code>proven_bound</code> <code>Fraction</code> <p>The rigorous lower bound from interval arithmetic</p> <code>verified</code> <code>bool</code> <p>Whether the witness was verified</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass MinWitnessResult(WitnessResult):\n    \"\"\"\n    Result of synthesizing a minimum witness.\n\n    Proves: \u2203 m, \u2200 x \u2208 I, f(x) \u2265 m\n\n    Attributes:\n        witness_value: The witness value m (exact Fraction)\n        witness_point: The point where the minimum is achieved\n        proven_bound: The rigorous lower bound from interval arithmetic\n        verified: Whether the witness was verified\n    \"\"\"\n    witness_value: Fraction = field(default_factory=lambda: Fraction(0))\n    witness_point: Optional[WitnessPoint] = None\n    proven_bound: Fraction = field(default_factory=lambda: Fraction(0))\n\n    def to_lean_tactic(self) -&gt; str:\n        \"\"\"Generate Lean tactic code for this minimum witness proof.\"\"\"\n        lines = []\n        lines.append(\"-- Auto-synthesized minimum witness\")\n        lines.append(f\"-- Witness value: {float(self.witness_value):.10f}\")\n        if self.witness_point:\n            vals = ', '.join(f'{k} = {float(v):.6f}' for k, v in self.witness_point.values.items())\n            lines.append(f\"-- Achieved at: {vals}\")\n        lines.append(f\"-- Proven bound: {float(self.proven_bound):.10f}\")\n        lines.append(\"\")\n        lines.append(\"-- Proof: \u2203 m, \u2200 x \u2208 I, f(x) \u2265 m\")\n        lines.append(f\"use {self._fraction_to_lean(self.witness_value)}\")\n        lines.append(\"intro x hx\")\n        lines.append(\"interval_min_witness\")\n        return '\\n'.join(lines)\n\n    def _fraction_to_lean(self, f: Fraction) -&gt; str:\n        \"\"\"Convert fraction to Lean rational literal.\"\"\"\n        if f.denominator == 1:\n            return str(f.numerator)\n        return f\"({f.numerator} / {f.denominator})\"\n\n    def __repr__(self) -&gt; str:\n        status = \"VERIFIED\" if self.verified else \"UNVERIFIED\"\n        return f\"MinWitnessResult({status}, m={float(self.witness_value):.6f})\"\n</code></pre>"},{"location":"api/types/#leancert.result.MinWitnessResult.to_lean_tactic","title":"<code>to_lean_tactic()</code>","text":"<p>Generate Lean tactic code for this minimum witness proof.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def to_lean_tactic(self) -&gt; str:\n    \"\"\"Generate Lean tactic code for this minimum witness proof.\"\"\"\n    lines = []\n    lines.append(\"-- Auto-synthesized minimum witness\")\n    lines.append(f\"-- Witness value: {float(self.witness_value):.10f}\")\n    if self.witness_point:\n        vals = ', '.join(f'{k} = {float(v):.6f}' for k, v in self.witness_point.values.items())\n        lines.append(f\"-- Achieved at: {vals}\")\n    lines.append(f\"-- Proven bound: {float(self.proven_bound):.10f}\")\n    lines.append(\"\")\n    lines.append(\"-- Proof: \u2203 m, \u2200 x \u2208 I, f(x) \u2265 m\")\n    lines.append(f\"use {self._fraction_to_lean(self.witness_value)}\")\n    lines.append(\"intro x hx\")\n    lines.append(\"interval_min_witness\")\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"api/types/#maxwitnessresult","title":"MaxWitnessResult","text":"<p>Returned by <code>synthesize_max_witness()</code>. Proves: <code>\u2203 M, \u2200 x \u2208 I, f(x) \u2264 M</code></p>"},{"location":"api/types/#leancert.result.MaxWitnessResult","title":"<code>leancert.result.MaxWitnessResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>WitnessResult</code></p> <p>Result of synthesizing a maximum witness.</p> <p>Proves: \u2203 M, \u2200 x \u2208 I, f(x) \u2264 M</p> <p>Attributes:</p> Name Type Description <code>witness_value</code> <code>Fraction</code> <p>The witness value M (exact Fraction)</p> <code>witness_point</code> <code>Optional[WitnessPoint]</code> <p>The point where the maximum is achieved</p> <code>proven_bound</code> <code>Fraction</code> <p>The rigorous upper bound from interval arithmetic</p> <code>verified</code> <code>bool</code> <p>Whether the witness was verified</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass MaxWitnessResult(WitnessResult):\n    \"\"\"\n    Result of synthesizing a maximum witness.\n\n    Proves: \u2203 M, \u2200 x \u2208 I, f(x) \u2264 M\n\n    Attributes:\n        witness_value: The witness value M (exact Fraction)\n        witness_point: The point where the maximum is achieved\n        proven_bound: The rigorous upper bound from interval arithmetic\n        verified: Whether the witness was verified\n    \"\"\"\n    witness_value: Fraction = field(default_factory=lambda: Fraction(0))\n    witness_point: Optional[WitnessPoint] = None\n    proven_bound: Fraction = field(default_factory=lambda: Fraction(0))\n\n    def to_lean_tactic(self) -&gt; str:\n        \"\"\"Generate Lean tactic code for this maximum witness proof.\"\"\"\n        lines = []\n        lines.append(\"-- Auto-synthesized maximum witness\")\n        lines.append(f\"-- Witness value: {float(self.witness_value):.10f}\")\n        if self.witness_point:\n            vals = ', '.join(f'{k} = {float(v):.6f}' for k, v in self.witness_point.values.items())\n            lines.append(f\"-- Achieved at: {vals}\")\n        lines.append(f\"-- Proven bound: {float(self.proven_bound):.10f}\")\n        lines.append(\"\")\n        lines.append(\"-- Proof: \u2203 M, \u2200 x \u2208 I, f(x) \u2264 M\")\n        lines.append(f\"use {self._fraction_to_lean(self.witness_value)}\")\n        lines.append(\"intro x hx\")\n        lines.append(\"interval_max_witness\")\n        return '\\n'.join(lines)\n\n    def _fraction_to_lean(self, f: Fraction) -&gt; str:\n        \"\"\"Convert fraction to Lean rational literal.\"\"\"\n        if f.denominator == 1:\n            return str(f.numerator)\n        return f\"({f.numerator} / {f.denominator})\"\n\n    def __repr__(self) -&gt; str:\n        status = \"VERIFIED\" if self.verified else \"UNVERIFIED\"\n        return f\"MaxWitnessResult({status}, M={float(self.witness_value):.6f})\"\n</code></pre>"},{"location":"api/types/#leancert.result.MaxWitnessResult.to_lean_tactic","title":"<code>to_lean_tactic()</code>","text":"<p>Generate Lean tactic code for this maximum witness proof.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def to_lean_tactic(self) -&gt; str:\n    \"\"\"Generate Lean tactic code for this maximum witness proof.\"\"\"\n    lines = []\n    lines.append(\"-- Auto-synthesized maximum witness\")\n    lines.append(f\"-- Witness value: {float(self.witness_value):.10f}\")\n    if self.witness_point:\n        vals = ', '.join(f'{k} = {float(v):.6f}' for k, v in self.witness_point.values.items())\n        lines.append(f\"-- Achieved at: {vals}\")\n    lines.append(f\"-- Proven bound: {float(self.proven_bound):.10f}\")\n    lines.append(\"\")\n    lines.append(\"-- Proof: \u2203 M, \u2200 x \u2208 I, f(x) \u2264 M\")\n    lines.append(f\"use {self._fraction_to_lean(self.witness_value)}\")\n    lines.append(\"intro x hx\")\n    lines.append(\"interval_max_witness\")\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"api/types/#rootwitnessresult","title":"RootWitnessResult","text":"<p>Returned by <code>synthesize_root_witness()</code>. Proves: <code>\u2203 x \u2208 I, f(x) = 0</code></p>"},{"location":"api/types/#leancert.result.RootWitnessResult","title":"<code>leancert.result.RootWitnessResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>WitnessResult</code></p> <p>Result of synthesizing a root witness.</p> <p>Proves: \u2203 x \u2208 I, f(x) = 0</p> <p>Attributes:</p> Name Type Description <code>witness_point</code> <code>Optional[WitnessPoint]</code> <p>The point where f(x) \u2248 0</p> <code>root_interval</code> <code>Optional[Interval]</code> <p>The interval guaranteed to contain the root</p> <code>verified</code> <code>bool</code> <p>Whether the witness was verified (via sign change or Newton)</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass RootWitnessResult(WitnessResult):\n    \"\"\"\n    Result of synthesizing a root witness.\n\n    Proves: \u2203 x \u2208 I, f(x) = 0\n\n    Attributes:\n        witness_point: The point where f(x) \u2248 0\n        root_interval: The interval guaranteed to contain the root\n        verified: Whether the witness was verified (via sign change or Newton)\n    \"\"\"\n    witness_point: Optional[WitnessPoint] = None\n    root_interval: Optional[Interval] = None\n    proof_method: str = 'sign_change'  # 'sign_change' or 'newton_contraction'\n\n    def to_lean_tactic(self) -&gt; str:\n        \"\"\"Generate Lean tactic code for this root witness proof.\"\"\"\n        lines = []\n        lines.append(\"-- Auto-synthesized root witness\")\n        if self.witness_point:\n            vals = ', '.join(f'{k} = {float(v):.6f}' for k, v in self.witness_point.values.items())\n            lines.append(f\"-- Witness point: {vals}\")\n        if self.root_interval:\n            lines.append(f\"-- Root interval: [{float(self.root_interval.lo):.10f}, {float(self.root_interval.hi):.10f}]\")\n        lines.append(f\"-- Proof method: {self.proof_method}\")\n        lines.append(\"\")\n        lines.append(\"-- Proof: \u2203 x \u2208 I, f(x) = 0\")\n        lines.append(\"interval_root_witness\")\n        return '\\n'.join(lines)\n\n    def __repr__(self) -&gt; str:\n        status = \"VERIFIED\" if self.verified else \"UNVERIFIED\"\n        if self.witness_point:\n            x_val = list(self.witness_point.values.values())[0] if self.witness_point.values else 0\n            return f\"RootWitnessResult({status}, x\u2248{float(x_val):.6f})\"\n        return f\"RootWitnessResult({status})\"\n</code></pre>"},{"location":"api/types/#leancert.result.RootWitnessResult.to_lean_tactic","title":"<code>to_lean_tactic()</code>","text":"<p>Generate Lean tactic code for this root witness proof.</p> Source code in <code>python/leancert/result.py</code> <pre><code>def to_lean_tactic(self) -&gt; str:\n    \"\"\"Generate Lean tactic code for this root witness proof.\"\"\"\n    lines = []\n    lines.append(\"-- Auto-synthesized root witness\")\n    if self.witness_point:\n        vals = ', '.join(f'{k} = {float(v):.6f}' for k, v in self.witness_point.values.items())\n        lines.append(f\"-- Witness point: {vals}\")\n    if self.root_interval:\n        lines.append(f\"-- Root interval: [{float(self.root_interval.lo):.10f}, {float(self.root_interval.hi):.10f}]\")\n    lines.append(f\"-- Proof method: {self.proof_method}\")\n    lines.append(\"\")\n    lines.append(\"-- Proof: \u2203 x \u2208 I, f(x) = 0\")\n    lines.append(\"interval_root_witness\")\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"api/types/#failurediagnosis","title":"FailureDiagnosis","text":"<p>Returned by <code>diagnose_bound_failure()</code>. Used for CEGPR support.</p>"},{"location":"api/types/#leancert.result.FailureDiagnosis","title":"<code>leancert.result.FailureDiagnosis</code>  <code>dataclass</code>","text":"<p>Diagnosis of why a bound verification failed.</p> <p>Used for Counterexample-Guided Proof Refinement (CEGPR).</p> <p>Attributes:</p> Name Type Description <code>failure_type</code> <code>str</code> <p>Type of failure ('bound_too_tight', 'no_root', etc.)</p> <code>margin</code> <code>float</code> <p>How much the bound was missed by (negative = violated)</p> <code>worst_point</code> <code>dict[str, float]</code> <p>Dictionary of variable values at the worst point</p> <code>suggested_bound</code> <code>float</code> <p>A suggested bound that would succeed</p> Source code in <code>python/leancert/result.py</code> <pre><code>@dataclass\nclass FailureDiagnosis:\n    \"\"\"\n    Diagnosis of why a bound verification failed.\n\n    Used for Counterexample-Guided Proof Refinement (CEGPR).\n\n    Attributes:\n        failure_type: Type of failure ('bound_too_tight', 'no_root', etc.)\n        margin: How much the bound was missed by (negative = violated)\n        worst_point: Dictionary of variable values at the worst point\n        suggested_bound: A suggested bound that would succeed\n    \"\"\"\n    failure_type: str\n    margin: float\n    worst_point: dict[str, float]\n    suggested_bound: float\n\n    def __repr__(self) -&gt; str:\n        return f\"FailureDiagnosis({self.failure_type}, margin={self.margin:.6f}, suggested={self.suggested_bound:.6f})\"\n</code></pre>"},{"location":"api/types/#discovery-results-lean","title":"Discovery Results (Lean)","text":"<p>The Lean side provides structured result types for discovery operations.</p>"},{"location":"api/types/#verifiedglobalmin","title":"VerifiedGlobalMin","text":"<p>Contains the lower bound, the box where it was found, and the formal proof.</p> <pre><code>structure VerifiedGlobalMin where\n  lowerBound : \u211a\n  achievingBox : Box\n  proof : \u2200 x \u2208 domain, f x \u2265 lowerBound\n</code></pre>"},{"location":"api/types/#verifiedroot","title":"VerifiedRoot","text":"<p>Contains an isolating interval for a root and the proof of existence (via sign change/IVT).</p> <pre><code>structure VerifiedRoot where\n  interval : IntervalRat\n  proof : \u2203 x \u2208 interval, f x = 0\n</code></pre>"},{"location":"api/types/#verifiedequivalence","title":"VerifiedEquivalence","text":"<p>Contains the certificate that two neural networks produce outputs within a specific tolerance \u03b5.</p> <pre><code>structure VerifiedEquivalence where\n  tolerance : \u211a\n  proof : \u2200 x \u2208 domain, |teacher x - student x| \u2264 tolerance\n</code></pre>"},{"location":"architecture/golden-theorems/","title":"Golden Theorems","text":"<p>LeanCert operates on a certificate-driven architecture. The Python side discovers facts, and the Lean side verifies them using Golden Theorems.</p>"},{"location":"architecture/golden-theorems/#concept","title":"Concept","text":"<p>A Golden Theorem bridges the gap between a computable boolean check (which <code>native_decide</code> can run) and a semantic proposition about real numbers.</p> <p>For example, to prove \\(f(x) \\le c\\) for all \\(x \\in I\\), we use:</p> \\[ \\text{checkUpperBound}(e, I, c) = \\text{true} \\implies \\forall x \\in I,\\ \\text{eval}(x, e) \\le c \\] <p>The key insight is that the checker runs in the Lean kernel using computable rational arithmetic, while the conclusion is a statement about real numbers.</p>"},{"location":"architecture/golden-theorems/#core-theorems","title":"Core Theorems","text":"<p>Golden Theorems are defined across multiple files: - <code>Validity/Bounds.lean</code> - Rational arithmetic (default) - <code>Validity/DyadicBounds.lean</code> - Dyadic arithmetic (fast) - <code>Validity/AffineBounds.lean</code> - Affine arithmetic (tight bounds) - <code>Validity/Monotonicity.lean</code> - Monotonicity via automatic differentiation</p>"},{"location":"architecture/golden-theorems/#bound-verification","title":"Bound Verification","text":"Goal Theorem Checker Upper bound \\(f(x) \\le c\\) <code>verify_upper_bound</code> <code>checkUpperBound</code> Lower bound \\(c \\le f(x)\\) <code>verify_lower_bound</code> <code>checkLowerBound</code> Strict upper \\(f(x) &lt; c\\) <code>verify_strict_upper_bound</code> <code>checkStrictUpperBound</code> Strict lower \\(c &lt; f(x)\\) <code>verify_strict_lower_bound</code> <code>checkStrictLowerBound</code> <pre><code>theorem verify_upper_bound (e : Expr) (hsupp : ExprSupportedCore e)\n    (I : IntervalRat) (c : \u211a) (cfg : EvalConfig)\n    (h_cert : checkUpperBound e I c cfg = true) :\n    \u2200 x \u2208 I, Expr.eval (fun _ =&gt; x) e \u2264 c\n</code></pre>"},{"location":"architecture/golden-theorems/#root-finding","title":"Root Finding","text":"Goal Theorem Checker Root existence <code>verify_sign_change</code> <code>checkSignChange</code> Root uniqueness <code>verify_unique_root_computable</code> <code>checkNewtonContractsCore</code> No roots <code>verify_no_root</code> <code>checkNoRoot</code> <pre><code>theorem verify_sign_change (e : Expr) (hsupp : ExprSupportedCore e)\n    (I : IntervalRat) (cfg : EvalConfig)\n    (hCont : ContinuousOn (fun x =&gt; Expr.eval (fun _ =&gt; x) e) (Set.Icc I.lo I.hi))\n    (h_cert : checkSignChange e I cfg = true) :\n    \u2203 x \u2208 I, Expr.eval (fun _ =&gt; x) e = 0\n</code></pre>"},{"location":"architecture/golden-theorems/#global-optimization","title":"Global Optimization","text":"Goal Theorem Checker Global lower bound <code>verify_global_lower_bound</code> <code>checkGlobalLowerBound</code> Global upper bound <code>verify_global_upper_bound</code> <code>checkGlobalUpperBound</code> <pre><code>theorem verify_global_lower_bound (e : Expr) (hsupp : ExprSupported e)\n    (B : Box) (c : \u211a) (cfg : GlobalOptConfig)\n    (h_cert : checkGlobalLowerBound e B c cfg = true) :\n    \u2200 (\u03c1 : Nat \u2192 \u211d), Box.envMem \u03c1 B \u2192 (\u2200 i, i \u2265 B.length \u2192 \u03c1 i = 0) \u2192\n      c \u2264 Expr.eval \u03c1 e\n</code></pre> <p>Note: Global optimization uses <code>ExprSupported</code> (not <code>ExprSupportedCore</code>) and multivariate environments.</p>"},{"location":"architecture/golden-theorems/#integration","title":"Integration","text":"<p>Rational backend:</p> <pre><code>theorem verify_integral_bound (e : Expr) (hsupp : ExprSupportedCore e)\n    (I : IntervalRat) (target : \u211a) (cfg : EvalConfig)\n    (h_cert : checkIntegralBoundsCore e I target cfg = true)\n    (hcontdom : exprContinuousDomainValid e (Set.Icc I.lo I.hi)) :\n    \u222b x in I.lo..I.hi, Expr.eval (fun _ =&gt; x) e \u2208 integrateInterval1Core e I cfg\n</code></pre> <p>Dyadic backend (for complex integrands like Li\u2082 where rational arithmetic explodes):</p> <pre><code>theorem integrateInterval1Dyadic_correct (e : Expr) (hsupp : ExprSupportedWithInv e)\n    (I : IntervalRat) (cfg : DyadicConfig)\n    (hprec : cfg.precision \u2264 0)\n    (hdom : evalDomainValidDyadic e (fun _ =&gt; IntervalDyadic.ofIntervalRat I cfg.precision) cfg)\n    (hInt : IntervalIntegrable (fun x =&gt; Expr.eval (fun _ =&gt; x) e) volume I.lo I.hi) :\n    \u222b x in (I.lo : \u211d)..(I.hi : \u211d), Expr.eval (fun _ =&gt; x) e \u2208\n      integrateInterval1Dyadic e I cfg\n</code></pre> <p>The dyadic integration path supports <code>ExprSupportedWithInv</code> (including <code>inv</code>, <code>log</code>, <code>atanh</code>) and uses <code>evalIntervalDyadic</code> which is total \u2014 domain violations produce wide bounds that safely cause the checker to return <code>false</code>.</p> <pre><code>theorem integratePartitionDyadic_correct (e : Expr) (hsupp : ExprSupportedWithInv e)\n    (I : IntervalRat) (n : \u2115) (hn : 0 &lt; n) (cfg : DyadicConfig)\n    (hprec : cfg.precision \u2264 0)\n    (hdom : \u2200 k (hk : k &lt; n), evalDomainValidDyadic e ...)\n    (hInt : IntervalIntegrable ...) :\n    \u222b x in (I.lo : \u211d)..(I.hi : \u211d), Expr.eval (fun _ =&gt; x) e \u2208\n      integratePartitionDyadic e I n hn cfg\n</code></pre>"},{"location":"architecture/golden-theorems/#monotonicity","title":"Monotonicity","text":"<p>Prove monotonicity properties using automatic differentiation with interval arithmetic.</p> Goal Theorem Checker Strictly increasing <code>verify_strictly_increasing</code> <code>checkStrictlyIncreasing</code> Strictly decreasing <code>verify_strictly_decreasing</code> <code>checkStrictlyDecreasing</code> Monotone (weak) <code>verify_monotone</code> <code>checkStrictlyIncreasing</code> Antitone (weak) <code>verify_antitone</code> <code>checkStrictlyDecreasing</code> <pre><code>theorem verify_strictly_increasing (e : Expr) (hsupp : ExprSupported e)\n    (I : IntervalRat) (cfg : EvalConfig)\n    (h_check : checkStrictlyIncreasing e I cfg = true) :\n    StrictMonoOn (fun x =&gt; Expr.eval (fun _ =&gt; x) e) (Set.Icc I.lo I.hi)\n</code></pre> <p>The approach uses automatic differentiation to compute interval bounds on derivatives: 1. Compute <code>dI := derivIntervalCore e I cfg</code> (interval containing all derivatives) 2. If <code>dI.lo &gt; 0</code>, then f'(x) &gt; 0 for all x \u2208 I, so f is strictly increasing 3. If <code>dI.hi &lt; 0</code>, then f'(x) &lt; 0 for all x \u2208 I, so f is strictly decreasing</p> <p>The mathematical foundation is the Mean Value Theorem: if f' has consistent sign, then f is monotonic.</p> <p>Example: <pre><code>-- Prove exp is strictly increasing on [0, 1]\ntheorem exp_strictly_increasing :\n    StrictMonoOn (fun x =&gt; Real.exp x) (Set.Icc 0 1) := by\n  have h := verify_strictly_increasing (Expr.exp (Expr.var 0))\n    (ExprSupported.exp (ExprSupported.var 0))\n    \u27e80, 1, by norm_num\u27e9 {} (by native_decide)\n  simp only [Expr.eval_exp, Expr.eval_var] at h\n  convert h using 2 &lt;;&gt; simp\n</code></pre></p>"},{"location":"architecture/golden-theorems/#expression-support-tiers","title":"Expression Support Tiers","text":"<p>Not all expressions support all theorems.</p>"},{"location":"architecture/golden-theorems/#exprsupportedcore","title":"ExprSupportedCore","text":"<p>Fully computable subset enabling <code>native_decide</code>:</p> <ul> <li><code>const</code>, <code>var</code>, <code>add</code>, <code>mul</code>, <code>neg</code></li> <li><code>sin</code>, <code>cos</code>, <code>exp</code>, <code>sqrt</code> (via Taylor series)</li> </ul>"},{"location":"architecture/golden-theorems/#exprsupportedwithinv","title":"ExprSupportedWithInv","text":"<p>Extended support including partial functions:</p> <ul> <li>Everything in <code>ExprSupportedCore</code></li> <li><code>inv</code>, <code>log</code>, <code>atan</code>, <code>arsinh</code>, <code>atanh</code>, <code>sinc</code>, <code>erf</code></li> </ul> <p>These require <code>evalInterval?</code> which may return <code>none</code> if domain constraints are violated.</p>"},{"location":"architecture/golden-theorems/#arithmetic-backends","title":"Arithmetic Backends","text":"<p>LeanCert provides three arithmetic backends, each with different tradeoffs:</p> Backend File Speed Precision Best For Rational <code>Validity/Bounds.lean</code> Slow Exact Small expressions, reproducibility Dyadic <code>Validity/DyadicBounds.lean</code> Fast Fixed-precision Deep expressions, neural networks Affine <code>Validity/AffineBounds.lean</code> Medium Correlation-aware Dependency-heavy expressions"},{"location":"architecture/golden-theorems/#rational-backend-default","title":"Rational Backend (Default)","text":"<p>The standard backend using arbitrary-precision rationals. Guarantees exact intermediate results but can suffer from denominator explosion on deep expressions.</p>"},{"location":"architecture/golden-theorems/#dyadic-backend","title":"Dyadic Backend","text":"<p>Uses fixed-precision dyadic numbers (m \u00b7 2^e) to avoid denominator explosion:</p> <pre><code>theorem verify_upper_bound_dyadic (e : Expr) (hsupp : ExprSupportedCore e)\n    (lo hi : \u211a) (hle : lo \u2264 hi) (c : \u211a)\n    (prec : Int) (depth : Nat) (h_prec : prec \u2264 0)\n    (hdom : evalDomainValidDyadic e ...)\n    (h_check : checkUpperBoundDyadic e lo hi hle c prec depth = true) :\n    \u2200 x \u2208 Set.Icc lo hi, Expr.eval (fun _ =&gt; x) e \u2264 c\n</code></pre> <p>Note: The API takes rational bounds (<code>lo</code>, <code>hi</code>, <code>c : \u211a</code>) for user convenience, but internally converts to <code>IntervalDyadic</code> and runs <code>evalIntervalDyadic</code> \u2014 the actual computation uses Dyadic arithmetic for speed.</p> <p>Key parameters: - <code>prec : Int</code> - Precision (negative = more precision, must be \u2264 0) - <code>depth : Nat</code> - Taylor series depth for transcendentals</p> <p>The <code>'</code> variant (<code>verify_upper_bound_dyadic'</code>) uses <code>ExprSupported</code> and handles domain validity automatically.</p> <p>Essential for neural network verification and optimization loops where expression depth can be in the hundreds.</p>"},{"location":"architecture/golden-theorems/#affine-backend","title":"Affine Backend","text":"<p>Solves the \"dependency problem\" in interval arithmetic by tracking linear correlations:</p> <pre><code>theorem verify_upper_bound_affine1 (e : Expr) (hsupp : ExprSupportedCore e)\n    (I : IntervalRat) (c : \u211a) (cfg : AffineConfig)\n    (hdom : evalDomainValidAffine e (toAffineEnvConst I) cfg)\n    (h_check : checkUpperBoundAffine1 e I c cfg = true) :\n    \u2200 x \u2208 I, Expr.eval (fun _ =&gt; x) e \u2264 c\n</code></pre> <p>The <code>'</code> variant (<code>verify_upper_bound_affine1'</code>) uses <code>ExprSupported</code> and handles domain validity automatically.</p> <p>Affine arithmetic represents values as <code>x\u0302 = c\u2080 + \u03a3\u1d62 c\u1d62\u00b7\u03b5\u1d62 + [-r, r]</code> where \u03b5\u1d62 \u2208 [-1, 1] are noise symbols. This means:</p> <ul> <li>Standard IA: <code>x - x</code> on <code>[-1, 1]</code> \u2192 <code>[-2, 2]</code> (pessimistic)</li> <li>Affine AA: <code>x - x</code> on <code>[-1, 1]</code> \u2192 <code>[0, 0]</code> (exact)</li> </ul> <p>Use affine when the same variable appears multiple times in an expression.</p>"},{"location":"architecture/golden-theorems/#backend-theorems-summary","title":"Backend Theorems Summary","text":"Goal Rational Dyadic Affine Upper bound <code>verify_upper_bound</code> <code>verify_upper_bound_dyadic</code> <code>verify_upper_bound_affine1</code> Lower bound <code>verify_lower_bound</code> <code>verify_lower_bound_dyadic</code> <code>verify_lower_bound_affine1</code> <p>Each backend also provides <code>'</code> variants for <code>ExprSupported</code> expressions where domain validity is automatic: - <code>verify_upper_bound_dyadic'</code> - <code>verify_lower_bound_affine1'</code> - etc.</p>"},{"location":"architecture/golden-theorems/#kernel-verification","title":"Kernel Verification","text":"<p>For higher trust, the dyadic backend supports verification via <code>decide</code> instead of <code>native_decide</code>:</p> Theorem Verification Trust Level <code>verify_upper_bound_dyadic</code> <code>decide</code> Kernel only <code>verify_lower_bound_dyadic</code> <code>decide</code> Kernel only <p>This removes the compiler from the trusted computing base\u2014only the Lean kernel must be trusted.</p> <p>Note: Kernel verification requires the goal to be in <code>Core.Expr.eval</code> form with rational interval bounds.</p>"},{"location":"architecture/golden-theorems/#the-certificate-workflow","title":"The Certificate Workflow","text":"<ol> <li>Python discovers: Find bounds, roots, or optima</li> <li>Python generates certificate: Parameters that make the checker return <code>true</code></li> <li>Lean verifies: Run the checker via <code>native_decide</code></li> <li>Golden theorem applies: Boolean <code>true</code> lifts to semantic proof</li> </ol> <pre><code>Python                           Lean\n\u2500\u2500\u2500\u2500\u2500\u2500                           \u2500\u2500\u2500\u2500\nfind_bounds(x\u00b2+sin(x), [0,1])\n    \u2502\n    \u25bc\n{expr: \"...\", interval: [0,1],   \u2500\u2500\u25b6  checkUpperBound(...) = true\n upper_bound: 2, config: {...}}        \u2502\n                                       \u25bc\n                                  verify_upper_bound(...)\n                                       \u2502\n                                       \u25bc\n                                  \u2200 x \u2208 [0,1], x\u00b2 + sin(x) \u2264 2\n</code></pre>"},{"location":"architecture/golden-theorems/#real-world-examples","title":"Real-World Examples","text":"<p>The <code>examples/</code> folder contains complete working examples demonstrating LeanCert on real-world problems from various domains.</p>"},{"location":"architecture/golden-theorems/#number-theory-2-examplessqrt2lean","title":"Number Theory: \u221a2 (<code>examples/Sqrt2.lean</code>)","text":"<p>Proves existence, uniqueness, and arbitrary-precision bounds for \u221a2:</p> <pre><code>-- Existence via IVT (sign change)\ntheorem sqrt2_exists : \u2203 x \u2208 I12, x * x - 2 = 0 := by\n  interval_roots\n\n-- Uniqueness via Newton contraction\ntheorem sqrt2_unique : \u2203! x, x \u2208 I12 \u2227 x * x - 2 = 0 := by\n  interval_unique_root\n\n-- 9 decimal places of precision\ntheorem sqrt2_9_decimals : \u2203 x \u2208 \u27e81414213562/1000000000, 1414213563/1000000000, _\u27e9,\n    x * x - 2 = 0 := by\n  interval_roots\n</code></pre>"},{"location":"architecture/golden-theorems/#ml-safety-neural-network-verification-examplesneuralnetlean","title":"ML Safety: Neural Network Verification (<code>examples/NeuralNet.lean</code>)","text":"<p>Demonstrates interval propagation through neural networks:</p> <pre><code>def simpleNet : TwoLayerNet where\n  layer1 := \u27e8[[1, 1], [1, -1]], [0, 0]\u27e9\n  layer2 := \u27e8[[1, 1]], [0]\u27e9\n\n-- Compute certified output bounds for input region\ndef outputBounds : IntervalVector :=\n  TwoLayerNet.forwardInterval simpleNet inputRegion (-53)\n</code></pre>"},{"location":"architecture/golden-theorems/#control-theory-lyapunov-stability-exampleslyapunovlean","title":"Control Theory: Lyapunov Stability (<code>examples/Lyapunov.lean</code>)","text":"<p>Proves energy dissipation for a damped harmonic oscillator:</p> <pre><code>-- V\u0307 = -2\u03b6\u03c9\u2099v\u00b2 \u2264 0 proves stability\ntheorem energy_derivative_nonpositive :\n    \u2200 v \u2208 Set.Icc (-1:\u211d) 1, -2/5 * v * v \u2264 (0 : \u211d) := by\n  -- Split domain to handle dependency problem\n  intro v \u27e8hlo, hhi\u27e9\n  by_cases h : v \u2265 0\n  \u00b7 have := energy_derivative_on_positive v \u27e8h, hhi\u27e9; linarith\n  \u00b7 have := energy_derivative_on_negative v \u27e8hlo, le_of_lt (not_le.mp h)\u27e9; linarith\n</code></pre> <p>Key technique: Domain splitting to handle the dependency problem (IA computes <code>v*v</code> on <code>[-1,1]</code> as <code>[-1,1]</code> instead of <code>[0,1]</code>).</p>"},{"location":"architecture/golden-theorems/#finance-black-scholes-bounds-examplesblackscholeslean","title":"Finance: Black-Scholes Bounds (<code>examples/BlackScholes.lean</code>)","text":"<p>Proves bounds on option pricing components:</p> <pre><code>-- Discount factor: e^(-rT) bounds for risk-free rate\ntheorem discount_factor_lower :\n    \u2200 r \u2208 Set.Icc (-6/100 : \u211d) (-4/100), (94/100 : \u211a) \u2264 Real.exp r := by\n  certify_bound\n\n-- Log-moneyness for near-ATM options\ntheorem log_moneyness_upper :\n    \u2200 x \u2208 Set.Icc (9/10 : \u211d) (11/10), Real.log x \u2264 (10/100 : \u211a) := by\n  certify_bound\n\n-- Gaussian core for vega calculation\ntheorem gaussian_core_upper :\n    \u2200 x \u2208 Set.Icc (0:\u211d) 2, Real.exp (-x * x / 2) \u2264 (1 : \u211a) := by\n  certify_bound\n</code></pre>"},{"location":"architecture/golden-theorems/#physics-projectile-motion-examplesprojectilelean","title":"Physics: Projectile Motion (<code>examples/Projectile.lean</code>)","text":"<p>Proves bounds on projectile dynamics with air resistance:</p> <pre><code>-- Drag acceleration: F_drag/m = k\u00b7v\u00b2 \u2264 8.33 m/s\u00b2\ntheorem drag_accel_upper :\n    \u2200 v \u2208 Set.Icc (0:\u211d) 50, 1/300 * v * v \u2264 (25/3 : \u211a) := by\n  certify_bound\n\n-- Net acceleration with gravity and drag\ntheorem net_accel_lower :\n    \u2200 v \u2208 Set.Icc (0:\u211d) 50, (7/5 : \u211a) \u2264 49/5 - 1/300 * v * v := by\n  certify_bound\n\n-- Exponential velocity decay\ntheorem exp_decay_lower :\n    \u2200 t \u2208 Set.Icc (-1:\u211d) 0, (36/100 : \u211a) \u2264 Real.exp t := by\n  certify_bound\n</code></pre>"},{"location":"architecture/golden-theorems/#running-the-examples","title":"Running the Examples","text":"<pre><code># Test all examples\nfor f in examples/*.lean; do lake env lean \"$f\"; done\n\n# Test a specific example\nlake env lean examples/Sqrt2.lean\n</code></pre>"},{"location":"architecture/golden-theorems/#lessons-learned","title":"Lessons Learned","text":"Issue Solution Dependency problem (<code>v*v</code> gives <code>[-1,1]</code> instead of <code>[0,1]</code>) Split domain and prove separately on <code>[0,1]</code> and <code>[-1,0]</code> Rational cast errors (<code>(2/5 : \u211a)</code> in expressions) Use plain fractions: <code>2/5</code> without type annotation Taylor overflow on wide intervals (sin/cos) Use narrower intervals or accept looser bounds Division not computable (<code>1/x</code> bounds) Division bounds require <code>ExprSupportedWithInv</code>, not pure <code>native_decide</code> Discovery command syntax Use <code>#bounds (fun x =&gt; ...) on [a, b]</code> with integer endpoints"},{"location":"architecture/root-finding/","title":"Root Finding Algorithms","text":"<p>LeanCert provides verified root finding with proofs of existence and uniqueness.</p>"},{"location":"architecture/root-finding/#overview","title":"Overview","text":"Algorithm Proves Method Tactic Bisection Existence Sign change + IVT <code>interval_roots</code> Newton Contraction Uniqueness Fixed-point theorem <code>interval_unique_root</code>"},{"location":"architecture/root-finding/#bisection-existence","title":"Bisection (Existence)","text":""},{"location":"architecture/root-finding/#how-it-works","title":"How It Works","text":"<ol> <li>Evaluate f at interval endpoints</li> <li>If signs differ, IVT guarantees a root exists</li> <li>Recursively bisect to narrow the interval</li> </ol> <pre><code>f(a) &lt; 0                    f(b) &gt; 0\n  \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf\n  a          root          b\n             somewhere\n             in here\n</code></pre>"},{"location":"architecture/root-finding/#the-theorem","title":"The Theorem","text":"<pre><code>theorem verify_sign_change (e : Expr) (hsupp : ExprSupportedCore e)\n    (hcont : ContinuousOn (Expr.eval e) (Set.Icc I.lo I.hi))\n    (I : IntervalRat) (cfg : EvalConfig)\n    (h_cert : checkSignChange e I cfg = true) :\n    \u2203 x \u2208 I, Expr.eval (fun _ =&gt; x) e = 0\n</code></pre> <p>Key insight: The checker <code>checkSignChange</code> is computable (runs via <code>native_decide</code>), while the conclusion is a semantic statement about real numbers.</p>"},{"location":"architecture/root-finding/#usage","title":"Usage","text":"<pre><code>import LeanCert.Tactic.Discovery\n\nopen LeanCert.Core\n\ndef I12 : IntervalRat := \u27e81, 2, by norm_num\u27e9\n\n-- Prove \u221a2 exists (root of x\u00b2 - 2)\nexample : \u2203 x \u2208 I12, Expr.eval (fun _ =&gt; x)\n    (Expr.add (Expr.mul (Expr.var 0) (Expr.var 0)) (Expr.neg (Expr.const 2))) = 0 := by\n  interval_roots\n</code></pre>"},{"location":"architecture/root-finding/#algorithm-details","title":"Algorithm Details","text":"<pre><code>bisectRoot(f, [a, b], depth):\n  if depth = 0:\n    return [a, b] if sign_change(f, a, b) else \u2205\n\n  mid = (a + b) / 2\n  roots = []\n\n  if sign_change(f, a, mid):\n    roots += bisectRoot(f, [a, mid], depth - 1)\n\n  if sign_change(f, mid, b):\n    roots += bisectRoot(f, [mid, b], depth - 1)\n\n  return roots\n</code></pre>"},{"location":"architecture/root-finding/#limitations","title":"Limitations","text":"<ul> <li>Only finds roots where sign changes (misses tangent roots like x\u00b2 at 0)</li> <li>Requires continuity (cannot handle discontinuous functions)</li> <li>Multiple roots in interval returns multiple candidate intervals</li> </ul>"},{"location":"architecture/root-finding/#newton-contraction-uniqueness","title":"Newton Contraction (Uniqueness)","text":""},{"location":"architecture/root-finding/#how-it-works_1","title":"How It Works","text":"<p>The Newton operator is:</p> <p>\\[ N(x) = x - \\frac{f(x)}{f'(x)} \\]</p> <p>If we can show: 1. N maps interval I into itself: N(I) \u2286 I 2. N is a contraction: |N'(x)| &lt; 1 for all x \u2208 I</p> <p>Then Banach fixed-point theorem guarantees exactly one root in I.</p>"},{"location":"architecture/root-finding/#the-theorem_1","title":"The Theorem","text":"<pre><code>theorem newton_contraction_unique_root (e : Expr) (hsupp : ExprSupportedCore e)\n    (I : IntervalRat) (cfg : EvalConfig)\n    (h_maps_into : newtonInterval e I cfg \u2286 I)\n    (h_contracts : \u2200 x \u2208 I, |newtonDerivative e x cfg| &lt; 1) :\n    \u2203! x \u2208 I, Expr.eval (fun _ =&gt; x) e = 0\n</code></pre>"},{"location":"architecture/root-finding/#usage_1","title":"Usage","text":"<pre><code>import LeanCert.Tactic.Discovery\n\n-- Prove x\u00b2 - 2 has exactly one root in [1, 2]\nexample : \u2203! x \u2208 I12, Expr.eval (fun _ =&gt; x) expr_x2_minus_2 = 0 := by\n  interval_unique_root\n</code></pre>"},{"location":"architecture/root-finding/#contraction-verification","title":"Contraction Verification","text":"<p>To verify contraction, we bound |N'(x)|:</p> <p>\\[ N'(x) = 1 - \\frac{f'(x)^2 - f(x) \\cdot f''(x)}{f'(x)^2} = \\frac{f(x) \\cdot f''(x)}{f'(x)^2} \\]</p> <p>Using interval arithmetic: 1. Compute interval bounds on f(I), f'(I), f''(I) 2. Check if |f(I) \u00b7 f''(I)| / |f'(I)|\u00b2 &lt; 1</p>"},{"location":"architecture/root-finding/#algorithm-details_1","title":"Algorithm Details","text":"<pre><code>checkNewtonContracts(f, I):\n  # Compute function and derivatives on interval\n  f_I   = evalInterval(f, I)\n  f'_I  = evalInterval(derivative(f), I)\n  f''_I = evalInterval(derivative(derivative(f)), I)\n\n  # Check f' doesn't contain 0 (otherwise N undefined)\n  if 0 \u2208 f'_I:\n    return false\n\n  # Compute Newton image\n  N_I = I - f_I / f'_I\n\n  # Check maps into\n  if not (N_I \u2286 I):\n    return false\n\n  # Check contraction (|N'| &lt; 1)\n  N'_bound = |f_I * f''_I| / (f'_I)\u00b2\n  return N'_bound.hi &lt; 1\n</code></pre>"},{"location":"architecture/root-finding/#refinement","title":"Refinement","text":"<p>Once uniqueness is established, Newton iteration refines the root location:</p> <pre><code>def newtonRefine (e : Expr) (I : IntervalRat) (n : \u2115) : IntervalRat :=\n  match n with\n  | 0 =&gt; I\n  | n + 1 =&gt; newtonRefine e (newtonStep e I) n\n</code></pre> <p>Each iteration roughly doubles the number of correct digits.</p>"},{"location":"architecture/root-finding/#comparison","title":"Comparison","text":"Aspect Bisection Newton Proves Existence Uniqueness Requires Sign change f' \u2260 0, contraction Convergence Linear Quadratic Multiple roots Finds all (with sign change) Finds one Tangent roots Misses Can verify if f' \u2260 0 nearby"},{"location":"architecture/root-finding/#combined-workflow","title":"Combined Workflow","text":"<p>For full root verification:</p> <pre><code>-- 1. First prove existence\nhave h_exists : \u2203 x \u2208 I, f x = 0 := by interval_roots\n\n-- 2. Then prove uniqueness (if needed)\nhave h_unique : \u2203! x \u2208 I, f x = 0 := by interval_unique_root\n\n-- 3. Optionally refine location\n-- The unique root is in a very narrow interval\n</code></pre>"},{"location":"architecture/root-finding/#mean-value-theorem-bounds","title":"Mean Value Theorem Bounds","text":"<p>The <code>MVTBounds</code> module provides additional tools:</p> <pre><code>-- If f' is bounded on [a,b], then f(b) - f(a) is bounded\ntheorem mvt_bound (f : \u211d \u2192 \u211d) (a b : \u211d) (M : \u211d)\n    (h_diff : DifferentiableOn \u211d f (Set.Icc a b))\n    (h_bound : \u2200 x \u2208 Set.Icc a b, |f' x| \u2264 M) :\n    |f b - f a| \u2264 M * |b - a|\n</code></pre> <p>This is used internally for: - Bounding how much f can change between sample points - Verifying monotonicity - Lipschitz constant estimation</p>"},{"location":"architecture/root-finding/#files","title":"Files","text":"File Description <code>Engine/RootFinding/Basic.lean</code> Core predicates (<code>signChange</code>, <code>excludesZero</code>) <code>Engine/RootFinding/Bisection.lean</code> Bisection algorithm <code>Engine/RootFinding/Contraction.lean</code> Newton contraction verification <code>Engine/RootFinding/MVTBounds.lean</code> Mean value theorem utilities <code>Tactic/Discovery.lean</code> <code>interval_roots</code>, <code>interval_unique_root</code> tactics"},{"location":"architecture/verification-status/","title":"Verification Status","text":"<p>LeanCert aims for full formal verification. This page documents what is fully proved versus what contains <code>sorry</code> (unfinished proofs).</p>"},{"location":"architecture/verification-status/#fully-verified","title":"Fully Verified","text":"<p>The following components have complete proofs with no <code>sorry</code>:</p>"},{"location":"architecture/verification-status/#interval-arithmetic-ftia","title":"Interval Arithmetic (FTIA)","text":"<p>The Fundamental Theorem of Interval Arithmetic is proved for all basic operations:</p> <ul> <li>Addition, subtraction: \\(x \\in I_1, y \\in I_2 \\implies x + y \\in I_1 + I_2\\)</li> <li>Multiplication: \\(x \\in I_1, y \\in I_2 \\implies x \\cdot y \\in I_1 \\cdot I_2\\)</li> <li>Division: \\(x \\in I_1, y \\in I_2, 0 \\notin I_2 \\implies x / y \\in I_1 / I_2\\)</li> <li>Power: \\(x \\in I \\implies x^n \\in I^n\\)</li> </ul>"},{"location":"architecture/verification-status/#transcendental-functions","title":"Transcendental Functions","text":"<p>Rigorous bounds via Taylor series with verified remainder terms:</p> Function Theorem Location \\(e^x\\) <code>mem_expInterval</code> <code>Core/IntervalReal.lean</code> \\(\\sin x\\) <code>mem_sinInterval</code> <code>Core/IntervalReal.lean</code> \\(\\cos x\\) <code>mem_cosInterval</code> <code>Core/IntervalReal.lean</code> \\(\\log x\\) <code>mem_logInterval</code> <code>Core/IntervalReal.lean</code> \\(\\sinh x\\) <code>mem_sinhInterval</code> <code>Core/IntervalReal.lean</code> \\(\\cosh x\\) <code>mem_coshInterval</code> <code>Core/IntervalReal.lean</code> \\(\\tanh x\\) <code>mem_tanhInterval</code> <code>Core/IntervalReal.lean</code> \\(\\arctan x\\) <code>mem_atanInterval</code> <code>Engine/Eval/Core.lean</code> \\(\\text{arsinh}(x)\\) <code>mem_arsinhInterval</code> <code>Engine/Eval/Core.lean</code> \\(\\text{atanh}(x)\\) <code>mem_atanhInterval</code> <code>Engine/Eval/Core.lean</code> \\(\\sqrt{x}\\) <code>mem_sqrtIntervalTight</code> <code>Core/IntervalRat/Transcendental.lean</code> \\(\\text{erf}(x)\\) <code>mem_erfInterval</code> <code>Engine/Eval/Core.lean</code> \\(\\text{sinc}(x)\\) <code>sinc_evalSet_correct</code> <code>Engine/TaylorModel/Trig.lean</code>"},{"location":"architecture/verification-status/#extended-interval-arithmetic","title":"Extended Interval Arithmetic","text":"<p>Standard interval arithmetic fails when dividing by an interval containing zero. LeanCert's Extended Arithmetic returns a union of intervals, preserving soundness even across singularities.</p> <ul> <li>Theorem: <code>evalExtended_correct_core</code></li> <li>Behavior: 1 / [-1, 1] \u2192 (-\u221e, -1] \u222a [1, \u221e)</li> <li>Status: Verified for core expressions</li> </ul> <p>This enables robust handling of expressions like 1/x near x = 0.</p>"},{"location":"architecture/verification-status/#taylor-series","title":"Taylor Series","text":"<p>The core Taylor remainder bounds are fully proved:</p> <pre><code>theorem taylor_remainder_bound (f : \u211d \u2192 \u211d) (n : \u2115) (a x : \u211d) ...\n</code></pre> <p>This is the foundation for all transcendental function bounds.</p>"},{"location":"architecture/verification-status/#taylor-models","title":"Taylor Models","text":"<p>Taylor Models combine polynomial approximation with rigorous remainder bounds. The <code>fromExpr?</code> function in <code>Engine/TaylorModel/Expr.lean</code> converts expressions to verified Taylor Models.</p> <p>All functions are now fully enabled:</p> Function Status Theorem <code>exp</code>, <code>log</code> \u2705 Verified <code>tmExp_correct</code>, <code>tmLog_correct</code> <code>sin</code>, <code>cos</code> \u2705 Verified <code>tmSin_correct</code>, <code>tmCos_correct</code> <code>sinh</code>, <code>cosh</code>, <code>tanh</code> \u2705 Verified <code>sinh_evalSet_correct</code>, etc. <code>atan</code> \u2705 Verified <code>mem_atanInterval</code> (interval-based) <code>arsinh</code>, <code>atanh</code> \u2705 Verified <code>tmAsinh_correct</code>, <code>atanh_evalSet_correct</code> <code>sqrt</code> \u2705 Verified <code>mem_sqrtIntervalTight</code> (interval-based) <code>erf</code> \u2705 Verified <code>mem_erfInterval</code> (interval-based) <code>sinc</code> \u2705 Verified <code>sinc_evalSet_correct</code> <p>The main correctness theorem <code>fromExpr_evalSet_correct</code> proves that for any supported expression, the Taylor Model's evaluation set contains the true function value.</p>"},{"location":"architecture/verification-status/#automatic-differentiation","title":"Automatic Differentiation","text":"<p>Forward-mode AD with verified value and derivative bounds:</p> <ul> <li><code>evalDual_val_correct</code>: Value component is correct</li> <li><code>evalDual_der_correct</code>: Derivative component is correct</li> </ul>"},{"location":"architecture/verification-status/#global-optimization","title":"Global Optimization","text":"<p>Branch-and-bound with formal guarantees:</p> <ul> <li><code>globalMinimize_lo_correct</code>: Lower bound is valid</li> <li><code>globalMaximize_hi_correct</code>: Upper bound is valid</li> </ul>"},{"location":"architecture/verification-status/#root-finding","title":"Root Finding","text":"<ul> <li>Bisection: <code>verify_sign_change</code> proves existence via IVT</li> <li>Newton: <code>verify_unique_root_core</code> proves uniqueness via contraction</li> </ul>"},{"location":"architecture/verification-status/#integration","title":"Integration","text":"<ul> <li><code>integrateInterval_correct</code>: Riemann sum bounds contain the true integral (general n partitions)</li> <li><code>integrateAdaptive_correct</code>: Adaptive integration with error-driven subdivision</li> <li>Both rational and dyadic backends are fully verified (see Dyadic Integration below)</li> </ul>"},{"location":"architecture/verification-status/#dyadic-backend","title":"Dyadic Backend","text":"<p>The high-performance dyadic interval evaluator is fully verified:</p> <ul> <li><code>evalIntervalDyadic_correct</code>: Dyadic evaluation produces sound intervals for <code>ExprSupportedCore</code></li> <li><code>evalIntervalDyadic_correct_withInv</code>: Extended correctness for <code>ExprSupportedWithInv</code> (includes <code>inv</code>, <code>log</code>, <code>atan</code>, <code>arsinh</code>, <code>atanh</code>, <code>sinc</code>, <code>erf</code>)</li> <li><code>IntervalDyadic.mem_add</code>, <code>mem_mul</code>, <code>mem_neg</code>: FTIA for dyadic operations</li> <li><code>IntervalDyadic.roundOut_contains</code>: Outward rounding preserves containment</li> <li><code>atanhComputable</code> / <code>mem_atanhComputable</code>: Computable atanh interval via Taylor series endpoint evaluation</li> </ul> <p>The dyadic backend avoids rational denominator explosion by using fixed-precision arithmetic:</p> Expression Rational Denominator Dyadic Mantissa <code>exp(exp(x))</code> ~200 digits 17 digits <code>exp(exp(exp(x)))</code> ~2000 digits 18 digits <p>See <code>LeanCert/Test/BenchmarkBackends.lean</code> for performance comparisons.</p>"},{"location":"architecture/verification-status/#dyadic-integration","title":"Dyadic Integration","text":"<p>High-performance integration using the dyadic backend, enabling verified integral bounds for complex expressions where rational arithmetic would be prohibitively slow:</p> <ul> <li><code>integrateInterval1Dyadic_correct</code>: Single-interval dyadic integration correctness</li> <li><code>integratePartitionDyadic_correct</code>: Partition-based dyadic integration with uniform partitioning</li> <li><code>integratePartitionDyadic_bound_correct</code>: Upper/lower bound extraction from partition results</li> </ul> <p>The dyadic integration module (<code>Validity/IntegrationDyadic.lean</code>) is a drop-in replacement for rational <code>integratePartitionWithInv</code> that uses <code>evalIntervalDyadic</code> instead of <code>evalInterval?</code>. Since <code>evalIntervalDyadic</code> is total (returns wide bounds on domain violations rather than <code>none</code>), the integration functions are also total \u2014 domain violations manifest as wide bounds that cause the checker to return <code>false</code>, which is safe for the <code>native_decide</code> workflow.</p>"},{"location":"architecture/verification-status/#bernstein-polynomial-enclosure","title":"Bernstein Polynomial Enclosure","text":"<p>Tight polynomial bounds via verified Bernstein basis conversion (<code>Engine/TaylorModel/Core.lean</code>):</p> <ul> <li><code>boundPolyBernstein_correct</code>: Main enclosure theorem \u2014 polynomial values on an interval are contained in the min/max of Bernstein coefficients</li> <li><code>bernstein_partition_of_unity</code>: Bernstein basis functions sum to 1</li> <li><code>bernstein_nonneg</code>: Bernstein basis functions are nonneg on [0, 1]</li> <li><code>monomial_bernstein_expansion</code>: Monomial-to-Bernstein conversion identity</li> </ul> <p>This enables tighter polynomial range bounds than naive interval evaluation, which is critical for Taylor model remainder estimation.</p>"},{"location":"architecture/verification-status/#computable-polynomial-taylor-models","title":"Computable Polynomial Taylor Models","text":"<p>Dyadic polynomial Taylor models (<code>Engine/CompPoly.lean</code>) avoiding rational coefficient explosion:</p> <ul> <li><code>DyPoly</code>: Polynomial with <code>Dyadic</code> coefficients</li> <li><code>DyTM</code>: Taylor model combining <code>DyPoly</code> + <code>IntervalDyadic</code> remainder</li> <li>Computable evaluation and integration operations using fixed-precision arithmetic throughout</li> </ul>"},{"location":"architecture/verification-status/#neural-network-verification","title":"Neural Network Verification","text":"<p>The ML module provides verified interval propagation for neural networks:</p> <ul> <li><code>mem_forwardInterval</code>: Soundness of dense layer propagation</li> <li><code>mem_relu</code>, <code>mem_sigmoid</code>: Activation function soundness</li> <li><code>relu_relaxation_sound</code>: DeepPoly ReLU triangle relaxation</li> <li><code>sigmoid_relaxation_sound</code>: DeepPoly sigmoid monotonicity bounds</li> </ul> <p>Transformer Components:</p> <ul> <li><code>mem_scaledDotProductAttention</code>: Soundness of Q\u00d7K^T + Softmax + V</li> <li><code>mem_layerNormInterval</code>: Soundness of Layer Normalization</li> <li><code>mem_geluInterval</code>: Soundness of GELU activation</li> <li><code>forwardQuantized_sound</code>: Soundness of integer-quantized split-sign inference</li> </ul> <p>See <code>LeanCert/ML/</code> for the full implementation.</p>"},{"location":"architecture/verification-status/#kernel-verification-dyadic","title":"Kernel Verification (Dyadic)","text":"<p>Bridge theorems for kernel-level verification via <code>decide</code>:</p> <ul> <li><code>verify_upper_bound_dyadic</code>: Connects Dyadic boolean check to Real semantic bounds</li> <li><code>verify_lower_bound_dyadic</code>: Lower bound variant</li> <li><code>evalIntervalDyadic_correct</code>: Dyadic evaluation is sound w.r.t Real operations</li> </ul> <p>These enable the <code>certify_kernel</code> tactic to produce proofs verified purely by the Lean kernel, removing the compiler from the trusted computing base.</p>"},{"location":"architecture/verification-status/#incomplete-contains-sorry","title":"Incomplete (Contains <code>sorry</code>)","text":"<p>These features work computationally but have gaps in formal proofs:</p> Component Issue Impact <code>sinc</code> derivative bound <code>sinc_deriv_bound</code> for n\u22652 Very Low - only affects Taylor precision for sinc <p>The <code>sinc_deriv_bound</code> lemma bounds higher derivatives of sinc for Taylor remainder estimation. The proof requires Leibniz rule under the integral (sinc(x) = \u222b\u2080\u00b9 cos(tx) dt), which is deferred. The interval-based sinc evaluation still works correctly.</p>"},{"location":"architecture/verification-status/#finding-sorries","title":"Finding Sorries","text":"<p>To audit the codebase yourself:</p> <pre><code>grep -r \"sorry\" --include=\"*.lean\" LeanCert/ | grep -v \"no sorry\"\n</code></pre> <p>Current count: 0 declarations using <code>sorry</code> in the default build target. The examples directory contains deliberate <code>sorry</code>s for downstream API ergonomics (e.g., <code>Li2Bounds.lean</code> provides sorry'd lemmas alongside verified proofs in <code>Li2Verified.lean</code>).</p>"},{"location":"architecture/verification-status/#what-this-means","title":"What This Means","text":"<p>For typical use cases (polynomials, <code>sin</code>, <code>cos</code>, <code>exp</code>, <code>log</code>, <code>sqrt</code>, <code>atan</code>, <code>atanh</code>, <code>erf</code>, optimization, root finding, integration):</p> <p>The verification is complete. Proofs generated by LeanCert are accepted by the Lean kernel with no axioms beyond standard Mathlib foundations.</p> <p>For the dyadic backend (neural networks, deep expressions, integration of complex integrands):</p> <p>All operations including <code>atanh</code> are now fully verified. The dyadic integration path (<code>IntegrationDyadic.lean</code>) provides sound integral bounds with 10-50x speedup over rational arithmetic for transcendental-heavy expressions.</p>"},{"location":"ml/distillation/","title":"Model Distillation Verification","text":"<p>LeanCert allows you to formally verify that a compressed \"Student\" model behaves identically (within a tolerance \u03b5) to a large \"Teacher\" model.</p>"},{"location":"ml/distillation/#the-problem","title":"The Problem","text":"<p>When deploying AI, we often compress large models via distillation, pruning, or quantization. How do we know the compressed model is safe? Testing on a dataset isn't enough\u2014it leaves gaps where untested inputs could produce dangerous outputs.</p>"},{"location":"ml/distillation/#the-solution-formal-equivalence","title":"The Solution: Formal Equivalence","text":"<p>We verify that:</p> <p>\\[ \\forall x \\in \\text{Domain}, \\quad |\\text{Teacher}(x) - \\text{Student}(x)| \\le \\epsilon \\]</p> <p>This provides a guarantee that holds for all possible inputs, not just test samples.</p>"},{"location":"ml/distillation/#usage","title":"Usage","text":"<pre><code>import LeanCert.ML.Distillation\n\nopen LeanCert.ML.Distillation\n\n-- 1. Define input domain (e.g., [0, 1]\u00b2)\ndef domain := [IntervalDyadic.ofRat 0 1, IntervalDyadic.ofRat 0 1]\n\n-- 2. Define tolerance\ndef epsilon : \u211a := 0.01\n\n-- 3. Verify equivalence\ntheorem model_equivalence :\n    verify_equivalence teacherNet studentNet domain epsilon := by\n  native_decide\n</code></pre>"},{"location":"ml/distillation/#how-it-works","title":"How it Works","text":"<p>The verifier computes interval bounds for the difference graph D(x) = T(x) - S(x). By computing the difference directly, interval arithmetic can cancel out correlated terms (like shared inputs), resulting in much tighter bounds than bounding T(x) and S(x) separately.</p>"},{"location":"ml/distillation/#difference-graph-approach","title":"Difference Graph Approach","text":"<pre><code>Standard approach (loose):\n  |T(x) - S(x)| \u2264 |T(x)| + |S(x)| \u2264 wide bound\n\nDifference graph approach (tight):\n  D(x) = T(x) - S(x)\n  |D(x)| \u2264 tight bound (cancellation exploited)\n</code></pre>"},{"location":"ml/distillation/#verification-workflow","title":"Verification Workflow","text":"<ol> <li>Define networks: Specify Teacher and Student as <code>Layer</code> lists</li> <li>Define domain: Input intervals representing valid inputs</li> <li>Set tolerance: Maximum acceptable output difference \u03b5</li> <li>Run verification: LeanCert propagates intervals through the difference graph</li> <li>Get proof: If successful, produces a formal Lean theorem</li> </ol>"},{"location":"ml/distillation/#example-pruned-classifier","title":"Example: Pruned Classifier","text":"<pre><code>-- Teacher: Full 3-layer network\ndef teacher : List Layer := [layer1, layer2, layer3]\n\n-- Student: Pruned version with zeroed weights\ndef student : List Layer := [layer1_pruned, layer2_pruned, layer3_pruned]\n\n-- Verify pruning didn't change outputs by more than 0.1\ntheorem pruning_safe :\n    \u2200 x \u2208 inputDomain, |teacher.forward x - student.forward x| \u2264 0.1 :=\n  verify_equivalence teacher student inputDomain 0.1\n</code></pre>"},{"location":"ml/distillation/#limitations","title":"Limitations","text":"<ul> <li>Scalability: Very deep networks or wide input domains may require subdivision</li> <li>Tolerance: The verifier may fail if \u03b5 is too tight (increase \u03b5 or refine the domain)</li> <li>Architecture: Both networks must have compatible input/output dimensions</li> </ul>"},{"location":"ml/distillation/#files","title":"Files","text":"File Description <code>ML/Distillation.lean</code> Core verification algorithm <code>Examples/ML/Distillation.lean</code> Example usage"},{"location":"ml/neural-networks/","title":"Neural Network &amp; Transformer Verification","text":"<p>LeanCert includes verified neural network verification based on interval propagation and DeepPoly relaxations, with support for modern architectures including Transformers.</p>"},{"location":"ml/neural-networks/#overview","title":"Overview","text":"<p>The ML module provides:</p> <ul> <li>Interval Propagation: Sound overapproximation of neural network outputs</li> <li>DeepPoly Relaxations: Tight linear bounds for ReLU and sigmoid activations</li> <li>Transformer Support: Multi-Head Attention, LayerNorm, GELU, Residual connections</li> <li>Verified Soundness: All propagation theorems are formally proved in Lean</li> </ul>"},{"location":"ml/neural-networks/#supported-architectures","title":"Supported Architectures","text":"Architecture Components Status Feedforward (MLP) Linear, ReLU, Sigmoid Fully verified Transformers Attention, LayerNorm, GELU Fully verified Residual Networks Skip connections Fully verified"},{"location":"ml/neural-networks/#quick-example","title":"Quick Example","text":"<pre><code>import LeanCert.ML.Network\n\nopen LeanCert.ML\n\n-- Define a simple 2-layer network\ndef myNet : TwoLayerNet := {\n  layer1 := { weights := [[1, -1], [0, 1]], bias := [0, 0] }\n  layer2 := { weights := [[1, 1]], bias := [0] }\n}\n\n-- Input interval: x\u2081 \u2208 [-1, 1], x\u2082 \u2208 [0, 1]\ndef inputBox : IntervalVector := [\n  IntervalDyadic.ofRat (-1) 1,\n  IntervalDyadic.ofRat 0 1\n]\n\n-- Propagate intervals through the network\ndef outputBounds := myNet.forwardInterval inputBox\n</code></pre>"},{"location":"ml/neural-networks/#architecture","title":"Architecture","text":""},{"location":"ml/neural-networks/#layer-structure","title":"Layer Structure","text":"<p>A dense layer computes \\(y = \\text{ReLU}(Wx + b)\\):</p> <pre><code>structure Layer where\n  weights : List (List \u211a)  -- Weight matrix (rows)\n  bias : List \u211a            -- Bias vector\n</code></pre>"},{"location":"ml/neural-networks/#soundness-theorem","title":"Soundness Theorem","text":"<p>The key theorem guarantees that interval propagation is sound:</p> <pre><code>theorem mem_forwardInterval {l : Layer} {xs : List \u211d} {Is : IntervalVector}\n    (hwf : l.WellFormed)\n    (hdim : l.inputDim = Is.length)\n    (hxlen : xs.length = Is.length)\n    (hmem : \u2200 i, xs[i] \u2208 Is[i]) :\n    \u2200 i, (forwardReal l xs)[i] \u2208 (forwardInterval l Is)[i]\n</code></pre> <p>This says: if every real input is contained in its corresponding interval, then every real output is contained in its corresponding output interval.</p>"},{"location":"ml/neural-networks/#activation-functions","title":"Activation Functions","text":""},{"location":"ml/neural-networks/#relu","title":"ReLU","text":"<p>ReLU interval propagation uses the simple rule:</p> \\[ \\text{ReLU}([l, u]) = [\\max(0, l), \\max(0, u)] \\] <pre><code>def relu (I : IntervalDyadic) : IntervalDyadic where\n  lo := Dyadic.max 0 I.lo\n  hi := Dyadic.max 0 I.hi\n\ntheorem mem_relu {x : \u211d} {I : IntervalDyadic} (hx : x \u2208 I) :\n    max 0 x \u2208 relu I\n</code></pre>"},{"location":"ml/neural-networks/#sigmoid","title":"Sigmoid","text":"<p>Sigmoid uses the conservative bound \\(\\sigma(x) \\in (0, 1)\\):</p> <pre><code>def sigmoid (_I : IntervalDyadic) : IntervalDyadic where\n  lo := 0\n  hi := 1\n\ntheorem mem_sigmoid {x : \u211d} {I : IntervalDyadic} (_hx : x \u2208 I) :\n    Real.sigmoid x \u2208 sigmoid I\n</code></pre>"},{"location":"ml/neural-networks/#deeppoly-relaxations","title":"DeepPoly Relaxations","text":"<p>For tighter bounds, the module implements DeepPoly-style linear relaxations.</p>"},{"location":"ml/neural-networks/#relu-triangle-relaxation","title":"ReLU Triangle Relaxation","text":"<p>For the \"crossing case\" where \\(l &lt; 0 &lt; u\\), ReLU is bounded by:</p> <ul> <li>Lower: \\(y \\geq 0\\)</li> <li>Upper: The line through \\((l, 0)\\) and \\((u, u)\\)</li> </ul> <pre><code>theorem upper_bound_valid (l u : \u211a) (x : \u211d)\n    (hl : l &lt; 0) (hu : 0 &lt; u) (hx_mem : l \u2264 x \u2227 x \u2264 u) :\n    max 0 x \u2264 (crossingUpperBound l u).eval x\n</code></pre>"},{"location":"ml/neural-networks/#sigmoid-monotonicity-bounds","title":"Sigmoid Monotonicity Bounds","text":"<p>Since sigmoid is strictly monotone:</p> \\[ \\sigma(l) \\leq \\sigma(x) \\leq \\sigma(u) \\quad \\text{for } x \\in [l, u] \\] <pre><code>theorem sigmoid_relaxation_sound (l u x : \u211d) (h : l \u2264 x \u2227 x \u2264 u) :\n    sigmoid l \u2264 sigmoid x \u2227 sigmoid x \u2264 sigmoid u\n</code></pre>"},{"location":"ml/neural-networks/#gelu-activation","title":"GELU Activation","text":"<p>GELU (Gaussian Error Linear Unit) is the standard activation for Transformers:</p> \\[ \\text{GELU}(x) = 0.5 \\cdot x \\cdot (1 + \\tanh(\\sqrt{2/\\pi} \\cdot (x + 0.044715 \\cdot x^3))) \\] <pre><code>def gelu (I : IntervalDyadic) : IntervalDyadic :=\n  -- Verified interval approximation\n  let inner := I.add (I.mul I.mul I.scale 0.044715)\n  let scaled := inner.scale (Real.sqrt (2 / Real.pi))\n  I.scale 0.5 |&gt;.mul (IntervalDyadic.one.add (tanh scaled))\n\ntheorem mem_geluInterval {x : \u211d} {I : IntervalDyadic} (hx : x \u2208 I) :\n    Real.gelu x \u2208 gelu I\n</code></pre>"},{"location":"ml/neural-networks/#transformer-components","title":"Transformer Components","text":""},{"location":"ml/neural-networks/#self-attention","title":"Self-Attention","text":"<p>LeanCert verifies the scaled dot-product attention mechanism:</p> \\[ \\text{Attention}(Q, K, V) = \\text{softmax}\\left(\\frac{Q \\cdot K^T}{\\sqrt{d_k}}\\right) \\cdot V \\] <pre><code>import LeanCert.ML.Attention\n\n-- Verified attention output bounds\ntheorem mem_scaledDotProductAttention\n    {Q K V : Matrix n d \u211d} {Q_int K_int V_int : IntervalMatrix n d}\n    (hQ : \u2200 i j, Q i j \u2208 Q_int i j)\n    (hK : \u2200 i j, K i j \u2208 K_int i j)\n    (hV : \u2200 i j, V i j \u2208 V_int i j) :\n    \u2200 i j, (scaledDotProductAttention Q K V) i j \u2208\n           (scaledDotProductAttentionInterval Q_int K_int V_int) i j\n</code></pre>"},{"location":"ml/neural-networks/#layer-normalization","title":"Layer Normalization","text":"<p>Interval bounds for LayerNorm are computed soundly:</p> <pre><code>import LeanCert.ML.LayerNorm\n\n-- LayerNorm: y = (x - \u03bc) / \u03c3 * \u03b3 + \u03b2\ntheorem mem_layerNormInterval {x : Vector n \u211d} {I : IntervalVector n}\n    (hx : \u2200 i, x i \u2208 I i) :\n    \u2200 i, (layerNorm x \u03b3 \u03b2) i \u2208 (layerNormInterval I \u03b3_int \u03b2_int) i\n</code></pre> <p>Note: Standard interval arithmetic may overestimate LayerNorm bounds due to variable correlation (the mean and variance are computed from the same input).</p>"},{"location":"ml/neural-networks/#affine-arithmetic-for-tight-layernorm-bounds","title":"Affine Arithmetic for Tight LayerNorm Bounds","text":"<p>To address the dependency problem in LayerNorm, LeanCert provides <code>LeanCert.ML.LayerNormAffine</code> which uses affine arithmetic to track linear correlations between variables:</p> <pre><code>import LeanCert.ML.LayerNormAffine\n\n-- Tight bounds via affine forms that track variable correlations\ndef layerNormAffine (x : AffineVector n) (\u03b3 \u03b2 : List \u211a) : AffineVector n\n\n-- Used in TransformerBlock.forwardIntervalTight\ntheorem layerNormAffine_sound {x_real : Vector n \u211d} {x_affine : AffineVector n}\n    (hx : x_real \u2208 x_affine) :\n    layerNorm x_real \u03b3 \u03b2 \u2208 (layerNormAffine x_affine \u03b3 \u03b2).toIntervalVector\n</code></pre> <p>Key insight: In LayerNorm, the centering operation <code>x - \u03bc</code> creates correlated outputs (they sum to zero). Standard interval arithmetic loses this correlation, leading to loose bounds. Affine arithmetic preserves it:</p> Method LayerNorm([0.9, 1.1]) Bounds Standard Interval [-1.5, 1.5] Affine Arithmetic [-0.1, 0.1] <p>Use <code>TransformerBlock.forwardIntervalTight</code> for the tightest bounds on transformer layers.</p>"},{"location":"ml/neural-networks/#optimized-implementation","title":"Optimized Implementation","text":"<p>For real-world networks, the <code>LeanCert.ML.Optimized</code> module provides:</p> Optimization Speedup Description Structure-of-Arrays ~5x Cache-efficient interval storage Split-Sign Decomposition ~2x Branch-free interval matrix multiply Common Exponent Alignment ~10-50x Pure integer (GMP) arithmetic <pre><code>import LeanCert.ML.Optimized\n\nopen LeanCert.ML.Optimized\n\n-- Create quantized network for fast propagation\ndef qnet := QuantizedNet.ofLayers myLayers\n\n-- Fast interval propagation\ndef output := qnet.forward alignedInput\n</code></pre>"},{"location":"ml/neural-networks/#verification-status","title":"Verification Status","text":"Component Status <code>mem_forwardInterval</code> (layer soundness) \u2713 Fully verified <code>mem_relu</code> \u2713 Fully verified <code>mem_sigmoid</code> \u2713 Fully verified <code>relu_relaxation_sound</code> (DeepPoly ReLU) \u2713 Fully verified <code>sigmoid_relaxation_sound</code> (DeepPoly Sigmoid) \u2713 Fully verified Optimized implementations Computationally correct, proofs in progress"},{"location":"ml/neural-networks/#use-cases","title":"Use Cases","text":"<ul> <li>Robustness Verification: Prove that small input perturbations don't change the output class</li> <li>Safety Certification: Verify that outputs stay within safe bounds</li> <li>Lipschitz Estimation: Bound the sensitivity of the network to input changes</li> </ul>"},{"location":"ml/neural-networks/#files","title":"Files","text":"File Description <code>ML/Network.lean</code> Layer and network definitions <code>ML/IntervalVector.lean</code> Activation functions (ReLU, sigmoid) <code>ML/Symbolic/ReLU.lean</code> DeepPoly ReLU relaxation <code>ML/Symbolic/Sigmoid.lean</code> DeepPoly sigmoid relaxation <code>ML/Optimized.lean</code> High-performance implementations <code>ML/LayerNormAffine.lean</code> Affine arithmetic for tight LayerNorm bounds <code>ML/Transformer.lean</code> Full transformer block definitions <code>ML/Attention.lean</code> Scaled dot-product attention verification <code>ML/Softmax.lean</code> Softmax interval propagation"},{"location":"python/pytorch/","title":"PyTorch Export","text":"<p>Export trained PyTorch models to Lean for formal verification.</p>"},{"location":"python/pytorch/#overview","title":"Overview","text":"<p>LeanCert can verify properties of neural networks, but first you need to convert your PyTorch model to Lean's representation. The <code>leancert.nn</code> module handles this conversion.</p>"},{"location":"python/pytorch/#quick-example","title":"Quick Example","text":"<pre><code>import torch\nimport torch.nn as nn\nimport leancert as lc\n\n# Your trained PyTorch model\nclass MyNetwork(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fc1 = nn.Linear(2, 4)\n        self.fc2 = nn.Linear(4, 1)\n\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        return self.fc2(x)\n\nmodel = MyNetwork()\nmodel.load_state_dict(torch.load(\"model.pt\"))\n\n# Convert to LeanCert\nnet = lc.nn.from_pytorch(model, input_names=['x1', 'x2'])\n\n# Export to Lean code\nlean_code = net.export_lean(\n    name=\"myNetwork\",\n    namespace=\"MyProject.Networks\",\n)\n\nprint(lean_code)\n</code></pre>"},{"location":"python/pytorch/#output","title":"Output","text":"<p>The exported Lean code looks like:</p> <pre><code>import LeanCert.ML.Network\n\nnamespace MyProject.Networks\n\ndef myNetwork : List Layer := [\n  { weights := [[1/2, -3/4], [1/8, 5/16], ...],\n    bias := [1/32, -1/64, ...] },\n  { weights := [[7/8, -1/2, 3/4, 1/4]],\n    bias := [0] }\n]\n\nend MyProject.Networks\n</code></pre>"},{"location":"python/pytorch/#api-reference","title":"API Reference","text":""},{"location":"python/pytorch/#from_pytorch","title":"<code>from_pytorch</code>","text":"<pre><code>lc.nn.from_pytorch(\n    model: nn.Module,\n    input_names: List[str],\n    max_denominator: int = 1000\n) -&gt; Network\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>model</code> <code>nn.Module</code> Trained PyTorch model <code>input_names</code> <code>List[str]</code> Names for input variables <code>max_denominator</code> <code>int</code> Max denominator for rational approximation <p>Supported layers: - <code>nn.Linear</code> - <code>nn.ReLU</code> - <code>nn.Sigmoid</code> (converted to interval bounds)</p>"},{"location":"python/pytorch/#export_lean","title":"<code>export_lean</code>","text":"<pre><code>net.export_lean(\n    name: str,\n    namespace: str = \"LeanCert.Examples\",\n    include_imports: bool = True\n) -&gt; str\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>name</code> <code>str</code> Lean definition name <code>namespace</code> <code>str</code> Lean namespace <code>include_imports</code> <code>bool</code> Include import statements"},{"location":"python/pytorch/#layerfrom_numpy","title":"<code>Layer.from_numpy</code>","text":"<p>For direct NumPy array import:</p> <pre><code>import numpy as np\n\nweights = np.array([[1.0, -0.5], [0.25, 0.75]])\nbias = np.array([0.1, -0.2])\n\nlayer = lc.nn.Layer.from_numpy(weights, bias, max_denominator=100)\n</code></pre>"},{"location":"python/pytorch/#rational-approximation","title":"Rational Approximation","text":"<p>Neural network weights are floats, but Lean verification uses exact rationals. LeanCert approximates each weight as a fraction:</p> <pre><code># float 0.333... becomes 1/3\n# float 0.142857... becomes 1/7\n</code></pre> <p>The <code>max_denominator</code> parameter controls precision:</p> <code>max_denominator</code> Precision Verification Speed 100 Low Fast 1000 Medium Medium 10000 High Slow <p>Tip: Start with <code>max_denominator=100</code> for quick verification, increase if bounds are too loose.</p>"},{"location":"python/pytorch/#verification-workflow","title":"Verification Workflow","text":"<pre><code># 1. Export model\nnet = lc.nn.from_pytorch(model, ['x'])\nlean_code = net.export_lean(name=\"classifier\")\n\n# 2. Save to file\nwith open(\"MyNetwork.lean\", \"w\") as f:\n    f.write(lean_code)\n\n# 3. In Lean, verify properties\n</code></pre> <pre><code>-- MyNetwork.lean (generated)\nimport LeanCert.ML.Network\n\ndef classifier : List Layer := [...]\n\n-- Verify robustness\ntheorem classifier_robust :\n    \u2200 x \u2208 inputDomain, \u2200 \u03b4 \u2208 perturbation,\n    classifier.forward (x + \u03b4) = classifier.forward x := by\n  -- Use interval propagation\n  native_decide\n</code></pre>"},{"location":"python/pytorch/#supported-architectures","title":"Supported Architectures","text":"Architecture Support Feedforward (MLP) Full Convolutional Flatten first RNN/LSTM Not supported Transformer Manual conversion <p>For transformers, use the <code>LeanCert.ML.Transformer</code> module directly in Lean.</p>"},{"location":"python/pytorch/#example-mnist-classifier","title":"Example: MNIST Classifier","text":"<pre><code>import torch\nimport torch.nn as nn\nimport leancert as lc\n\nclass MNISTNet(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fc1 = nn.Linear(784, 128)\n        self.fc2 = nn.Linear(128, 10)\n\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        return self.fc2(x)\n\n# Load trained model\nmodel = MNISTNet()\nmodel.load_state_dict(torch.load(\"mnist.pt\"))\n\n# Export with reasonable precision\nnet = lc.nn.from_pytorch(\n    model,\n    input_names=[f'pixel_{i}' for i in range(784)],\n    max_denominator=1000\n)\n\n# Generate Lean code\nlean_code = net.export_lean(\n    name=\"mnistClassifier\",\n    namespace=\"MNIST\"\n)\n\n# Save\nwith open(\"MNISTClassifier.lean\", \"w\") as f:\n    f.write(lean_code)\n</code></pre>"},{"location":"python/pytorch/#transformer-export","title":"Transformer Export","text":"<p>LeanCert supports exporting Transformer architectures for formal verification.</p>"},{"location":"python/pytorch/#quick-example_1","title":"Quick Example","text":"<pre><code>import torch\nimport torch.nn as nn\nimport leancert as lc\n\n# Create a PyTorch transformer\nencoder_layer = nn.TransformerEncoderLayer(d_model=64, nhead=4)\ntransformer = nn.TransformerEncoder(encoder_layer, num_layers=2)\n\n# Export to LeanCert\nencoder = lc.nn.from_pytorch_transformer(transformer)\n\n# Generate Lean code with affine arithmetic for tight LayerNorm bounds\nlean_code = encoder.export_lean(\n    name=\"myTransformer\",\n    namespace=\"MyProject.Transformers\",\n    input_domain={f\"x{i}\": (-1, 1) for i in range(64)},\n    use_affine_layernorm=True,  # Use affine arithmetic for tighter bounds\n)\n</code></pre>"},{"location":"python/pytorch/#from_pytorch_transformer","title":"<code>from_pytorch_transformer</code>","text":"<pre><code>lc.nn.from_pytorch_transformer(\n    model: nn.Module,\n    input_names: List[str] = None,\n    max_denominator: int = 10000,\n    description: str = \"\"\n) -&gt; TransformerEncoder\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>model</code> <code>nn.Module</code> PyTorch transformer model <code>input_names</code> <code>List[str]</code> Names for input variables (default: x0, x1, ...) <code>max_denominator</code> <code>int</code> Max denominator for rational approximation <code>description</code> <code>str</code> Optional description for documentation <p>Supported architectures:</p> <ul> <li><code>nn.TransformerEncoder</code> with <code>nn.TransformerEncoderLayer</code></li> <li>Custom models with <code>norm1</code>/<code>norm2</code> and <code>linear1</code>/<code>linear2</code> attributes</li> <li>BERT-style models with <code>encoder.layer[i]</code> structure</li> </ul>"},{"location":"python/pytorch/#transformer-components","title":"Transformer Components","text":"<p>The export creates these Lean structures:</p>"},{"location":"python/pytorch/#layernormparams","title":"<code>LayerNormParams</code>","text":"<pre><code>lc.nn.LayerNormParams.from_numpy(\n    gamma: np.ndarray,   # Scale parameter\n    beta: np.ndarray,    # Shift parameter\n    epsilon: float = 1e-6,\n    max_denom: int = 10000\n)\n</code></pre>"},{"location":"python/pytorch/#ffnblock","title":"<code>FFNBlock</code>","text":"<p>Feed-forward network with GELU activation:</p> <pre><code>lc.nn.FFNBlock.from_numpy(\n    w1: np.ndarray,  # First linear weights\n    b1: np.ndarray,  # First linear bias\n    w2: np.ndarray,  # Second linear weights\n    b2: np.ndarray,  # Second linear bias\n    max_denom: int = 10000\n)\n</code></pre>"},{"location":"python/pytorch/#transformerblock","title":"<code>TransformerBlock</code>","text":"<p>A single transformer layer (LayerNorm \u2192 FFN \u2192 Residual \u2192 LayerNorm):</p> <pre><code>block = lc.nn.TransformerBlock(\n    ln1=layer_norm_params_1,\n    ffn=ffn_block,\n    ln2=layer_norm_params_2\n)\n</code></pre>"},{"location":"python/pytorch/#transformerencoder","title":"<code>TransformerEncoder</code>","text":"<p>Complete encoder with multiple blocks:</p> <pre><code>encoder = lc.nn.TransformerEncoder(\n    blocks=[block1, block2, ...],\n    final_ln=optional_final_layernorm,\n    input_names=[\"x0\", \"x1\", ...]\n)\n</code></pre>"},{"location":"python/pytorch/#affine-arithmetic-for-layernorm","title":"Affine Arithmetic for LayerNorm","text":"<p>Standard interval arithmetic can produce loose bounds for LayerNorm due to the \"dependency problem\" - the mean and variance are computed from the same input, creating correlations that interval arithmetic ignores.</p> <p>LeanCert provides affine arithmetic for tighter LayerNorm bounds:</p> <pre><code># Enable affine arithmetic (recommended for transformers)\nlean_code = encoder.export_lean(\n    name=\"transformer\",\n    use_affine_layernorm=True  # Uses forwardIntervalTight\n)\n</code></pre> <p>This uses <code>LeanCert.ML.LayerNormAffine</code> which tracks linear correlations between variables.</p>"},{"location":"python/pytorch/#generated-lean-code","title":"Generated Lean Code","text":"<p>The export generates Lean code that:</p> <ol> <li>Defines rational weight/bias matrices</li> <li>Creates <code>TransformerBlock</code> structures</li> <li>Provides well-formedness proofs</li> <li>Computes output bounds via interval propagation</li> </ol> <pre><code>-- Generated code example\nimport LeanCert.ML.Transformer\nimport LeanCert.ML.LayerNormAffine\n\nnamespace MyProject.Transformers\n\n-- Layer definitions...\n\ndef myTransformerBlocks : List TransformerBlock := [...]\n\ndef myTransformerForward (x : IntervalVector) : IntervalVector :=\n  myTransformerBlocks.foldl (fun acc blk =&gt; blk.forwardIntervalTight acc (-53)) x\n\n#eval myTransformerOutputBounds.map (fun I =&gt; (I.lo.toRat, I.hi.toRat))\n\nend MyProject.Transformers\n</code></pre>"},{"location":"python/pytorch/#limitations","title":"Limitations","text":"<ol> <li> <p>Float precision: Rational approximation introduces small errors. Verify that <code>max_denominator</code> is sufficient for your use case.</p> </li> <li> <p>Large models: Models with millions of parameters generate large Lean files. Consider verifying critical subnetworks.</p> </li> <li> <p>Activations: Only ReLU, Sigmoid, and GELU are directly supported. Other activations need manual interval implementations.</p> </li> <li> <p>Attention: Self-attention mechanisms are verified in Lean (<code>LeanCert.ML.Attention</code>) but not automatically extracted from PyTorch. Export the FFN portion and verify attention separately.</p> </li> </ol>"},{"location":"python/validation/","title":"Bug Validation Framework","text":"<p>LeanCert includes a validation framework to filter false positives from counter-example searches.</p>"},{"location":"python/validation/#the-problem","title":"The Problem","text":"<p>Static analysis and interval arithmetic can report \"violations\" that aren't real bugs:</p> <ul> <li>Interval explosion: Wide bounds due to the dependency problem</li> <li>Precision artifacts: Floating-point rounding in the checker</li> <li>Intentional behavior: Code that's designed to handle edge cases</li> </ul> <p>The validation framework helps distinguish real bugs from false alarms.</p>"},{"location":"python/validation/#quick-example","title":"Quick Example","text":"<pre><code>import leancert as lc\nfrom leancert.validation import BugValidator, BugReport, Box\n\n# Expression that might have issues\nx = lc.var('x')\nexpr = 1 / (x - 1)  # Singularity at x = 1\n\n# Find potential violations\nresult = lc.find_bounds(expr, {'x': (0.5, 1.5)})\n\n# Create a bug report\nbug = BugReport(\n    description=\"Potential division by zero\",\n    location=\"math_utils.py:42\",\n    severity=\"high\",\n    expression=expr,\n    domain=Box({'x': (0.5, 1.5)}),\n    bounds_result=result,\n    claimed_violation=\"unbounded output\"\n)\n\n# Validate if the issue is real\nvalidator = BugValidator()\nresult = validator.validate(bug)\n\nprint(result)\n# ValidationResult(\n#   verdict=ValidationVerdict.CONFIRMED,\n#   confidence=0.8,\n#   reason=\"Monte Carlo sampling confirms bounds\"\n# )\n</code></pre>"},{"location":"python/validation/#components","title":"Components","text":""},{"location":"python/validation/#bugvalidator","title":"<code>BugValidator</code>","text":"<p>Main entry point for validation.</p> <pre><code>from leancert.validation import BugValidator, BugReport\n\nvalidator = BugValidator()\nresult = validator.validate(bug)  # Takes a BugReport object\n</code></pre> <p>Constructor parameters:</p> <pre><code>validator = BugValidator(\n    explosion_detector=None,       # Optional custom IntervalExplosionDetector\n    comment_analyzer=None,         # Optional custom CommentAnalyzer\n    counterexample_verifier=None   # Optional custom CounterexampleVerifier\n)\n</code></pre>"},{"location":"python/validation/#intervalexplosiondetector","title":"<code>IntervalExplosionDetector</code>","text":"<p>Detects if bounds blew up due to interval arithmetic limitations, not actual unboundedness.</p> <pre><code>import leancert as lc\nfrom leancert.validation import IntervalExplosionDetector\n\nx = lc.var('x')\ndetector = IntervalExplosionDetector()\n\n# First compute bounds\nresult = lc.find_bounds(x * x - x * x, {'x': (-1, 1)})\n\n# Check if wide bounds are due to dependency problem\nis_explosion, reason = detector.detect_explosion(result)\nprint(f\"Is explosion: {is_explosion}, Reason: {reason}\")\n</code></pre> <p>You can also use the convenience function:</p> <pre><code>is_explosion, reason = lc.detect_interval_explosion(result)\n</code></pre> <p>Common explosion patterns: - <code>x - x</code> -&gt; should be 0, interval gives wide bounds - <code>x * (1/x)</code> -&gt; should be 1, interval gives wide bounds - Correlated variables in LayerNorm</p>"},{"location":"python/validation/#counterexampleverifier","title":"<code>CounterexampleVerifier</code>","text":"<p>Concretely evaluates the expression at reported counter-example points using Monte Carlo sampling.</p> <pre><code>from leancert.validation import CounterexampleVerifier\n\nverifier = CounterexampleVerifier()\n\n# Monte Carlo verification over the domain\nis_confirmed, observed_min, observed_max = verifier.monte_carlo_verify(\n    expr=x**2,\n    domain={'x': (-2, 2)},\n    n_samples=1000\n)\n\n# Or verify a specific counterexample point\nis_real = verifier.verify_counterexample(\n    expr=x**2,\n    point={'x': 2.0},\n    claimed_value=3.0,\n    is_upper=True\n)\n# Returns True - x\u00b2=4 really does exceed 3\n</code></pre> <p>Convenience function for concrete verification:</p> <pre><code>is_real = lc.verify_counterexample_concrete(\n    expr=x**2,\n    counterexample={'x': 2.0},\n    claimed_max=3.0\n)\n</code></pre>"},{"location":"python/validation/#commentanalyzer","title":"<code>CommentAnalyzer</code>","text":"<p>Checks code context for indicators that behavior is intentional.</p> <pre><code>from leancert.validation import CommentAnalyzer\n\nanalyzer = CommentAnalyzer()\n\ncode_context = \"\"\"\n# NOTE: This can return infinity for x near 0\n# This is expected behavior - caller handles it\ndef f(x):\n    return 1/x\n\"\"\"\n\nis_intentional, pattern = analyzer.is_intentional_protection(code_context)\n# Returns (True, \"expected behavior\") - comment indicates intentional behavior\n</code></pre> <p>Convenience function:</p> <pre><code>is_intentional, matched_pattern = lc.is_intentional_behavior(code_context)\n</code></pre> <p>Detected patterns: - <code># expected</code>, <code># intentional</code>, <code># by design</code> - <code># TODO: handle edge case</code> - <code># FIXME</code> (indicates known issue) - Overflow/underflow protection comments</p>"},{"location":"python/validation/#validationresult","title":"ValidationResult","text":"<p>Result of validation:</p> <pre><code>@dataclass\nclass ValidationResult:\n    verdict: ValidationVerdict      # Enum: CONFIRMED, FALSE_POSITIVE, DESIGN_INTENT, NEEDS_REVIEW\n    confidence: float               # 0.0 to 1.0\n    reason: str                     # Human-readable explanation\n    counterexample: dict | None     # Concrete input triggering issue (if found)\n    concrete_value: float | None    # Actual computed value at counterexample\n    interval_width: float | None    # Width of the interval bounds\n    matched_pattern: str | None     # Pattern matched (for design intent)\n</code></pre>"},{"location":"python/validation/#validationverdict-enum","title":"<code>ValidationVerdict</code> Enum","text":"<pre><code>class ValidationVerdict(Enum):\n    CONFIRMED = \"confirmed\"           # Real bug confirmed\n    FALSE_POSITIVE = \"false_positive\" # Interval explosion or precision artifact\n    DESIGN_INTENT = \"design_intent\"   # Code comments indicate intentional behavior\n    NEEDS_REVIEW = \"needs_review\"     # Uncertain, manual review recommended\n</code></pre>"},{"location":"python/validation/#validation-pipeline","title":"Validation Pipeline","text":"<p>The <code>BugValidator</code> runs multiple checks:</p> <pre><code>Reported Issue\n      |\n      v\n+------------------+\n| Interval         |--&gt; If explosion detected,\n| Explosion Check  |    likely false positive\n+------------------+\n      |\n      v\n+------------------+\n| Counterexample   |--&gt; Concrete evaluation\n| Verification     |    confirms or refutes\n+------------------+\n      |\n      v\n+------------------+\n| Comment          |--&gt; Check for intentional\n| Analysis         |    behavior markers\n+------------------+\n      |\n      v\n   Verdict\n</code></pre>"},{"location":"python/validation/#bugreport","title":"BugReport","text":"<p>Structured bug report for validation:</p> <pre><code>@dataclass\nclass BugReport:\n    description: str                    # Human-readable description\n    location: str                       # File and line (e.g., \"utils.py:42\")\n    severity: str                       # \"low\", \"medium\", \"high\", \"critical\"\n    expression: Expr | None = None      # The expression with potential issue\n    domain: Box | None = None           # Input domain\n    bounds_result: BoundsResult | None = None  # Result from find_bounds\n    claimed_violation: str | None = None       # Type of violation claimed\n    bound_value: float | None = None    # The bound that was violated\n    source_code: str | None = None      # Source code context for comment analysis\n</code></pre>"},{"location":"python/validation/#integration-with-ci","title":"Integration with CI","text":"<pre><code>import leancert as lc\nfrom leancert.validation import BugValidator, BugReport, Box, ValidationVerdict\n\ndef check_expression(expr, domain, location):\n    \"\"\"Check an expression for real bugs, filtering false positives.\"\"\"\n    validator = BugValidator()\n\n    # Run interval analysis\n    bounds = lc.find_bounds(expr, domain)\n\n    # Create bug report\n    bug = BugReport(\n        description=\"Potential bound violation\",\n        location=location,\n        severity=\"medium\",\n        expression=expr,\n        domain=Box(domain),\n        bounds_result=bounds\n    )\n\n    # Validate\n    result = validator.validate(bug)\n\n    if result.verdict == ValidationVerdict.CONFIRMED and result.confidence &gt; 0.8:\n        return bug  # Real bug\n    return None\n\n# In CI pipeline\nx = lc.var('x')\nbug = check_expression(1/x, {'x': (-1, 1)}, \"math.py:10\")\nif bug:\n    print(f\"Found real bug at {bug.location}\")\n    sys.exit(1)\n</code></pre>"},{"location":"python/validation/#example-filtering-false-positives","title":"Example: Filtering False Positives","text":"<pre><code>import leancert as lc\nfrom leancert.validation import BugValidator, BugReport, Box, ValidationVerdict\n\nx = lc.var('x')\n\n# Case 1: False positive - interval explosion\nexpr1 = (x + 1) * (x - 1) - (x*x - 1)  # Algebraically 0\nresult1 = lc.find_bounds(expr1, {'x': (-10, 10)})\n\nbug1 = BugReport(\n    description=\"Large bounds detected\",\n    location=\"test.py:10\",\n    severity=\"medium\",\n    expression=expr1,\n    domain=Box({'x': (-10, 10)}),\n    bounds_result=result1\n)\n\nvalidator = BugValidator()\nverdict1 = validator.validate(bug1)\nprint(f\"Case 1: {verdict1.verdict}\")  # FALSE_POSITIVE or CONFIRMED with low confidence\n\n# Case 2: Real bug - division by zero possible\nexpr2 = 1 / x\nresult2 = lc.find_bounds(expr2, {'x': (-1, 1)})\n\nbug2 = BugReport(\n    description=\"Division may be undefined\",\n    location=\"test.py:20\",\n    severity=\"high\",\n    expression=expr2,\n    domain=Box({'x': (-1, 1)}),\n    bounds_result=result2\n)\n\nverdict2 = validator.validate(bug2)\nprint(f\"Case 2: {verdict2.verdict}\")  # CONFIRMED (x=0 causes real issue)\n</code></pre>"}]}