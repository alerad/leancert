# Verification Status

LeanBound aims for full formal verification. This page documents what is **fully proved** versus what contains `sorry` (unfinished proofs).

## Fully Verified

The following components have complete proofs with no `sorry`:

### Interval Arithmetic (FTIA)

The Fundamental Theorem of Interval Arithmetic is proved for all basic operations:

- Addition, subtraction: \\( x \in I_1, y \in I_2 \implies x + y \in I_1 + I_2 \\)
- Multiplication: \\( x \in I_1, y \in I_2 \implies x \cdot y \in I_1 \cdot I_2 \\)
- Division: \\( x \in I_1, y \in I_2, 0 \notin I_2 \implies x / y \in I_1 / I_2 \\)
- Power: \\( x \in I \implies x^n \in I^n \\)

### Transcendental Functions

Rigorous bounds via Taylor series with verified remainder terms:

| Function | Theorem | Location |
|----------|---------|----------|
| \\( e^x \\) | `mem_expInterval` | `Core/IntervalReal.lean` |
| \\( \sin x \\) | `mem_sinInterval` | `Core/IntervalReal.lean` |
| \\( \cos x \\) | `mem_cosInterval` | `Core/IntervalReal.lean` |
| \\( \log x \\) | `mem_logInterval` | `Core/IntervalReal.lean` |
| \\( \sinh x \\) | `mem_sinhInterval` | `Core/IntervalReal.lean` |
| \\( \cosh x \\) | `mem_coshInterval` | `Core/IntervalReal.lean` |
| \\( \tanh x \\) | `mem_tanhInterval` | `Core/IntervalReal.lean` |
| \\( \arctan x \\) | `mem_atanInterval` | `Core/IntervalReal.lean` |
| \\( \text{arsinh} x \\) | `mem_arsinhInterval` | `Core/IntervalReal.lean` |

### Taylor Series

The core Taylor remainder bounds are fully proved:

```lean
theorem taylor_remainder_bound (f : ℝ → ℝ) (n : ℕ) (a x : ℝ) ...
```

This is the foundation for all transcendental function bounds.

### Automatic Differentiation

Forward-mode AD with verified value and derivative bounds:

- `evalDual_val_correct`: Value component is correct
- `evalDual_der_correct`: Derivative component is correct

### Global Optimization

Branch-and-bound with formal guarantees:

- `globalMinimize_lo_correct`: Lower bound is valid
- `globalMaximize_hi_correct`: Upper bound is valid

### Root Finding

- **Bisection**: `verify_sign_change` proves existence via IVT
- **Newton**: `verify_unique_root_core` proves uniqueness via contraction

### Integration

- `integrateInterval_correct`: Riemann sum bounds contain the true integral

## Incomplete (Contains `sorry`)

These features work computationally but have gaps in formal proofs:

| Component | Issue | Impact |
|-----------|-------|--------|
| `atanh` interval | `mem_atanhInterval` fallback uses `sorry` | Low - Taylor model path verified |
| `atanh` Taylor | `atanh_series_remainder_bound` incomplete | Medium - affects precision |
| `log` Taylor model | `tmLog_correct` incomplete | Low - basic interval verified |
| `sinc` derivative | Missing `Differentiable ℝ Real.sinc` | Low - exotic function |
| `erf` derivative | Missing `Differentiable ℝ Real.erf` | Low - exotic function |

## Finding Sorries

To audit the codebase yourself:

```bash
grep -r "sorry" --include="*.lean" LeanBound/ | grep -v "no sorry"
```

Current count: ~12 `sorry` occurrences, all in edge cases for exotic functions.

## What This Means

**For typical use cases** (polynomials, `sin`, `cos`, `exp`, `log`, optimization, root finding):

> The verification is complete. Proofs generated by LeanBound are accepted by the Lean kernel with no axioms beyond standard Mathlib foundations.

**For `atanh`, `sinc`, `erf`**:

> These work computationally, but formal proofs have gaps. Use with awareness that the Lean proofs contain `sorry`.
